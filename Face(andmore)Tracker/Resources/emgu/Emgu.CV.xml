<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emgu.CV</name>
    </assembly>
    <members>
        <member name="T:Emgu.CV.CalibrateCRF">
            <summary>
            The base class for camera response calibration algorithms.
            </summary>
        </member>
        <member name="F:Emgu.CV.CalibrateCRF._calibrateCRFPtr">
            <summary>
            The pointer the the calibrateCRF object
            </summary>
        </member>
        <member name="M:Emgu.CV.CalibrateCRF.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Recovers inverse camera response.
            </summary>
            <param name="src">Vector of input images</param>
            <param name="dst">256x1 matrix with inverse camera response function</param>
            <param name="times">Vector of exposure time values for each image</param>
        </member>
        <member name="T:Emgu.CV.CvInvoke">
            <summary>
            Library to invoke OpenCV functions
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.StringMarshalType">
            <summary>
            string marshaling type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.BoolMarshalType">
            <summary>
            Represent a bool value in C++
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.BoolToIntMarshalType">
            <summary>
            Represent a int value in C++
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvCallingConvention">
            <summary>
            Opencv's calling convention
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.ExternLibrary">
            <summary>
            The file name of the cvextern library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.ExternCudaLibrary">
            <summary>
            The file name of the cvextern library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvFFMpegLibrary">
            <summary>
            The file name of the opencv_ffmpeg library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpenclLibrary">
            <summary>
            The file name of the OpenCL library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCoreLibrary">
            <summary>
            The file name of the core library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvImgprocLibrary">
            <summary>
            The file name of the imgproc library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvVideoLibrary">
            <summary>
            The file name of the video library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvFlannLibrary">
            <summary>
            The file name of the flann library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvMlLibrary">
            <summary>
            The file name of the ml library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvImgcodecsLibrary">
            <summary>
            The file name of the imgcodecs library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvVideoioLibrary">
            <summary>
            The file name of the videoio library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvHighguiLibrary">
            <summary>
            The file name of the highgui library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvObjdetectLibrary">
            <summary>
            The file name of the objdetect library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvFeatures2dLibrary">
            <summary>
            The file name of the features2d library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCalib3dLibrary">
            <summary>
            The file name of the calib3d library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudalegacyLibrary">
            <summary>
            The file name of the cudalegacy library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudaarithmLibrary">
            <summary>
            The file name of the cudaarithm library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudawarpingLibrary">
            <summary>
            The file name of the cudawarping library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudaLibrary">
            <summary>
            The file name of the cuda library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudafiltersLibrary">
            <summary>
            The file name of the cudafilters library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudaimgprocLibrary">
            <summary>
            The file name of the cudaimgproc library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudaoptflowLibrary">
            <summary>
            The file name of the cudaoptflow library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudastereoLibrary">
            <summary>
            The file name of the cudastereo library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudabgsegmLibrary">
            <summary>
            The file name of the cudabgsegm library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudafeatures2dLibrary">
            <summary>
            The file name of the cudafeatures2d library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvPhotoLibrary">
            <summary>
            The file name of the photo library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvSuperresLibrary">
            <summary>
            The file name of the superres library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvStitchingLibrary">
            <summary>
            The file name of the stitching library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvVideostabLibrary">
            <summary>
            The file name of the videostab library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvShapeLibrary">
            <summary>
            The file name of the shape library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudevLibrary">
            <summary>
            The file name of the cudev library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvCudacodecLibrary">
            <summary>
            The file name of the cudacodec library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvTextLibrary">
            <summary>
            The file name of the text library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvFaceLibrary">
            <summary>
            The file name of the face library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvXimgprocLibrary">
            <summary>
            The file name of the ximgproc library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvXobjdetectLibrary">
            <summary>
            The file name of the xobjdetect library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvXfeatures2dLibrary">
            <summary>
            The file name of the xfeatures2d library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvBgsegmLibrary">
            <summary>
            The file name of the bgsegm library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvOptflowLibrary">
            <summary>
            The file name of the optflow library
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureCreateFromDevice(System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed</param>
            <returns>Pointer to the capture structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureCreateFromFile(System.IntPtr)">
             <summary>
             Allocates and initialized the CvCapture structure for reading the video stream from the specified file. 
            After the allocated structure is not used any more it should be released by cvReleaseCapture function. 
             </summary>
             <param name="filename">Name of the video file.</param>
             <returns>Pointer to the capture structure.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureRelease(System.IntPtr@)">
            <summary>
            The function cvReleaseCapture releases the CvCapture structure allocated by cvCreateFileCapture or cvCreateCameraCapture
            </summary>
            <param name="capture">pointer to video capturing structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureRead(System.IntPtr,System.IntPtr)">
            <summary>
            Grabs a frame from camera or video file, decompresses and returns it. This function is just a combination of cvGrabFrame and cvRetrieveFrame in one call. 
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="frame">The output frame</param>
            <returns>true id a frame is read</returns>
            <remarks>The returned image should not be released or modified by user. </remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureGrab(System.IntPtr)">
            <summary>
            Grab a frame
            </summary>
            <param name="capture">Video capturing structure</param>
            <returns>True on success</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureRetrieve(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Get the frame grabbed with cvGrabFrame(..)
            This function may apply some frame processing like frame decompression, flipping etc.
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="image">The output image</param>
            <param name="flag">The frame retrieve flag</param>
            <returns>True on success</returns>
            <remarks>The returned image should not be released or modified by user. </remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureGet(System.IntPtr,Emgu.CV.CvEnum.CapProp)">
            <summary>
            Retrieves the specified property of camera or video file
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="prop">Property identifier</param>
            <returns>The specified property of camera or video file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureSet(System.IntPtr,Emgu.CV.CvEnum.CapProp,System.Double)">
            <summary>
            Sets the specified property of video capturing
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="propertyId">Property identifier</param>
            <param name="value">Value of the property</param>
            <returns>True on success</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CheckLibraryLoaded">
            <summary>
            Check to make sure all the unmanaged libraries are loaded
            </summary>
            <returns>True if library loaded</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LoadUnmanagedModules(System.String,System.String[])">
            <summary>
            Attemps to load opencv modules from the specific location
            </summary>
            <param name="loadDirectory">The directory where the unmanaged modules will be loaded. If it is null, the default location will be used.</param>
            <param name="unmanagedModules">The names of opencv modules. e.g. "opencv_cxcore.dll" on windows.</param>
            <returns>True if all the modules has been loaded sucessfully</returns>
            <remarks>If <paramref name="loadDirectory"/> is null, the default location on windows is the dll's path appended by either "x64" or "x86", depends on the applications current mode.</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetModuleFormatString">
            <summary>
            Get the module format string.
            </summary>
            <returns>On Windows, "{0}".dll will be returned; On Linux, "lib{0}.so" will be returned; Otherwise {0} is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.#cctor">
            <summary>
            Static Constructor to setup opencv environment
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDepthType(Emgu.CV.CvEnum.DepthType)">
            <summary>
            Get the corresponding depth type
            </summary>
            <param name="t">The opencv depth type</param>
            <returns>The equivalent depth type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDepthType(System.Type)">
            <summary>
            Get the corresponding opencv depth type
            </summary>
            <param name="t">The element type</param>
            <returns>The equivalent opencv depth type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MakeType(Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            This function performs the same as MakeType macro
            </summary>
            <param name="depth">The type of depth</param>
            <param name="channels">The number of channels</param>
            <returns>An interger tha represent a mat type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SanityCheck">
            <summary>
            Check if the size of the C structures match those of C#
            </summary>
            <returns>True if the size matches</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindHomography(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.HomographyMethod,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Finds perspective transformation H=||hij|| between the source and the destination planes
            </summary>
            <param name="srcPoints">Point coordinates in the original plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogeneous coordinates), where N is the number of points. </param>
            <param name="dstPoints">Point coordinates in the destination plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogeneous coordinates) </param>
            <param name="method">The type of the method</param>
            <param name="ransacReprojThreshold">The maximum allowed re-projection error to treat a point pair as an inlier. The parameter is only used in RANSAC-based homography estimation. E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3</param>
            <param name="mask">The optional output mask set by a robust method (RANSAC or LMEDS). </param>
            <param name="homography">Output 3x3 homography matrix. Homography matrix is determined up to a scale, thus it is normalized to make h33=1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Rodrigues(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts a rotation vector to rotation matrix or vice versa. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. 
            </summary>
            <param name="src">The input rotation vector (3x1 or 1x3) or rotation matrix (3x3). </param>
            <param name="dst">The output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9 or 9x3 - partial derivatives of the output array components w.r.t the input array components</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindFundamentalMat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.FmType,System.Double,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Calculates fundamental matrix using one of four methods listed above and returns the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. 
            </summary>
            <param name="points1">Array of N points from the first image. The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 </param>
            <param name="method">Method for computing the fundamental matrix </param>
            <param name="param1">Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="param2">Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="mask">The optional pointer to output array of N elements, every element of which is set to 0 for outliers and to 1 for the "inliers", i.e. points that comply well with the estimated epipolar geometry. The array is computed only in RANSAC and LMedS methods. For other methods it is set to all 1.</param>
            <param name="f">The calculated fundamental matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ComputeCorrespondEpilines(Emgu.CV.IInputArray,System.Int32,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            For every point in one of the two images of stereo-pair the function cvComputeCorrespondEpilines finds equation of a line that contains the corresponding point (i.e. projection of the same 3D point) in the other image. Each line is encoded by a vector of 3 elements l=[a,b,c]^T, so that: 
            l^T*[x, y, 1]^T=0, or
            a*x + b*y + c = 0
            From the fundamental matrix definition (see cvFindFundamentalMatrix discussion), line l2 for a point p1 in the first image (which_image=1) can be computed as: 
            l2=F*p1 and the line l1 for a point p2 in the second image (which_image=1) can be computed as: 
            l1=F^T*p2Line coefficients are defined up to a scale. They are normalized (a2+b2=1) are stored into correspondent_lines
            </summary>
            <param name="points">The input points. 2xN, Nx2, 3xN or Nx3 array (where N number of points). Multi-channel 1xN or Nx1 array is also acceptable.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points</param>
            <param name="fundamentalMatrix">Fundamental matrix </param>
            <param name="correspondentLines">Computed epilines, 3xN or Nx3 array </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertPointsToHomogeneous(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts points from Euclidean to homogeneous space.
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N+1-dimensional points.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertPointsFromHomogeneous(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts points from homogeneous to Euclidean space.
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N-1-dimensional points.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ReprojectImageTo3D(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Boolean,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Transforms 1-channel disparity map to 3-channel image, a 3D surface.
            </summary>
            <param name="disparity">Disparity map</param>
            <param name="image3D">3-channel, 16-bit integer or 32-bit floating-point image - the output map of 3D points</param>
            <param name="q">The reprojection 4x4 matrix, can be arbitrary, e.g. the one, computed by cvStereoRectify</param>
            <param name="handleMissingValues">Indicates, whether the function should handle missing values (i.e. points where the disparity was not computed). 
            If handleMissingValues=true, then pixels with the minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) 
            are transformed to 3D points with a very large Z value (currently set to 10000).</param>
            <param name="ddepth">The optional output array depth. If it is -1, the output image will have CV_32F depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ProjectPoints(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters.
            Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points). 
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="rvec">The rotation vector, 1x3 or 3x1</param>
            <param name="tvec">The translation vector, 1x3 or 3x1</param>
            <param name="cameraMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's</param>
            <param name="imagePoints">The output array of image points, 2xN or Nx2, where N is the total number of points in the view</param>
            <param name="aspectRatio">Aspect ratio</param>
            <param name="jacobian">Optional output 2Nx(10+&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrateCamera(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Estimates intrinsic camera parameters and extrinsic parameters for each of the views
            </summary>
            <param name="objectPoints">The joint matrix of object points, 3xN or Nx3, where N is the total number of points in all views</param>
            <param name="imagePoints">The joint matrix of corresponding image points, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="cameraMatrix">The output camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATION are specified, some or all of fx, fy, cx, cy must be initialized</param>
            <param name="distortionCoeffs">The output 4x1 or 1x4 vector of distortion coefficients [k1, k2, p1, p2]</param>
            <param name="rotationVectors">The output 3xM or Mx3 array of rotation vectors (compact representation of rotation matrices, see cvRodrigues2). </param>
            <param name="translationVectors">The output 3xM or Mx3 array of translation vectors</param>
            <param name="flags">Different flags</param>
            <param name="termCriteria">The termination criteria</param>
            <returns>The final reprojection error</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrationMatrixValues(Emgu.CV.IInputArray,System.Drawing.Size,System.Double,System.Double,System.Double@,System.Double@,System.Double@,Emgu.CV.Structure.MCvPoint2D64f@,System.Double@)">
            <summary>
            Computes various useful camera (sensor/lens) characteristics using the computed camera calibration matrix, image frame resolution in pixels and the physical aperture size
            </summary>
            <param name="cameraMatrix">The matrix of intrinsic parameters</param>
            <param name="imageSize">Image size in pixels</param>
            <param name="apertureWidth">Aperture width in real-world units (optional input parameter). Set it to 0 if not used</param>
            <param name="apertureHeight">Aperture width in real-world units (optional input parameter). Set it to 0 if not used</param>
            <param name="fovx">Field of view angle in x direction in degrees</param>
            <param name="fovy">Field of view angle in y direction in degrees </param>
            <param name="focalLength">Focal length in real-world units </param>
            <param name="principalPoint">The principal point in real-world units </param>
            <param name="aspectRatio">The pixel aspect ratio ~ fy/f</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnP(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="imagePoints">The array of corresponding image points, 2xN or Nx2, where N is the number of points in the view</param>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's.</param>
            <param name="rotationVector">The output 3x1 or 1x3 rotation vector (compact representation of a rotation matrix, see cvRodrigues2). </param>
            <param name="translationVector">The output 3x1 or 1x3 translation vector</param>
            <param name="useExtrinsicGuess">Use the input rotation and translation parameters as a guess</param>
            <param name="flags">Method for solving a PnP problem</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnPRansac(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,System.Int32,System.Single,System.Int32,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. VectorOfPoint3D32f can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. VectorOfPointF can be also passed here.</param>
            <param name="cameraMatrix">Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients of 4, 5, 8 or 12 elements. If the vector is null/empty, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector </param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="iterationsCount">Number of iterations.</param>
            <param name="reprojectionError">Inlier threshold value used by the RANSAC procedure. The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier.</param>
            <param name="minInliersCount">Number of inliers. If the algorithm at some stage finds more inliers than minInliersCount, it finishes.</param>
            <param name="inliers">Output vector that contains indices of inliers in objectPoints and imagePoints .</param>
            <param name="flags">Method for solving a PnP problem </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoCalibrate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The joint matrix of object points, 3xN or Nx3, where N is the total number of points in all views</param>
            <param name="imagePoints1">The joint matrix of corresponding image points in the views from the 1st camera, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="imagePoints2">The joint matrix of corresponding image points in the views from the 2nd camera, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="cameraMatrix1">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs1">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="cameraMatrix2">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs2">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="r">The rotation matrix between the 1st and the 2nd cameras' coordinate systems </param>
            <param name="t">The translation vector between the cameras' coordinate systems</param>
            <param name="e">The optional output essential matrix</param>
            <param name="f">The optional output fundamental matrix </param>
            <param name="termCrit">Termination criteria for the iterative optimization algorithm</param>
            <param name="flags">The calibration flags</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoRectifyUncalibrated(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in space, hence the suffix "Uncalibrated". Another related difference from cvStereoRectify is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations, encoded by the homography matrices H1 and H2. The function implements the following algorithm [Hartley99]. 
            </summary>
            <remarks>
            Note that while the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have significant distortion, it would better be corrected before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using cvCalibrateCamera2 and then the images can be corrected using cvUndistort2
            </remarks>
            <param name="points1">The array of 2D points</param>
            <param name="points2">The array of 2D points</param>
            <param name="f">Fundamental matrix. It can be computed using the same set of point pairs points1 and points2 using cvFindFundamentalMat</param>
            <param name="imgSize">Size of the image</param>
            <param name="h1">The rectification homography matrices for the first images</param>
            <param name="h2">The rectification homography matrices for the second images</param>
            <param name="threshold">If the parameter is greater than zero, then all the point pairs that do not comply the epipolar geometry well enough (that is, the points for which fabs(points2[i]T*F*points1[i])>threshold) are rejected prior to computing the homographies</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoRectify(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.StereoRectifyType,System.Double,System.Drawing.Size,System.Drawing.Rectangle@,System.Drawing.Rectangle@)">
            <summary>
            computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, that makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. On input the function takes the matrices computed by cvStereoCalibrate and on output it gives 2 rotation matrices and also 2 projection matrices in the new coordinates. The function is normally called after cvStereoCalibrate that computes both camera matrices, the distortion coefficients, R and T
            </summary>
            <param name="cameraMatrix1">The camera matrices [fx_k 0 cx_k; 0 fy_k cy_k; 0 0 1]</param>
            <param name="cameraMatrix2">The camera matrices [fx_k 0 cx_k; 0 fy_k cy_k; 0 0 1]</param>
            <param name="distCoeffs1">The vectors of distortion coefficients for first camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="distCoeffs2">The vectors of distortion coefficients for second camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image used for stereo calibration</param>
            <param name="r">The rotation matrix between the 1st and the 2nd cameras' coordinate systems</param>
            <param name="t">The translation vector between the cameras' coordinate systems</param>
            <param name="r1">3x3 Rectification transforms (rotation matrices) for the first camera</param>
            <param name="r2">3x3 Rectification transforms (rotation matrices) for the second camera</param>
            <param name="p1">3x4 Projection matrices in the new (rectified) coordinate systems</param>
            <param name="p2">3x4 Projection matrices in the new (rectified) coordinate systems</param>
            <param name="q">The optional output disparity-to-depth mapping matrix, 4x4, see cvReprojectImageTo3D. </param>
            <param name="flags">The operation flags, use CALIB_ZERO_DISPARITY for default</param>
            <param name="alpha">Use -1 for default</param>
            <param name="newImageSize">Use Size.Empty for default</param>
            <param name="validPixRoi1">The valid pixel ROI for image1</param>
            <param name="validPixRoi2">The valid pixel ROI for image2</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindChessboardCorners(Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibCbType)">
            <summary>
            Attempts to determine whether the input image is a view of the chessboard pattern and locate internal chessboard corners
            </summary>
            <param name="image">Source chessboard view; it must be 8-bit grayscale or color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">Pointer to the output array of corners(PointF) detected</param>
            <param name="flags">Various operation flags</param>
            <returns>True if all the corners have been found and they have been placed in a certain order (row by row, left to right in every row), otherwise, if the function fails to find all the corners or reorder them, it returns 0</returns>
            <remarks>The coordinates detected are approximate, and to determine their position more accurately, the user may use the function cvFindCornerSubPix</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DrawChessboardCorners(Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Draws the individual chessboard corners detected (as red circles) in case if the board was not found (pattern_was_found=0) or the colored corners connected with lines when the board was found (pattern_was_found != 0). 
            </summary>
            <param name="image">The destination image; it must be 8-bit color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">The array of corners detected</param>
            <param name="patternWasFound">Indicates whether the complete board was found (!=0) or not (=0). One may just pass the return value cvFindChessboardCorners here. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreatePOSITObject(System.Single[0:,0:],System.Int32)">
            <summary>
            Allocates memory for the object structure and computes the object inverse matrix. 
            </summary>
            <remarks>The preprocessed object data is stored in the structure CvPOSITObject, internal for OpenCV, which means that the user cannot directly access the structure data. The user may only create this structure and pass its pointer to the function. 
            Object is defined as a set of points given in a coordinate system. The function cvPOSIT computes a vector that begins at a camera-related coordinate system center and ends at the points[0] of the object. 
            Once the work with a given object is finished, the function cvReleasePOSITObject must be called to free memory</remarks>
            <param name="points3D">A two dimensional array contains the points of the 3D object model, the second dimension must be 3. </param>
            <param name="pointCount">Number of object points</param>
            <returns>A pointer to the CvPOSITObject</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPOSIT(System.IntPtr,System.IntPtr,System.Double,Emgu.CV.Structure.MCvTermCriteria,System.IntPtr,System.IntPtr)">
            <summary>
            Implements POSIT algorithm. Image coordinates are given in a camera-related coordinate system. The focal length may be retrieved using camera calibration functions. At every iteration of the algorithm new perspective projection of estimated pose is computed. 
            </summary>
            <remarks>Difference norm between two projections is the maximal distance between corresponding points. </remarks>
            <param name="positObject">Pointer to the object structure</param>
            <param name="imagePoints">2D array to the object points projections on the 2D image plane, the second dimension must be 2.</param>
            <param name="focalLength">Focal length of the camera used</param>
            <param name="criteria">Termination criteria of the iterative POSIT algorithm. The parameter criteria.epsilon serves to stop the algorithm if the difference is small.</param>
            <param name="rotationMatrix">A vector which contains the 9 elements of the 3x3 rotation matrix</param>
            <param name="translationVector">Translation vector (3x1)</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleasePOSITObject(System.IntPtr@)">
            <summary>
            The function cvReleasePOSITObject releases memory previously allocated by the function cvCreatePOSITObject. 
            </summary>
            <param name="positObject">pointer to CvPOSIT structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.TriangulatePoints(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Reconstructs points by triangulation.
            </summary>
            <param name="projMat1">3x4 projection matrix of the first camera.</param>
            <param name="projMat2">3x4 projection matrix of the second camera.</param>
            <param name="projPoints1">2xN array of feature points in the first image. It can be also a vector of feature points or two-channel matrix of size 1xN or Nx1</param>
            <param name="projPoints2">2xN array of corresponding points in the second image. It can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="points4D">4xN array of reconstructed points in homogeneous coordinates.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CorrectMatches(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Refines coordinates of corresponding points.
            </summary>
            <param name="f">3x3 fundamental matrix.</param>
            <param name="points1">1xN array containing the first set of points.</param>
            <param name="points2">1xN array containing the second set of points.</param>
            <param name="newPoints1">The optimized points1.</param>
            <param name="newPoints2">The optimized points2.</param>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvErrorHandlerThrowException">
            <summary>
            The default Exception callback to handle Error thrown by OpenCV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvErrorHandlerIgnoreError">
            <summary>
            An error handler which will ignore any error and continue
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvIgnoreErrorErrorHandler(System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            A custom error handler for OpenCV
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvErrorHandler(System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            A custom error handler for OpenCV
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRedirectError(Emgu.CV.CvInvoke.CvErrorCallback,System.IntPtr,System.IntPtr)">
            <summary>
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="errorHandler">The new error handler</param>
            <param name="userdata">Arbitrary pointer that is transparently passed to the error handler.</param>
            <param name="prevUserdata">Pointer to the previously assigned user data pointer.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRedirectError(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="errorHandler">Pointer to the new error handler</param>
            <param name="userdata">Arbitrary pointer that is transparently passed to the error handler.</param>
            <param name="prevUserdata">Pointer to the previously assigned user data pointer.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetErrMode(System.Int32)">
            <summary>
            Sets the specified error mode.
            </summary>
            <param name="errorMode">The error mode</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetErrMode">
            <summary>
            Returns the current error mode
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetErrStatus">
            <summary>
            Returns the current error status - the value set with the last cvSetErrStatus call. Note, that in Leaf mode the program terminates immediately after error occurred, so to always get control after the function call, one should call cvSetErrMode and set Parent or Silent error mode.
            </summary>
            <returns>the current error status</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetErrStatus(Emgu.CV.CvEnum.ErrorCodes)">
            <summary>
            Sets the error status to the specified value. Mostly, the function is used to reset the error status (set to it CV_StsOk) to recover after error. In other cases it is more natural to call cvError or CV_ERROR.
            </summary>
            <param name="code">The error status.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSeq(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Creates a sequence and returns the pointer to it. The function allocates the sequence header in the storage block as one continuous chunk and sets the structure fields flags, elem_size, header_size and storage to passed values, sets delta_elems to the default value (that may be reassigned using cvSetSeqBlockSize function), and clears other header fields, including the space after the first sizeof(CvSeq) bytes
            </summary>
            <param name="seqFlags">Flags of the created sequence. If the sequence is not passed to any function working with a specific type of sequences, the sequence value may be set to 0, otherwise the appropriate type must be selected from the list of predefined sequence types</param>
            <param name="headerSize">Size of the sequence header; must be greater or equal to sizeof(CvSeq). If a specific type or its extension is indicated, this type must fit the base type header</param>
            <param name="elemSize">Size of the sequence elements in bytes. The size must be consistent with the sequence type. For example, for a sequence of points to be created, the element type CV_SEQ_ELTYPE_POINT should be specified and the parameter elem_size must be equal to sizeof(CvPoint). </param>
            <param name="storage">Sequence location.</param>
            <returns>A pointer to the sequence</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPush(System.IntPtr,System.IntPtr)">
            <summary>
            Adds an element to the end of sequence and returns pointer to the allocated element. If the input element is NULL, the function simply allocates a space for one more element.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">Added element</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPushFront(System.IntPtr,System.IntPtr)">
            <summary>
            Adds an element to the front of sequence and returns pointer to the allocated element. If the input element is NULL, the function simply allocates a space for one more element.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">Added element</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPop(System.IntPtr,System.IntPtr)">
            <summary>
            Removes element from sequence end.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">If the pointer is not zero, the function copies the removed element to this location</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPopFront(System.IntPtr,System.IntPtr)">
            <summary>
            Removes element from sequence beginning.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">If the pointer is not zero, the function copies the removed element to this location</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqRemove(System.IntPtr,System.Int32)">
            <summary>
            Removes element from sequence middle
            </summary>
            <param name="seq">Sequence</param>
            <param name="index">Index of removed element</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqInsert(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Shifts the sequence elements from the inserted position to the nearest end of the sequence and copies the element content there if the pointer is not IntPtr.Zero
            </summary>
            <param name="seq">Sequence</param>
            <param name="beforeIndex">Index before which the element is inserted. Inserting before 0 (the minimal allowed value of the parameter) is equal to cvSeqPushFront and inserting before seq->total (the maximal allowed value of the parameter) is equal to cvSeqPush</param>
            <param name="element">Inserted element</param>
            <returns>Pointer to the inserted element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPushMulti(System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.CvEnum.BackOrFront)">
            <summary>
            Adds several elements to either end of the sequence. The elements are added to the sequence in the same order as they are arranged in the input array but they can fall into different sequence blocks.
            </summary>
            <param name="seq">Sequence</param>
            <param name="elements">Added elements</param>
            <param name="count">Number of elements to push</param>
            <param name="backOrFront">
            If != 0, the elements are added to the beginning of sequence;
            Otherwise the elements are added to the end of sequence </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPopMulti(System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.CvEnum.BackOrFront)">
            <summary>
            Removes several elements from either end of the sequence. If the number of the elements to be removed exceeds the total number of elements in the sequence, the function removes as many elements as possible
            </summary>
            <param name="seq">Sequence</param>
            <param name="elements">Removed elements</param>
            <param name="count">Number of elements to remove</param>
            <param name="backOrFront">
            If != 0, the elements are added to the beginning of sequence;
            Otherwise the elements are added to the end of sequence </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvChangeSeqBlock(Emgu.CV.Structure.MCvSeqReader@,System.Int32)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNextSeqElem(System.Int32,Emgu.CV.Structure.MCvSeqReader@)">
            <summary>
            Move to the next element in the sequence
            </summary>
            <param name="elemSize">the size of the element</param>
            <param name="reader">the sequence reader</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReadSeqElem``1(Emgu.CV.Structure.MCvSeqReader@)">
            <summary>
            forward reading the sequence reader
            </summary>
            <typeparam name="T">The type of structure to be read</typeparam>
            <param name="reader">The sequence reader</param>
            <returns>The read object</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvIsSetElem(System.IntPtr)">
            <summary>
            Determined whether the specified node is occupied or not
            </summary>
            <param name="ptr">Pointer to the node</param>
            <returns>true if the specified node is occupied</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvStartReadSeq(System.IntPtr,Emgu.CV.Structure.MCvSeqReader@,System.Boolean)">
            <summary>
            Initializes the reader state
            </summary>
            <param name="seq">Sequence</param>
            <param name="reader">Reader state; initialized by the function</param>
            <param name="reverse">Determines the direction of the sequence traversal. If reverse is 0, the reader is positioned at the first sequence element, otherwise it is positioned at the last element.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSeqElem(System.IntPtr,System.Int32)">
            <summary>
            Finds the element with the given index in the sequence and returns the pointer to it. If the element is not found, the function returns 0. The function supports negative indices, where -1 stands for the last sequence element, -2 stands for the one before last, etc. If the sequence is most likely to consist of a single sequence block or the desired element is likely to be located in the first block, then the macro CV_GET_SEQ_ELEM( elemType, seq, index ) should be used, where the parameter elemType is the type of sequence elements ( CvPoint for example), the parameter seq is a sequence, and the parameter index is the index of the desired element. The macro checks first whether the desired element belongs to the first block of the sequence and returns it if it does, otherwise the macro calls the main function GetSeqElem. Negative indices always cause the cvGetSeqElem call. The function has O(1) time complexity assuming that number of blocks is much smaller than the number of elements.
            </summary>
            <param name="seq">Sequence</param>
            <param name="index">Index of element</param>
            <returns>the pointer to the element with the given index in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearSeq(System.IntPtr)">
            <summary>
            Removes all elements from the sequence. The function does not return the memory to the storage, but this memory is reused later when new elements are added to the sequence. This function time complexity is O(1). 
            </summary>
            <param name="seq">Sequence</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReshape(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            initializes CvMat header so that it points to the same data as the original array but has different shape - different number of channels, different number of rows or both
            </summary>
            <param name="arr">Input array</param>
            <param name="header">Output header to be filled</param>
            <param name="newCn">New number of channels. new_cn = 0 means that number of channels remains unchanged</param>
            <param name="newRows">New number of rows. new_rows = 0 means that number of rows remains unchanged unless it needs to be changed according to new_cn value. destination array to be changed</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Repeat(Emgu.CV.IInputArray,System.Int32,System.Int32,Emgu.CV.IOutputArray)">
            <summary>
            Fills the destination array with source array tiled:
            dst(i,j)=src(i mod rows(src), j mod cols(src))So the destination array may be as larger as well as smaller than the source array
            </summary>
            <param name="src">Source array, image or matrix</param>
            <param name="dst">Destination array, image or matrix</param>
            <param name="nx">Flag to specify how many times the src is repeated along the vertical axis.</param>
            <param name="ny">Flag to specify how many times the src is repeated along the horizontal axis.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Merge(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IOutputArray)">
            <summary>
            This function is the opposite to cvSplit. If the destination array has N channels then if the first N input channels are not IntPtr.Zero, all they are copied to the destination array, otherwise if only a single source channel of the first N is not IntPtr.Zero, this particular channel is copied into the destination array, otherwise an error is raised. Rest of source channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to insert a single channel into the image. 
            </summary>
            <param name="mv">Input vector of matrices to be merged; all the matrices in mv must have the same size and the same depth.</param>
            <param name="dst">output array of the same size and the same depth as mv[0]; The number of channels will be the total number of channels in the matrix array.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MixChannels(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputOutputArray,System.Int32[])">
            <summary>
            The function cvMixChannels is a generalized form of cvSplit and cvMerge and some forms of cvCvtColor. It can be used to change the order of the planes, add/remove alpha channel, extract or insert a single plane or multiple planes etc.
            </summary>
            <param name="src">The array of input arrays.</param>
            <param name="dst">The array of output arrays</param>
            <param name="fromTo">The array of pairs of indices of the planes copied. from_to[k*2] is the 0-based index of the input plane, and from_to[k*2+1] is the index of the output plane, where the continuous numbering of the planes over all the input and over all the output arrays is used. When from_to[k*2] is negative, the corresponding output plane is filled with 0's.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ExtractChannel(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Extract the specific channel from the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The channel</param>
            <param name="coi">0 based index of the channel to be extracted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InsertChannel(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Int32)">
            <summary>
            Insert the specific channel to the image
            </summary>
            <param name="src">The source channel</param>
            <param name="dst">The destination image where the channel will be inserted into</param>
            <param name="coi">0-based index of the channel to be inserted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RandShuffle(Emgu.CV.IInputOutputArray,System.Double,System.UInt64)">
            <summary>
            Shuffles the matrix by swapping randomly chosen pairs of the matrix elements on each iteration (where each element may contain several components in case of multi-channel arrays)
            </summary>
            <param name="mat">The input/output matrix. It is shuffled in-place. </param>
            <param name="rng">Pointer to MCvRNG random number generator. Use 0 if not sure</param>
            <param name="iterFactor">The relative parameter that characterizes intensity of the shuffling performed. The number of iterations (i.e. pairs swapped) is round(iter_factor*rows(mat)*cols(mat)), so iter_factor=0 means that no shuffling is done, iter_factor=1 means that the function swaps rows(mat)*cols(mat) random pairs etc</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseNot(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Inverses every bit of every array element:
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">The optional mask for the operation, use null to ignore</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Max(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates per-element maximum of two arrays:
            dst(I)=max(src1(I), src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. </param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CountNonZero(Emgu.CV.IInputArray)">
            <summary>
            Returns the number of non-zero elements in arr:
            result = sumI arr(I)!=0
            In case of IplImage both ROI and COI are supported.
            </summary>
            <param name="arr">The image</param>
            <returns>the number of non-zero elements in image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindNonZero(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Find the location of the non-zero pixel
            </summary>
            <param name="src">The source array</param>
            <param name="idx">The output array where the location of the pixels are sorted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PSNR(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Computes PSNR image/video quality metric
            </summary>
            <param name="src1">The first source image</param>
            <param name="src2">The second source image</param>
            <returns>the quality metric</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Min(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates per-element minimum of two arrays:
            dst(I)=min(src1(I),src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Add(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Adds one array to another one:
            dst(I)=src1(I)+src2(I) if mask(I)!=0All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="src2">The second source array.</param>
            <param name="dst">The destination array.</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Subtract(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Subtracts one array from another one:
            dst(I)=src1(I)-src2(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Divide(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Divides one array by another:
            dst(I)=scale * src1(I)/src2(I), if src1!=IntPtr.Zero;
            dst(I)=scale/src2(I),      if src1==IntPtr.Zero;
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. If the pointer is IntPtr.Zero, the array is assumed to be all 1s. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor </param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Multiply(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates per-element product of two arrays:
            dst(I)=scale*src1(I)*src2(I)
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor</param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseAnd(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseOr(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise disjunction of two arrays:
            dst(I)=src1(I)|src2(I)
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseXor(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Mask, 8-bit single channel array; specifies elements of destination array to be changed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCopy(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copies selected elements from input array to output array:
            dst(I)=src(I) if mask(I)!=0. 
            If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions and the same size. The function can also copy sparse arrays (mask is not supported in this case).
            </summary>
            <param name="src">The source array</param>
            <param name="des">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSet(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr)">
            <summary>
            Copies scalar value to every selected element of the destination array:
            arr(I)=value if mask(I)!=0
            If array arr is of IplImage type, then is ROI used, but COI must not be set
            </summary>
            <param name="arr">The destination array</param>
            <param name="value">Fill value</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetZero(System.IntPtr)">
            <summary>
            Clears the array. In case of dense arrays (CvMat, CvMatND or IplImage) cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0), in case of sparse arrays all the elements are removed
            </summary>
            <param name="arr">array to be cleared</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvZero(System.IntPtr)">
            <summary>
            Clears the array. In case of dense arrays (CvMat, CvMatND or IplImage) cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0), in case of sparse arrays all the elements are removed
            </summary>
            <param name="arr">array to be cleared</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetIdentity(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Initializes scaled identity matrix:
            arr(i,j)=value if i=j,
            0 otherwise
            </summary>
            <param name="mat">The matrix to initialize (not necessarily square).</param>
            <param name="value">The value to assign to the diagonal elements.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRange(System.IntPtr,System.Double,System.Double)">
            <summary>
            Initializes the matrix as following:
            arr(i,j)=(end-start)*(i*cols(arr)+j)/(cols(arr)*rows(arr))
            </summary>
            <param name="mat">The matrix to initialize. It should be single-channel 32-bit, integer or floating-point</param>
            <param name="start">The lower inclusive boundary of the range</param>
            <param name="end">The upper exclusive boundary of the range</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CartToPolar(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Calculates either magnitude, angle, or both of every 2d vector (x(I),y(I)):
            magnitude(I)=sqrt( x(I)2+y(I)2 ),
            angle(I)=atan( y(I)/x(I) )
            The angles are calculated with ~0.1 degree accuracy. For (0,0) point the angle is set to 0
            </summary>
            <param name="x">The array of x-coordinates </param>
            <param name="y">The array of y-coordinates</param>
            <param name="magnitude">The destination array of magnitudes, may be set to IntPtr.Zero if it is not needed </param>
            <param name="angle">The destination array of angles, may be set to IntPtr.Zero if it is not needed. The angles are measured in radians (0..2?) or in degrees (0..360?). </param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PolarToCart(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Calculates either x-coordinate, y-coordinate or both of every vector magnitude(I)* exp(angle(I)*j), j=sqrt(-1):
            x(I)=magnitude(I)*cos(angle(I)),
            y(I)=magnitude(I)*sin(angle(I))
            </summary>
            <param name="magnitude">Input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (=Mat()), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as angle</param>
            <param name="angle">input floating-point array of angles of 2D vectors.</param>
            <param name="x">Output array of x-coordinates of 2D vectors; it has the same size and type as angle.</param>
            <param name="y">Output array of y-coordinates of 2D vectors; it has the same size and type as angle.</param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Pow(Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Raises every element of input array to p:
            dst(I)=src(I)p, if p is integer
            dst(I)=abs(src(I))p, otherwise
            That is, for non-integer power exponent the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations, as the following sample, computing cube root of array elements, shows:
            CvSize size = cvGetSize(src);
            CvMat* mask = cvCreateMat( size.height, size.width, CV_8UC1 );
            cvCmpS( src, 0, mask, CV_CMP_LT ); /* find negative elements */
            cvPow( src, dst, 1./3 );
            cvSubRS( dst, cvScalarAll(0), dst, mask ); /* negate the results of negative inputs */
            cvReleaseMat( &amp;mask );
            For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used.
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, should be the same type as the source</param>
            <param name="power">The exponent of power</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Exp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            Maximum relative error is 7e-6. Currently, the function converts denormalized values to zeros on output
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Log(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array:
            dst(I)=log(abs(src(I))), src(I)!=0
            dst(I)=C,  src(I)=0
            Where C is large negative number (-700 in the current implementation)
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolveCubic(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            finds real roots of a cubic equation:
            coeffs[0]*x^3 + coeffs[1]*x^2 + coeffs[2]*x + coeffs[3] = 0
            (if coeffs is 4-element vector)
            or
            x^3 + coeffs[0]*x^2 + coeffs[1]*x + coeffs[2] = 0
            (if coeffs is 3-element vector)
            </summary>
            <param name="coeffs">The equation coefficients, array of 3 or 4 elements</param>
            <param name="roots">The output array of real roots. Should have 3 elements. Padded with zeros if there is only one root</param>
            <returns>the number of real roots found</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePoly(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Finds all real and complex roots of any degree polynomial with real coefficients
            </summary>
            <param name="coeffs">The (degree + 1)-length array of equation coefficients (CV_32FC1 or CV_64FC1)</param>
            <param name="roots">The degree-length output array of real or complex roots (CV_32FC2 or CV_64FC2)</param>
            <param name="maxiter">The maximum number of iterations</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Solve(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DecompMethod)">
            <summary>
            Solves linear system (src1)*(dst) = (src2)
            </summary>
            <param name="src1">The source matrix in the LHS</param>
            <param name="src2">The source matrix in the RHS</param>
            <param name="dst">The result</param>
            <param name="method">The method for solving the equation</param>
            <returns>0 if src1 is a singular and CV_LU method is used</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dft(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DxtType,System.Int32)">
            <summary>
            Performs forward or inverse transform of 1D or 2D floating-point array
            In case of real (single-channel) data, the packed format, borrowed from IPL, is used to to represent a result of forward Fourier transform or input for inverse Fourier transform
            </summary>
            <param name="src">Source array, real or complex</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
            <param name="nonzeroRows">Number of nonzero rows to in the source array (in case of forward 2d transform), or a number of rows of interest in the destination array (in case of inverse 2d transform). If the value is negative, zero, or greater than the total number of rows, it is ignored. The parameter can be used to speed up 2d convolution/correlation when computing them via DFT. See the sample below</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetOptimalDFTSize(System.Int32)">
            <summary>
            Returns the minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. 
            </summary>
            <param name="size0">Vector size</param>
            <returns>The minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MulSpectrums(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.MulSpectrumsType,System.Boolean)">
            <summary>
            Performs per-element multiplication of the two CCS-packed or complex matrices that are results of real or complex Fourier transform. 
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array of the same type and the same size of the sources</param>
            <param name="flags">Operation flags; currently, the only supported flag is DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum.</param>
            <param name="conjB">Optional flag that conjugates the second input array before the multiplication (true) or not (false).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dct(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DctType)">
            <summary>
            Performs forward or inverse transform of 1D or 2D floating-point array
            </summary>
            <param name="src">Source array, real 1D or 2D array</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ClipLine(System.Drawing.Rectangle,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Calculates a part of the line segment which is entirely in the rectangle.
            </summary>
            <param name="rectangle">The rectangle</param>
            <param name="pt1">First ending point of the line segment. It is modified by the function</param>
            <param name="pt2">Second ending point of the line segment. It is modified by the function.</param>
            <returns>It returns false if the line segment is completely outside the rectangle and true otherwise.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AbsDiff(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates absolute difference between two arrays.
            dst(I)c = abs(src1(I)c - src2(I)c).
            All the arrays must have the same data type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AddWeighted(Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculated weighted sum of two arrays as following:
            dst(I)=src1(I)*alpha+src2(I)*beta+gamma
            All the arrays must have the same type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="alpha">Weight of the first array elements.</param>
            <param name="src2">The second source array. </param>
            <param name="beta">Weight of the second array elements.</param>
            <param name="gamma">Scalar, added to each sum. </param>
            <param name="dst">The destination array.</param>
            <param name="dtype">Optional depth of the output array; when both input arrays have the same depth</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InRange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Performs range check for every element of the input array:
            dst(I)=lower(I)_0 &lt;= src(I)_0 &lt;= upper(I)_0
            For single-channel arrays,
            dst(I)=lower(I)_0 &lt;= src(I)_0 &lt;= upper(I)_0 &amp;&amp;
            lower(I)_1 &lt;= src(I)_1 &lt;= upper(I)_1
            For two-channel arrays etc.
            dst(I) is set to 0xff (all '1'-bits) if src(I) is within the range and 0 otherwise. All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src">The source image</param>
            <param name="lower">The lower values stored in an image of same type &amp; size as <paramref name="src"/></param>
            <param name="upper">The upper values stored in an image of same type &amp; size as <paramref name="src"/></param>
            <param name="dst">The resulting mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.IInputArray)">
            <summary>
            Returns the calculated norm. The multiple-channel array are treated as single-channel, that is, the results for all channels are combined. 
            </summary>
            <param name="arr1">The first source image</param>
            <param name="arr2">The second source image. If it is null, the absolute norm of arr1 is calculated, otherwise absolute or relative norm of arr1-arr2 is calculated</param>
            <param name="normType">Type of norm</param>
            <param name="mask">The optional operation mask</param>
            <returns>The calculated norm</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.IInputArray)">
            <summary>
            Returns the calculated norm. The multiple-channel array are treated as single-channel, that is, the results for all channels are combined. 
            </summary>
            <param name="arr1">The first source image</param>
            <param name="normType">Type of norm</param>
            <param name="mask">The optional operation mask</param>
            <returns>The calculated norm</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImage(System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32)">
            <summary>
            Creates the header and allocates data. 
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns>A pointer to IplImage </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImageHeader(System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32)">
            <summary>
            Allocates, initializes, and returns the structure IplImage.
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns> The structure IplImage</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitImageHeader(System.IntPtr,System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the image header structure, pointer to which is passed by the user, and returns the pointer.
            </summary>
            <param name="image">Image header to initialize.</param>
            <param name="size">Image width and height.</param>
            <param name="depth">Image depth </param>
            <param name="channels">Number of channels </param>
            <param name="origin">IPL_ORIGIN_TL or IPL_ORIGIN_BL.</param>
            <param name="align">Alignment for image rows, typically 4 or 8 bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetData(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Assigns user data to the array header.
            </summary>
            <param name="arr">Array header.</param>
            <param name="data">User data.</param>
            <param name="step">Full row length in bytes.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImageHeader(System.IntPtr@)">
            <summary>
            Releases the header.
            </summary>
            <param name="image">Pointer to the deallocated header.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatHeader(System.IntPtr,System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.IntPtr,System.Int32)">
            <summary>
            Initializes already allocated CvMat structure. It can be used to process raw data with OpenCV matrix functions.
            </summary>
            <param name="mat">Pointer to the matrix header to be initialized.</param>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <param name="step">Full row width in bytes of the data assigned. By default, the minimal possible step is used, i.e., no gaps is assumed between subsequent rows of the matrix.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatHeader(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Initializes already allocated CvMat structure. It can be used to process raw data with OpenCV matrix functions.
            </summary>
            <param name="mat">Pointer to the matrix header to be initialized.</param>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <param name="step">Full row width in bytes of the data assigned. By default, the minimal possible step is used, i.e., no gaps is assumed between subsequent rows of the matrix.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageCOI(System.IntPtr,System.Int32)">
            <summary>
            Sets the channel of interest to a given value. Value 0 means that all channels are selected, 1 means that the first channel is selected etc. If ROI is NULL and coi != 0, ROI is allocated.
            </summary>
            <param name="image">Image header</param>
            <param name="coi">Channel of interest starting from 1. If 0, the COI is unset.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageCOI(System.IntPtr)">
            <summary>
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header. </param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvResetImageROI(System.IntPtr)">
            <summary>
            Releases image ROI. After that the whole image is considered selected.
            </summary>
            <param name="image">Image header</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageROI(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Sets the image ROI to a given rectangle. If ROI is NULL and the value of the parameter rect is not equal to the whole image, ROI is allocated. 
            </summary>
            <param name="image">Image header.</param>
            <param name="rect">ROI rectangle.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageROI(System.IntPtr)">
            <summary>
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header.</param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateMat(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Allocates header for the new matrix and underlying data, and returns a pointer to the created matrix. Matrices are stored row by row. All the rows are aligned by 4 bytes. 
            </summary>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <returns>A pointer to the created matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatNDHeader(System.IntPtr,System.Int32,System.Int32[],Emgu.CV.CvEnum.DepthType,System.IntPtr)">
            <summary>
            Initializes CvMatND structure allocated by the user
            </summary>
            <param name="mat">Pointer to the array header to be initialized</param>
            <param name="dims">Number of array dimensions</param>
            <param name="sizes">Array of dimension sizes</param>
            <param name="type">Type of array elements</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <returns>Pointer to the array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseMat(System.IntPtr@)">
            <summary>
            Decrements the matrix data reference counter and releases matrix header
            </summary>
            <param name="mat">Double pointer to the matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSparseMat(System.Int32,System.IntPtr,Emgu.CV.CvEnum.DepthType)">
            <summary>
            The function allocates a multi-dimensional sparse array. Initially the array contain no elements, that is Get or GetReal returns zero for every index
            </summary>
            <param name="dims">Number of array dimensions</param>
            <param name="sizes">Array of dimension sizes</param>
            <param name="type">Type of array elements</param>
            <returns>Pointer to the array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseSparseMat(System.IntPtr@)">
            <summary>
            The function releases the sparse array and clears the array pointer upon exit.
            </summary>
            <param name="mat">Reference of the pointer to the array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateMemStorage(System.Int32)">
            <summary>
            Creates a memory storage and returns pointer to it. Initially the storage is empty. All fields of the header, except the block_size, are set to 0.
            </summary>
            <param name="blockSize"></param>
            <returns>Size of the storage blocks in bytes. If it is 0, the block size is set to default value - currently it is 64K. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateChildMemStorage(System.IntPtr)">
            <summary>
            Creates a child memory storage that is similar to simple memory storage except for the differences in the memory allocation/deallocation mechanism. When a child storage needs a new block to add to the block list, it tries to get this block from the parent. The first unoccupied parent block available is taken and excluded from the parent block list. If no blocks are available, the parent either allocates a block or borrows one from its own parent, if any. In other words, the chain, or a more complex structure, of memory storages where every storage is a child/parent of another is possible. When a child storage is released or even cleared, it returns all blocks to the parent. In other aspects, the child storage is the same as the simple storage.
            </summary>
            <param name="parent">Parent memory storage</param>
            <returns>ChildMemStorage</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearMemStorage(System.IntPtr)">
            <summary>
            Resets the top (free space boundary) of the storage to the very beginning. This function does not deallocate any memory. If the storage has a parent, the function returns all blocks to the parent.
            </summary>
            <param name="storage">Memory storage</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseMemStorage(System.IntPtr@)">
            <summary>
            Deallocates all storage memory blocks or returns them to the parent, if any. Then it deallocates the storage header and clears the pointer to the storage. All children of the storage must be released before the parent is released.
            </summary>
            <param name="storage">Pointer to the released storage</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke._cvLoad(System.String,System.IntPtr,System.String,System.IntPtr)">
            <summary>
            Loads object from file. It provides a simple interface to cvRead. After object is loaded, the file storage is closed and all the temporary buffers are deleted. Thus, to load a dynamic structure, such as sequence, contour or graph, one should pass a valid destination memory storage to the function.
            </summary>
            <param name="fileName">File name</param>
            <param name="memstorage">Memory storage for dynamic structures, such as CvSeq or CvGraph. It is not used for matrices or images</param>
            <param name="name">Optional object name. If it is IntPtr.Zero, the first top-level object in the storage will be loaded</param>
            <param name="realName">Optional output parameter that will contain name of the loaded object (useful if name=IntPtr.Zero). </param>
            <returns>Loaded object from file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLoad(System.String,System.IntPtr,System.String,System.IntPtr)">
            <summary>
            Loads object from file. It provides a simple interface to cvRead. After object is loaded, the file storage is closed and all the temporary buffers are deleted. Thus, to load a dynamic structure, such as sequence, contour or graph, one should pass a valid destination memory storage to the function.
            </summary>
            <param name="fileName">File name</param>
            <param name="memstorage">Memory storage for dynamic structures, such as CvSeq or CvGraph. It is not used for matrices or images</param>
            <param name="name">Optional object name. If it is NULL, the first top-level object in the storage will be loaded</param>
            <param name="realName">Optional output parameter that will contain name of the loaded object (useful if name=NULL). </param>
            <returns>Loaded object from file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqSlice(System.IntPtr,Emgu.CV.Structure.MCvSlice,System.IntPtr,System.Int32)">
            <summary>
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function.
            </summary>
            <param name="seq">Sequence</param>
            <param name="slice">The part of the sequence to extract</param>
            <param name="storage">The destination storage to keep the new sequence header and the copied data if any. If it is IntPtr.Zero, the function uses the storage containing the input sequence.</param>
            <param name="copyData">The flag that indicates whether to copy the elements of the extracted slice (copy_data!=0) or not (copy_data=0)</param>
            <returns>A pointer to CvSeq</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqSlice(System.IntPtr,Emgu.CV.Structure.MCvSlice,System.IntPtr,System.Boolean)">
            <summary>
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function.
            </summary>
            <param name="seq">Sequence</param>
            <param name="slice">The part of the sequence to extract</param>
            <param name="storage">The destination storage to keep the new sequence header and the copied data if any. If it is IntPtr.Zero, the function uses the storage containing the input sequence.</param>
            <param name="copyData">The flag that indicates whether to copy the elements of the extracted slice (copyData == true) or not (copyData=false)</param>
            <returns>A pointer to CvSeq</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal1D(System.IntPtr,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal2D(System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index </param>
            <param name="idx2">The third zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetRealND(System.IntPtr,System.Int32[],System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx">Array of the element indices </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearND(System.IntPtr,System.Int32[])">
            <summary>
            Clears (sets to zero) the particular element of dense array or deletes the element of sparse array. If the element does not exists, the function does nothing
            </summary>
            <param name="arr">Input array</param>
            <param name="idx">Array of the element indices </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSet2D(System.IntPtr,System.Int32,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Assign the new value to the particular element of array
            </summary>
            <param name="arr">Input array. </param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="value">The assigned value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Flip(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.FlipType)">
            <summary>
            Flips the array in one of different 3 ways (row and column indices are 0-based)
            </summary>
            <param name="src">Source array.</param>
            <param name="dst">Destination array.</param>
            <param name="flipType">Specifies how to flip the array.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Line(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image or ROI rectangle. For non-antialiased lines with integer coordinates the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.
            </summary>
            <param name="img">The image</param>
            <param name="pt1">First point of the line segment</param>
            <param name="pt2">Second point of the line segment</param>
            <param name="color">Line color</param>
            <param name="thickness">Line thickness. </param>
            <param name="lineType">Type of the line:
            8 (or 0) - 8-connected line.
            4 - 4-connected line.
            CV_AA - antialiased line. 
            </param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Polylines(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,System.Boolean,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a single or multiple polygonal curves
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of pointers to polylines</param>
            <param name="isClosed">
            Indicates whether the polylines must be drawn closed. 
            If !=0, the function draws the line from the last vertex of every contour to the first vertex.
            </param>
            <param name="color">Polyline color</param>
            <param name="thickness">Thickness of the polyline edges</param>
            <param name="lineType">Type of the line segments, see cvLine description</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Rectangle(Emgu.CV.IInputOutputArray,System.Drawing.Rectangle,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a rectangle specified by a CvRect structure
            </summary>
            /// <param name="img">Image</param>
            <param name="rect">The rectangle to be drawn</param>
            <param name="color">Line color </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle.</param>
            <param name="lineType">Type of the line</param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSubRect(System.IntPtr,System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Returns header, corresponding to a specified rectangle of the input array. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array. ROI is taken into account by the function so the sub-array of ROI is actually extracted.
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the resultant sub-array header.</param>
            <param name="rect">Zero-based coordinates of the rectangle of interest.</param>
            <returns>the resultant sub-array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRows(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the header, corresponding to a specified row span of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocated memory of resulting sub-array header</param>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <param name="deltaRow">Index step in the row span. That is, the function extracts every delta_row-th row from start_row and up to (but not including) end_row</param>
            <returns>The header, corresponding to a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRow(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return the header, corresponding to a specified row of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocate memory of the resulting sub-array header</param>
            <param name="row">Zero-based index of the selected row</param>
            <returns>The header, corresponding to a specified row of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCols(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the header, corresponding to a specified col span of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocated memory of the resulting sub-array header</param>
            <param name="startCol">Zero-based index of the selected column</param>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <returns>The header, corresponding to a specified col span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCol(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return the header, corresponding to a specified column of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocate memory of the resulting sub-array header</param>
            <param name="col">Zero-based index of the selected column</param>
            <returns>The header, corresponding to a specified column of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetDiag(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            returns the header, corresponding to a specified diagonal of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the resulting sub-array header</param>
            <param name="diag">Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above the main etc., 1 corresponds to the diagonal below the main etc</param>
            <returns>Pointer to the resulting sub-array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSize(System.IntPtr)">
            <summary>
            Returns number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.
            </summary>
            <param name="arr">array header</param>
            <returns>number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Circle(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Int32,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a simple or filled circle with given center and radius. The circle is clipped by ROI rectangle.
            </summary>
            <param name="img">Image where the circle is drawn</param>
            <param name="center">Center of the circle</param>
            <param name="radius">Radius of the circle.</param>
            <param name="color">Color of the circle</param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Split(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Divides a multi-channel array into separate single-channel arrays. Two modes are available for the operation. If the source array has N channels then if the first N destination channels are not IntPtr.Zero, all they are extracted from the source array, otherwise if only a single destination channel of the first N is not IntPtr.Zero, this particular channel is extracted, otherwise an error is raised. Rest of destination channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to extract a single channel from the image
            </summary>
            <param name="src">Input multi-channel array</param>
            <param name="mv">Output array or vector of arrays</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Ellipse(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Drawing.Size,System.Double,System.Double,System.Double,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="center">Center of the ellipse</param>
            <param name="axes">Length of the ellipse axes</param>
            <param name="angle">Rotation angle</param>
            <param name="startAngle">Starting angle of the elliptic arc</param>
            <param name="endAngle">Ending angle of the elliptic arc</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc</param>
            <param name="lineType">Type of the ellipse boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Ellipse(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.RotatedRect,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="box">The box the define the ellipse area</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc</param>
            <param name="lineType">Type of the ellipse boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LUT(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Fills the destination array with values from the look-up table. Indices of the entries are taken from the source array. That is, the function processes each element of src as following:
            dst(I)=lut[src(I)+DELTA]
            where DELTA=0 if src has depth CV_8U, and DELTA=128 if src has depth CV_8S
            </summary>
            <param name="src">Source array of 8-bit elements</param>
            <param name="dst">Destination array of arbitrary depth and of the same number of channels as the source array</param>
            <param name="lut">Look-up table of 256 elements; should have the same depth as the destination array. In case of multi-channel source and destination arrays, the table should either have a single-channel (in this case the same table is used for all channels), or the same number of channels as the source/destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertScale(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel arrays are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination array element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate cvConvert synonym. If source and destination array types have equal types, this is also a special case that can be used to scale and shift a matrix or an image and that fits to cvScale synonym.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertScaleAbs(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Similar to cvCvtScale but it stores absolute values of the conversion results:
            dst(I)=abs(src(I)*scale + (shift,shift,...))
            The function supports only destination arrays of 8u (8-bit unsigned integers) type, for other types the function can be emulated by combination of cvConvertScale and cvAbs functions.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array (should have 8u depth). </param>
            <param name="scale">ScaleAbs factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Mean(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
             <summary>
             Calculates the average value M of array elements, independently for each channel:
            N = sumI mask(I)!=0
            Mc = 1/N * sumI,mask(I)!=0 arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the average to the first scalar component (S0).
             </summary>
             <param name="arr">The array</param>
             <param name="mask">The optional operation mask</param>
             <returns>average (mean) of array elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanStdDev(Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Structure.MCvScalar@,Emgu.CV.IInputArray)">
            <summary>
            The function cvAvgSdv calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <remarks>If the array is IplImage and COI is set, the function processes the selected channel only and stores the average and standard deviation to the first compoenents of output scalars (M0 and S0).</remarks>
            <param name="arr">The array</param>
            <param name="mean">Pointer to the mean value</param>
            <param name="stdDev">Pointer to the standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanStdDev(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates a mean and standard deviation of array elements.
            </summary>
            <param name="arr">Input array that should have from 1 to 4 channels so that the results can be stored in MCvScalar</param>
            <param name="mean">Calculated mean value</param>
            <param name="stdDev">Calculated standard deviation</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sum(Emgu.CV.IInputArray)">
            <summary>
            Calculates sum S of array elements, independently for each channel
            Sc = sumI arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the sum to the first scalar component (S0).
            </summary>
            <param name="src">The array</param>
            <returns>The sum of array elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Reduce(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ReduceDimension,Emgu.CV.CvEnum.ReduceType,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <remarks>
            The function can be used to compute horizontal and vertical projections of an raster image. 
            In case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element bit-depth to preserve accuracy. 
            And multi-channel arrays are also supported in these two reduction modes
            </remarks>
            <param name="src">The input matrix</param>
            <param name="dst">The output single-row/single-column vector that accumulates somehow all the matrix rows/columns</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="type">The reduction operation type</param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImage(System.IntPtr@)">
            <summary>
            Releases the header and the image data.
            </summary>
            <param name="image">Double pointer to the header of the deallocated image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DrawContours(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,System.Int32,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,Emgu.CV.IInputArray,System.Int32,System.Drawing.Point)">
            <summary>
            Draws contours outlines or filled contours.
            </summary>
            <param name="image">Image where the contours are to be drawn. Like in any other drawing function, the contours are clipped with the ROI</param>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours </param>
            <param name="maxLevel">Maximal level for drawn contours. If 0, only contour is drawn. If 1, the contour and all contours after it on the same level are drawn. If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level. </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrieved in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FillConvexPoly(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Fills convex polygon interior. This function is much faster than The function cvFillPoly and can fill not only the convex polygons but any monotonic polygon, i.e. a polygon whose contour intersects every horizontal line (scan line) twice at the most
            </summary>
            <param name="img">Image</param>
            <param name="points">Array of pointers to a single polygon</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FillPoly(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.LineType,System.Int32,System.Drawing.Point)">
            <summary>
            Fills the area bounded by one or more polygons.
            </summary>
            <param name="img">Image.</param>
            <param name="points">Array of polygons where each polygon is represented as an array of points.</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries.</param>
            <param name="shift">Number of fractional bits in the vertex coordinates.</param>
            <param name="offset">Optional offset of all points of the contours.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PutText(Emgu.CV.IInputOutputArray,System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Renders the text in the image with the specified font and color. The printed text is clipped by ROI rectangle. Symbols that do not belong to the specified font are replaced with the rectangle symbol.
            </summary>
            <param name="img">Input image</param>
            <param name="text">String to print</param>
            <param name="org">Coordinates of the bottom-left corner of the first letter</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="color">Text color</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCvtSeqToArray(System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvSlice)">
            <summary>
            Copies the entire sequence or subsequence to the specified buffer and returns the pointer to the buffer
            </summary>
            <param name="seq">Sequence</param>
            <param name="elements">Pointer to the destination array that must be large enough. It should be a pointer to data, not a matrix header</param>
            <param name="slice">The sequence part to copy to the array</param>
            <returns>the pointer to the buffer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMakeSeqHeaderForArray(System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Initializes sequence header for array. The sequence header as well as the sequence block are allocated by the user (for example, on stack). No data is copied by the function. The resultant sequence will consists of a single block and have IntPtr.Zero storage pointer, thus, it is possible to read its elements, but the attempts to add elements to the sequence will raise an error in most cases
            </summary>
            <param name="seqType">Type of the created sequence</param>
            <param name="headerSize">Size of the header of the sequence. Parameter sequence must point to the structure of that size or greater size.</param>
            <param name="elemSize">Size of the sequence element</param>
            <param name="elements">Elements that will form a sequence</param>
            <param name="total">Total number of elements in the sequence. The number of array elements must be equal to the value of this parameter</param>
            <param name="seq">Pointer to the local variable that is used as the sequence header. </param>
            <param name="block">Pointer to the local variable that is the header of the single sequence block. </param>
            <returns>Pointer to the local variable that is used as the sequence header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinMaxLoc(Emgu.CV.IInputArray,System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,Emgu.CV.IInputArray)">
            <summary>
            Finds minimum and maximum element values and their positions. The extremums are searched over the whole array, selected ROI (in case of IplImage) or, if mask is not IntPtr.Zero, in the specified array region. If the array has more than one channel, it must be IplImage with COI set. In case if multi-dimensional arrays min_loc->x and max_loc->x will contain raw (linear) positions of the extremums
            </summary>
            <param name="arr">The source array, single-channel or multi-channel with COI set</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask that is used to select a subarray. Use IntPtr.Zero if not needed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CopyMakeBorder(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Copies the source 2D array into interior of destination array and makes a border of the specified type around the copied area. The function is useful when one needs to emulate border type that is different from the one embedded into a specific algorithm implementation. For example, morphological functions, as well as most of other filtering functions in OpenCV, internally use replication border type, while the user may need zero border or a border, filled with 1's or 255's
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="bordertype">Type of the border to create around the copied source image rectangle</param>
            <param name="value">Value of the border pixels if bordertype=CONSTANT</param>
            <param name="bottom">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="left">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="right">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="top">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet1D(System.IntPtr,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal1D(System.IntPtr,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUseOptimized(System.Int32)">
            <summary>
            Switches between the mode, where only pure C implementations from cxcore, OpenCV etc. are used, and the mode, where IPP and MKL functions are used if available. When cvUseOptimized(0) is called, all the optimized libraries are unloaded. The function may be useful for debugging, IPP&amp;MKL upgrade on the fly, online speed comparisons etc.  Note that by default the optimized plugins are loaded, so it is not necessary to call cvUseOptimized(1) in the beginning of the program (actually, it will only increase the startup time)
            </summary>
            <param name="optimize">1 to turn on optimization, 0 to turn off</param>
            <returns>The number of optimized functions loaded</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUseOptimized(System.Boolean)">
            <summary>
            Switches between the mode, where only pure C implementations from cxcore, OpenCV etc. are used, and the mode, where IPP and MKL functions are used if available. When cvUseOptimized(0) is called, all the optimized libraries are unloaded. The function may be useful for debugging, IPP&amp;MKL upgrade on the fly, online speed comparisons etc.  Note that by default the optimized plugins are loaded, so it is not necessary to call cvUseOptimized(1) in the beginning of the program (actually, it will only increase the startup time)
            </summary>
            <param name="optimize">true to turn on optimization, false to turn off</param>
            <returns>The number of optimized functions loaded</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRandArr(System.UInt64@,System.IntPtr,Emgu.CV.CvEnum.RandType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Fills the destination array with uniformly or normally distributed random numbers.
            </summary>
            <param name="rng">the seed for the random number generator</param>
            <param name="arr">The destination array</param>
            <param name="distType">Distribution type</param>
            <param name="param1">The first parameter of distribution. In case of uniform distribution it is the inclusive lower boundary of random numbers range. In case of normal distribution it is the mean value of random numbers</param>
            <param name="param2">The second parameter of distribution. In case of uniform distribution it is the exclusive upper boundary of random numbers range. In case of normal distribution it is the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDotProduct(System.IntPtr,System.IntPtr)">
            <summary>
            Calculates and returns the Euclidean dot product of two arrays.
            src1 dot src2 = sumI(src1(I)*src2(I))
            In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.
            </summary>
            <param name="src1">The first source array.</param>
            <param name="src2">The second source array</param>
            <returns>the Euclidean dot product of two arrays</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Eigen(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes eigenvalues and eigenvectors of a symmetric matrix
            </summary>
            <param name="src">The input symmetric square matrix, modified during the processing</param>
            <param name="eigenVectors">The output matrix of eigenvectors, stored as subsequent rows</param>
            <param name="eigenValues">The output vector of eigenvalues, stored in the descending order (order of eigenvalues and eigenvectors is syncronized, of course)</param>
            <remarks>Currently the function is slower than cvSVD yet less accurate, so if A is known to be positivelydefined (for example, it is a covariance matrix)it is recommended to use cvSVD to find eigenvalues and eigenvectors of A, especially if eigenvectors are not required.</remarks>
            <example>To calculate the largest eigenvector/-value set lowindex = highindex = 1. For legacy reasons this function always returns a square matrix the same size as the source matrix with eigenvectors and a vector the length of the source matrix with eigenvalues. The selected eigenvectors/-values are always in the first highindex - lowindex + 1 rows.</example>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Normalize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.NormType,Emgu.CV.CvEnum.DepthType,Emgu.CV.IInputArray)">
            <summary>
            normalizes the input array so that it's norm or value range takes the certain value(s).
            </summary>
            <param name="src">The input array</param>
            <param name="dst">The output array; in-place operation is supported</param>
            <param name="alpha">The minimum/maximum value of the output array or the norm of output array</param>
            <param name="beta">The maximum/minimum value of the output array</param>
            <param name="normType">The normalization type</param>
            <param name="mask">The operation mask. Makes the function consider and normalize only certain array elements</param>
            <param name="dType">Optional depth type for the dst array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCrossProduct(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates the cross product of two 3D vectors
            </summary>
            <param name="src1">The first source vector</param>
            <param name="src2">The second source vector</param>
            <param name="dst">The destination vect</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Gemm(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.GemmType)">
            <summary>
            Performs generalized matrix multiplication:
            dst = alpha*op(src1)*op(src2) + beta*op(src3), where op(X) is X or XT
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array. </param>
            <param name="alpha">The scalar</param>
            <param name="src3">The third source array (shift). Can be null, if there is no shift.</param>
            <param name="beta">The scalar</param>
            <param name="dst">The destination array.</param>
            <param name="tAbc">The Gemm operation type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Transform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Performs matrix transformation of every element of array src and stores the results in dst
            Both source and destination arrays should have the same depth and the same size or selected ROI size. transmat and shiftvec should be real floating-point matrices.
            </summary>
            <param name="src">The first source array</param>
            <param name="dst">The destination array</param>
            <param name="m"> transformation 2x2 or 2x3 floating-point matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PerspectiveTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Transforms every element of src (by treating it as 2D or 3D vector) in the following way:
            (x, y, z) -> (x'/w, y'/w, z'/w) or
            (x, y) -> (x'/w, y'/w),
            where
            (x', y', z', w') = mat4x4 * (x, y, z, 1) or
            (x', y', w') = mat3x3 * (x, y, 1)
            and w = w'   if w'!=0,
                   inf  otherwise
            </summary>
            <param name="src">The source three-channel floating-point array</param>
            <param name="dst">The destination three-channel floating-point array</param>
            <param name="mat">3x3 or 4x4 floating-point transformation matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MulTransposed(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.IInputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates the product of src and its transposition.
            The function evaluates dst=scale(src-delta)*(src-delta)^T if order=0, and dst=scale(src-delta)^T*(src-delta) otherwise.
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
            <param name="aTa">Order of multipliers</param>
            <param name="delta">An optional array, subtracted from <paramref name="src"/> before multiplication</param>
            <param name="scale">An optional scaling</param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Trace(Emgu.CV.IInputArray)">
            <summary>
            Returns sum of diagonal elements of the matrix <paramref name="mat"/>.
            </summary>
            <param name="mat">the matrix</param>
            <returns>sum of diagonal elements of the matrix src1</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Transpose(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Transposes matrix src1:
            dst(i,j)=src(j,i)
            Note that no complex conjugation is done in case of complex matrix. Conjugation should be done separately: look at the sample code in cvXorS for example
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Determinant(Emgu.CV.IInputArray)">
            <summary>
            Returns determinant of the square matrix mat. The direct method is used for small matrices and Gaussian elimination is used for larger matrices. For symmetric positive-determined matrices it is also possible to run SVD with U=V=NULL and then calculate determinant as a product of the diagonal elements of W
            </summary>
            <param name="mat">The pointer to the matrix</param>
            <returns>determinant of the square matrix mat</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Invert(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DecompMethod)">
            <summary>
            Inverts matrix src1 and stores the result in src2
            </summary>
            <param name="src">The source matrix.</param>
            <param name="dst">The destination matrix</param>
            <param name="method">Inversion method</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSVD(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.SvdType)">
            <summary>
            Decomposes matrix A into a product of a diagonal matrix and two orthogonal matrices:
            A=U*W*VT
            Where W is diagonal matrix of singular values that can be coded as a 1D vector of singular values and U and V. All the singular values are non-negative and sorted (together with U and V columns) in descenting order.
            </summary>
            <remarks>
            SVD algorithm is numerically robust and its typical applications include: 
            1. accurate eigenvalue problem solution when matrix A is square, symmetric and positively defined matrix, for example, when it is a covariation matrix. W in this case will be a vector of eigen values, and U=V is matrix of eigen vectors (thus, only one of U or V needs to be calculated if the eigen vectors are required) 
            2. accurate solution of poor-conditioned linear systems 
            3. least-squares solution of overdetermined linear systems. This and previous is done by cvSolve function with CV_SVD method 
            4. accurate calculation of different matrix characteristics such as rank (number of non-zero singular values), condition number (ratio of the largest singular value to the smallest one), determinant (absolute value of determinant is equal to the product of singular values). All the things listed in this item do not require calculation of U and V matrices. 
            </remarks>
            <param name="a">Source MxN matrix</param>
            <param name="w">Resulting singular value matrix (MxN or NxN) or vector (Nx1). </param>
            <param name="u">Optional left orthogonal matrix (MxM or MxN). If CV_SVD_U_T is specified, the number of rows and columns in the sentence above should be swapped</param>
            <param name="v">Optional right orthogonal matrix (NxN)</param>
            <param name="flags">Operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcCovarMatrix(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.CovarMethod,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates the covariance matrix of a set of vectors.
            </summary>
            <param name="samples">Samples stored either as separate matrices or as rows/columns of a single matrix.</param>
            <param name="covar">Output covariance matrix of the type ctype and square size.</param>
            <param name="mean">Input or output (depending on the flags) array as the average value of the input vectors.</param>
            <param name="flags">Operation flags</param>
            <param name="ctype">Type of the matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Mahalanobis(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates the weighted distance between two vectors and returns it
            </summary>
            <param name="v1">The first 1D source vector</param>
            <param name="v2">The second 1D source vector</param>
            <param name="iconvar">The inverse covariation matrix</param>
            <returns>the Mahalanobis distance</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcPCA(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.PcaType)">
            <summary>
            Performs PCA analysis of the vector set. First, it uses cvCalcCovarMatrix to compute covariation matrix and then it finds its eigenvalues and eigenvectors. The output number of eigenvalues/eigenvectors should be less than or equal to MIN(rows(data),cols(data)). 
            </summary>
            <param name="data">The input data; each vector is either a single row (CV_PCA_DATA_AS_ROW) or a single column (CV_PCA_DATA_AS_COL). </param>
            <param name="avg">The mean (average) vector, computed inside the function or provided by user</param>
            <param name="eigenvalues">The output eigenvalues of covariation matrix. </param>
            <param name="eigenvectors">The output eigenvectors of covariation matrix (i.e. principal components); one vector per row.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvProjectPCA(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Projects vectors to the specified subspace
            </summary>
            <param name="data">The input data. Each vector is either a single row or a single column.</param>
            <param name="avg">
            The mean (average) vector. If it is a single-row vector, it means that the input vectors are stored as rows of data;
            Otherwise, it should be a single-column vector, then the vectors are stored as columns of data.
            </param>
            <param name="eigenvectors">
            The eigenvectors (principle components). One vector per row.
            </param>
            <param name="result">
            The output matrix of decomposition coefficients.
            The number of rows must be the same as the number of vectors, the number of columns
            must be less than or equal to the number of rows in eigenvectos.
            That it is less, the input vectors are projected into subspace of the first cols(result)
            principle components.
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRawData(System.IntPtr,System.IntPtr@,System.Int32@,System.Drawing.Size@)">
            <summary>
            Fills output variables with low-level information about the array data. All output parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, parameters of ROI are returned. 
            </summary>
            <param name="arr">Array header</param>
            <param name="data">Output pointer to the whole image origin or ROI origin if ROI is set</param>
            <param name="step">Output full row length in bytes</param>
            <param name="roiSize">Output ROI size</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetMat(System.IntPtr,System.IntPtr,System.Int32@,System.Int32)">
            <summary>
            Returns matrix header for the input array that can be matrix - CvMat, image - IplImage or multi-dimensional dense array - CvMatND* (latter case is allowed only if allowND != 0) . In the case of matrix the function simply returns the input pointer. In the case of IplImage* or CvMatND* it initializes header structure with parameters of the current image ROI and returns pointer to this temporary structure. Because COI is not supported by CvMat, it is returned separately. 
            </summary>
            <param name="arr">Input array</param>
            <param name="header">Pointer to CvMat structure used as a temporary buffer</param>
            <param name="coi">Optional output parameter for storing COI</param>
            <param name="allowNd">If non-zero, the function accepts multi-dimensional dense arrays (CvMatND*) and returns 2D (if CvMatND has two dimensions) or 1D matrix (when CvMatND has 1 dimension or more than 2 dimensions). The array must be continuous</param>
            <returns>Returns matrix header for the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImage(System.IntPtr,System.IntPtr)">
            <summary>
            Returns image header for the input array that can be matrix - CvMat*, or image - IplImage*.
            </summary>
            <param name="arr">Input array. </param>
            <param name="imageHeader">Pointer to IplImage structure used as a temporary buffer.</param>
            <returns>Returns image header for the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCheckArr(System.IntPtr,Emgu.CV.CvEnum.CheckType,System.Double,System.Double)">
            <summary>
            Checks that every array element is neither NaN nor Infinity. If CV_CHECK_RANGE is set, it also checks that every element is greater than or equal to minVal and less than maxVal. 
            </summary>
            <param name="arr">The array to check.</param>
            <param name="flags">The operation flags, CHECK_NAN_INFINITY or combination of
            CHECK_RANGE - if set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neither NaN nor Infinity.
            CHECK_QUIET - if set, the function does not raises an error if an element is invalid or out of range 
            </param>
            <param name="minVal">The inclusive lower boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <param name="maxVal">The exclusive upper boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <returns>Returns nonzero if the check succeeded, i.e. all elements are valid and within the range, and zero otherwise. In the latter case if CV_CHECK_QUIET flag is not set, the function raises runtime error.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetNumThreads">
            <summary>
            Return the current number of threads that are used by parallelized (via OpenMP) OpenCV functions.
            </summary>
            <returns>the current number of threads that are used by parallelized (via OpenMP) OpenCV functions</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetNumThreads(System.Int32)">
            <summary>
            Sets the number of threads that are used by parallelized OpenCV functions. 
            </summary>
            <param name="threadsCount">The number of threads that are used by parallelized OpenCV functions. When the argument is zero or negative, and at the beginning of the program, the number of threads is set to the number of processors in the system, as returned by the function omp_get_num_procs() from OpenMP runtime. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetThreadNum">
            <summary>
            Returns the index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. 
            </summary>
            <returns>The index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Compare(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compares the corresponding elements of two arrays and fills the destination mask array:
            dst(I)=src1(I) op src2(I),
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. 
            All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src1">The first image to compare with</param>
            <param name="src2">The second image to compare with</param>
            <param name="dst">dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise.</param>
            <param name="cmpOp">The comparison operator type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvErrorStr(System.Int32)">
            <summary>
            Returns the textual description for the specified error status code. In case of unknown status the function returns NULL pointer. 
            </summary>
            <param name="status">The error status</param>
            <returns>the textual description for the specified error status code.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvOpenFileStorage(System.String,System.IntPtr,Emgu.CV.CvEnum.StorageOp)">
            <summary>
            Opens file storage for reading or writing data. In the latter case a new file is created or existing file is rewritten. Type of the read of written file is determined by the filename extension: .xml for XML, and .yml or .yaml for YAML
            </summary>
            <param name="filename">Name of the file associated with the storage</param>
            <param name="memStorage">Memory storage used for temporary data and for storing dynamic structures, such as CvSeq or CvGraph. If it is NULL, a temporary memory storage is created and used</param>
            <param name="flags"></param>
            <returns>Pointer to CvFileStorage structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseFileStorage(System.IntPtr@)">
            <summary>
            Closes the file associated with the storage and releases all the temporary structures. It must be called after all I/O operations with the storage are finished
            </summary>
            <param name="fs">Reference to the pointer of the released file storage</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetFileNodeByName(System.IntPtr,System.IntPtr,System.String)">
            <summary>
            Finds a file node by name
            </summary>
            <param name="fs">File storage</param>
            <param name="map">The parent map. If it is NULL, the function searches in all the top-level nodes (streams), starting from the first one. </param>
            <param name="name">The file node name</param>
            <returns>Pointer to the specific file node</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvArrToMat(System.IntPtr,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Converts CvMat, IplImage , or CvMatND to Mat.
            </summary>
            <param name="arr">Input CvMat, IplImage , or CvMatND.</param>
            <param name="allowND">When true (default value), CvMatND is converted to 2-dimensional Mat, if it is possible (see the discussion below); if it is not possible, or when the parameter is false, the function will report an error</param>
            <param name="copyData">When false (default value), no data is copied and only the new header is created, in this case, the original array should not be deallocated while the new matrix header is used; if the parameter is true, all the data is copied and you may deallocate the original array right after the conversion.</param>
            <param name="coiMode">Parameter specifying how the IplImage COI (when set) is handled. If coiMode=0 and COI is set, the function reports an error. If coiMode=1 , the function never reports an error. Instead, it returns the header to the whole original image and you will have to check and process COI manually. </param>
            <returns>The Mat header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HConcat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Horizontally concatenate two images
            </summary>
            <param name="src1">The first image</param>
            <param name="src2">The second image</param>
            <param name="dst">The result image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.VConcat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Vertically concatenate two images
            </summary>
            <param name="src1">The first image</param>
            <param name="src2">The second image</param>
            <param name="dst">The result image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.OclFinish">
            <summary>
            Finishes OpenCL queue.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.OclGetPlatformsSummary">
            <summary>
            Get the OpenCL platform summary as a string
            </summary>
            <returns>An OpenCL platform summary</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Kmeans(Emgu.CV.IInputArray,System.Int32,Emgu.CV.IOutputArray,Emgu.CV.Structure.MCvTermCriteria,System.Int32,Emgu.CV.CvEnum.KMeansInitType,Emgu.CV.IOutputArray)">
            <summary>
            Implements k-means algorithm that finds centers of cluster_count clusters and groups the input samples around the clusters. On output labels(i) contains a cluster index for sample stored in the i-th row of samples matrix
            </summary>
            <param name="data">Floating-point matrix of input samples, one row per sample</param>
            <param name="bestLabels">Output integer vector storing cluster indices for every sample</param>
            <param name="termcrit">Specifies maximum number of iterations and/or accuracy (distance the centers move by between the subsequent iterations)</param>
            <param name="attempts">The number of attempts. Use 2 if not sure</param>
            <param name="flags">Flags, use 0 if not sure</param>
            <param name="centers">Pointer to array of centers, use IntPtr.Zero if not sure</param>
            <param name="k">Number of clusters to split the set by.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GrabCut(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Drawing.Rectangle,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Int32,Emgu.CV.CvEnum.GrabcutInitType)">
             <summary>
             The grab cut algorithm for segmentation
             </summary>
             <param name="img">The 8-bit 3-channel image to be segmented</param>
             <param name="mask">Input/output 8-bit single-channel mask. The mask is initialized by the function
             when mode is set to GC_INIT_WITH_RECT. Its elements may have one of following values:
             0 (GC_BGD) defines an obvious background pixels.
             1 (GC_FGD) defines an obvious foreground (object) pixel.
             2 (GC_PR_BGR) defines a possible background pixel.
             3 (GC_PR_FGD) defines a possible foreground pixel.
            </param>
             <param name="rect">The rectangle to initialize the segmentation</param>
             <param name="bgdModel">
             Temporary array for the background model. Do not modify it while you are
             processing the same image.
             </param>
             <param name="fgdModel">
             Temporary arrays for the foreground model. Do not modify it while you are
             processing the same image.
             </param>
             <param name="iterCount">The number of iterations</param>
             <param name="type">The initialization type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sqrt(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculate square root of each source array element. in the case of multichannel
            arrays each channel is processed independently. The function accuracy is approximately
            the same as of the built-in std::sqrt.
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ApplyColorMap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorMapType)">
            <summary>
            Apply color map to the image
            </summary>
            <param name="src">
            The source image.         
            This function expects Image&lt;Bgr, Byte&gt; or Image&lt;Gray, Byte&gt;. If the wrong image type is given, the original image
            will be returned.</param>
            <param name="dst">The destination image</param>
            <param name="colorMapType">The type of color map</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CheckRange(Emgu.CV.IInputArray,System.Boolean,System.Drawing.Point@,System.Double,System.Double)">
            <summary>
            Check that every array element is neither NaN nor +- inf. The functions also check that each value
            is between minVal and maxVal. in the case of multi-channel arrays each channel is processed
            independently. If some values are out of range, position of the first outlier is stored in pos, 
            and then the functions either return false (when quiet=true) or throw an exception.
            </summary>
            <param name="arr">The array to check</param>
            <param name="quiet">The flag indicating whether the functions quietly return false when the array elements are
            out of range, or they throw an exception</param>
            <param name="pos">This will be filled with the position of the first outlier</param>
            <param name="minVal">The inclusive lower boundary of valid values range</param>
            <param name="maxVal">The exclusive upper boundary of valid values range</param>
            <returns>If quiet, return true if all values are in range</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffine3D(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Matrix{System.Double}@,System.Byte[]@,System.Double,System.Double)">
            <summary>
            Computes an optimal affine transformation between two 3D point sets.
            </summary>
            <param name="src">First input 3D point set.</param>
            <param name="dst">Second input 3D point set.</param>
            <param name="estimate">Output 3D affine transformation matrix.</param>
            <param name="inliers">Output vector indicating which points are inliers.</param>
            <param name="ransacThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffine3D(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Computes an optimal affine transformation between two 3D point sets.
            </summary>
            <param name="src"> First input 3D point set.</param>
            <param name="dst">Second input 3D point set.</param>
            <param name="affineEstimate">Output 3D affine transformation matrix 3 x 4</param>
            <param name="inliers"> Output vector indicating which points are inliers.</param>
            <param name="ransacThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinMaxIdx(Emgu.CV.IInputArray,System.Double@,System.Double@,System.Int32[],System.Int32[],Emgu.CV.IInputArray)">
            <summary>
            Finds the global minimum and maximum in an array
            </summary>
            <param name="src">Input single-channel array.</param>
            <param name="minVal">The returned minimum value</param>
            <param name="maxVal">The returned maximum value</param>
            <param name="minIdx">The returned minimum location</param>
            <param name="maxIdx">The returned maximum location</param>
            <param name="mask">The extremums are searched across the whole array if mask is IntPtr.Zert. Otherwise, search is performed in the specified array region.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Filter2D(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="kernel">Convolution kernel, single-channel floating point matrix. If you want to apply different kernels to different channels, split the image using cvSplit into separate color planes and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor shoud lie within the kernel. The special default value (-1,-1) means that it is at the kernel center</param>
            <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
            <param name="borderType">The pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CLAHE(Emgu.CV.IInputArray,System.Double,System.Drawing.Size,Emgu.CV.IOutputArray)">
            <summary>
            Contrast Limited Adaptive Histogram Equalization (CLAHE)
            </summary>
            <param name="src">The source image</param>
            <param name="clipLimit">Clip Limit, use 40 for default</param>
            <param name="tileGridSize">Tile grid size, use (8, 8) for default</param>
            <param name="dst">The destination image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetCvStructSizes(Emgu.CV.Structure.CvStructSizes@)">
            <summary>
            This function retrieve the Open CV structure sizes in unmanaged code
            </summary>
            <param name="sizes">The structure that will hold the Open CV structure sizes</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindCirclesGrid(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.Size,Emgu.CV.CvEnum.CalibCgType,Emgu.CV.Features2D.IFeatureDetector)">
            <summary>
            Finds centers in the grid of circles
            </summary>
            <param name="image">Source chessboard view</param>
            <param name="patternSize">The number of inner circle per chessboard row and column</param>
            <param name="flags">Various operation flags</param>
            <param name="featureDetector">The feature detector. Use a SimpleBlobDetector for default</param>
            <returns>The center of circles detected if the chess board pattern is found, otherwise null is returned</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindCirclesGrid(Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibCgType,Emgu.CV.Features2D.IFeatureDetector)">
            <summary>
            Finds centers in the grid of circles
            </summary>
            <param name="image">Source chessboard view</param>
            <param name="patternSize">The number of inner circle per chessboard row and column</param>
            <param name="flags">Various operation flags</param>
            <param name="featureDetector">The feature detector. Use a SimpleBlobDetector for default</param>
            <param name="centers">output array of detected centers.</param>
            <returns>True if grid found.</returns>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpenCVModuleList">
            <summary>
            The List of the opencv modules
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imread(System.String,Emgu.CV.CvEnum.LoadImageType)">
            <summary>
            Loads an image from the specified file and returns the pointer to the loaded image. Currently the following file formats are supported: 
            Windows bitmaps - BMP, DIB; 
            JPEG files - JPEG, JPG, JPE; 
            Portable Network Graphics - PNG; 
            Portable image format - PBM, PGM, PPM; 
            Sun rasters - SR, RAS; 
            TIFF files - TIFF, TIF; 
            OpenEXR HDR images - EXR; 
            JPEG 2000 images - jp2. 
            </summary>
            <param name="filename">The name of the file to be loaded</param>
            <param name="loadType">The image loading type</param>
            <returns>The loaded image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imwrite(System.String,Emgu.CV.IInputArray,System.Int32[])">
            <summary>
            Saves the image to the specified file. The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format
            </summary>
            <param name="filename">The name of the file to be saved to</param>
            <param name="image">The image to be saved</param>
            <param name="parameters">The parameters</param>
            <returns>true if success</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imdecode(System.Byte[],Emgu.CV.CvEnum.LoadImageType,Emgu.CV.Mat)">
            <summary>
            Decode image stored in the buffer
            </summary>
            <param name="buf">The buffer</param>
            <param name="loadType">The image loading type</param>
            <param name="dst">The output placeholder for the decoded matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imdecode(Emgu.CV.IInputArray,Emgu.CV.CvEnum.LoadImageType,Emgu.CV.Mat)">
            <summary>
            Decode image stored in the buffer
            </summary>
            <param name="buf">The buffer</param>
            <param name="loadType">The image loading type</param>
            <param name="dst">The output placeholder for the decoded matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imencode(System.String,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfByte,System.Int32[])">
            <summary>
            encode image and store the result as a byte vector.
            </summary>
            <param name="ext">The image format</param>
            <param name="image">The image</param>
            <param name="buf">Output buffer resized to fit the compressed image.</param>
            <param name="parameters">The pointer to the array of intergers, which contains the parameter for encoding, use IntPtr.Zero for default</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNamedWindow(System.String)">
            <summary>
            Creates a window which can be used as a placeholder for images and trackbars. Created windows are reffered by their names. 
            If the window with such a name already exists, the function does nothing.
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvWaitKey(System.Int32)">
            <summary>
            Waits for key event infinitely (delay &lt;= 0) or for "delay" milliseconds. 
            </summary>
            <param name="delay">Delay in milliseconds.</param>
            <returns>The code of the pressed key or -1 if no key were pressed until the specified timeout has elapsed</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvShowImage(System.String,System.IntPtr)">
            <summary>
            Shows the image in the specified window
            </summary>
            <param name="name">Name of the window</param>
            <param name="image">Image to be shown</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDestroyWindow(System.String)">
            <summary>
            Destroys the window with a given name
            </summary>
            <param name="name">Name of the window to be destroyed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSampleLine(System.IntPtr,System.Drawing.Point,System.Drawing.Point,System.IntPtr,Emgu.CV.CvEnum.Connectivity)">
            <summary>
            Implements a particular case of application of line iterators. The function reads all the image points lying on the line between pt1 and pt2, including the ending points, and stores them into the buffer
            </summary>
            <param name="image">Image to sample the line from</param>
            <param name="pt1">Starting the line point.</param>
            <param name="pt2">Ending the line point</param>
            <param name="buffer">Buffer to store the line points; must have enough size to store max( |pt2.x-pt1.x|+1, |pt2.y-pt1.y|+1 ) points in case of 8-connected line and |pt2.x-pt1.x|+|pt2.y-pt1.y|+1 in case of 4-connected line</param>
            <param name="connectivity">The line connectivity, 4 or 8</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRectSubPix(System.IntPtr,System.IntPtr,System.Drawing.PointF)">
            <summary>
            Extracts pixels from src:
            dst(x, y) = src(x + center.x - (width(dst)-1)*0.5, y + center.y - (height(dst)-1)*0.5)
            where the values of pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multiple-channel images is processed independently. Whereas the rectangle center must be inside the image, the whole rectangle may be partially occluded. In this case, the replication border mode is used to get pixel values beyond the image boundaries.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Extracted rectangle</param>
            <param name="center">Floating point coordinates of the extracted rectangle center within the source image. The center must be inside the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetQuadrangleSubPix(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Extracts pixels from src at sub-pixel accuracy and stores them to dst as follows:
            dst(x, y)= src( A_11 x'+A_12 y'+ b1, A_21 x'+A_22 y'+ b2),
            where A and b are taken from map_matrix:
            map_matrix = [ [A11 A12  b1], [ A21 A22  b2 ] ]
            x'=x-(width(dst)-1)*0.5, y'=y-(height(dst)-1)*0.5
            where the values of pixels at non-integer coordinates A (x,y)^T + b are retrieved using bilinear interpolation. When the function needs pixels outside of the image, it uses replication border mode to reconstruct the values. Every channel of multiple-channel images is processed independently.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Extracted quadrangle</param>
            <param name="mapMatrix">The transformation 2 x 3 matrix [A|b]</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Resize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.Inter)">
            <summary>
            Resizes the image src down to or up to the specified size
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image</param>
            <param name="dsize">Output image size; if it equals zero, it is computed as: dsize=Size(round(fx*src.cols), round(fy * src.rows)). Either dsize or both fx and fy must be non-zero.</param>
            <param name="fx">Scale factor along the horizontal axis</param>
            <param name="fy">Scale factor along the vertical axis;</param>
            <param name="interpolation">Interpolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WarpAffine(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies an affine transformation to an image.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="dsize">Size of the output image.</param>
            <param name="interpMethod">Interpolation method</param>
            <param name="warpMethod">Warp method</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="borderValue">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetAffineTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Pointer to an array of PointF, Coordinates of 3 triangle vertices in the source image.</param>
            <param name="dst">Pointer to an array of PointF, Coordinates of the 3 corresponding triangle vertices in the destination image</param>
            <returns>The destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetRotationMatrix2D(System.Drawing.PointF,System.Double,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Calculates rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image. </param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner).</param>
            <param name="scale">Isotropic scale factor</param>
            <param name="mapMatrix">Pointer to the destination 2x3 matrix</param>
            <returns>Pointer to the destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WarpPerspective(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies a perspective transformation to an image
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="dsize">Size of the output image</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">Warp method</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="borderValue">value used in case of a constant border</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetPerspectiveTransform(System.Drawing.PointF[],System.Drawing.PointF[],System.IntPtr)">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dst">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <param name="mapMatrix">Pointer to the destination 3x3 matrix</param>
            <returns>Pointer to the perspective transform matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetPerspectiveTransform(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dst">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <param name="mapMatrix">Pointer to the destination 3x3 matrix</param>
            <returns>Pointer to the perspective transform matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Remap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies a generic geometrical transformation to an image.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="map1">The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1 , or CV_32FC2 . See convertMaps() for details on converting a floating point representation to fixed-point for speed.</param>
            <param name="map2">The second map of y values having the type CV_16UC1 , CV_32FC1 , or none (empty map if map1 is (x,y) points), respectively.</param>
            <param name="interpolation">Interpolation method (see resize() ). The method 'Area' is not supported by this function. </param>
            <param name="borderMode">Pixel extrapolation method </param>
            <param name="borderValue">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InvertAffineTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Inverts an affine transformation
            </summary>
            <param name="m">Original affine transformation</param>
            <param name="im">Output reverse affine transformation.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDefaultNewCameraMatrix(Emgu.CV.IInputArray,System.Drawing.Size,System.Boolean)">
            <summary>
            Returns the default new camera matrix.
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="imgsize">Camera view image size in pixels.</param>
            <param name="centerPrincipalPoint">Location of the principal point in the new camera matrix. The parameter indicates whether this location should be at the image center or not.</param>
            <returns>The default new camera matrix.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LogPolar(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="M">Magnitude scale parameter</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">warp method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LinearPolar(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="maxRadius">Maximum radius</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">Warp method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrDown(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Performs downsampling step of Gaussian pyramid decomposition. First it convolves source image with the specified filter and then downsamples the image by rejecting even rows and columns.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="borderType">Border type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrUp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Performs up-sampling step of Gaussian pyramid decomposition. First it upsamples the source image by injecting even zero rows and columns and then convolves result with the specified filter multiplied by 4 for interpolation. So the destination image is four times larger than the source image.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="borderType">Border type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Watershed(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray)">
            <summary>
            Implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in [Meyer92] Before passing the image to the function, user has to outline roughly the desired regions in the image markers with positive (>0) indices, i.e. every region is represented as one or more connected components with the pixel values 1, 2, 3 etc. Those components will be "seeds" of the future image regions. All the other pixels in markers, which relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0's. On the output of the function, each pixel in markers is set to one of values of the "seed" components, or to -1 at boundaries between the regions.
            </summary>
            <remarks>Note, that it is not necessary that every two neighbor connected components are separated by a watershed boundary (-1's pixels), for example, in case when such tangent components exist in the initial marker image. </remarks>
            <param name="image">The input 8-bit 3-channel image</param>
            <param name="markers">The input/output Int32 depth single-channel image (map) of markers. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMaxRect(System.Drawing.Rectangle@,System.Drawing.Rectangle@)">
            <summary>
            Finds minimum area rectangle that contains both input rectangles inside
            </summary>
            <param name="rect1">First rectangle </param>
            <param name="rect2">Second rectangle </param>
            <returns>The minimum area rectangle that contains both input rectangles inside</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitLine(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DistType,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to 2D or 3D point set 
            </summary>
            <param name="points">Input vector of 2D or 3D points, stored in std::vector or Mat.</param>
            <param name="distType">The distance used for fitting </param>
            <param name="param">Numerical parameter (C) for some types of distances, if 0 then some optimal value is chosen</param>
            <param name="reps">Sufficient accuracy for radius (distance between the coordinate origin and the line),  0.01 would be a good default</param>
            <param name="aeps">Sufficient accuracy for angle, 0.01 would be a good default</param>
            <param name="line">Output line parameters. In case of 2D ?tting, it should be a vector of 4 elements (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line 
            and (x0, y0) is a point on the line. In case of 3D ?tting, it should be a vector of 6 elements
            (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector
            collinear to the line and (x0, y0, z0) is a point on the line.
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitLine(System.Drawing.PointF[],System.Drawing.PointF@,System.Drawing.PointF@,Emgu.CV.CvEnum.DistType,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to 2D or 3D point set 
            </summary>
            <param name="points">Input vector of 2D points.</param>
            <param name="distType">The distance used for fitting </param>
            <param name="param">Numerical parameter (C) for some types of distances, if 0 then some optimal value is chosen</param>
            <param name="reps">Sufficient accuracy for radius (distance between the coordinate origin and the line),  0.01 would be a good default</param>
            <param name="aeps">Sufficient accuracy for angle, 0.01 would be a good default</param>
            <param name="direction">A normalized vector collinear to the line </param>
            <param name="pointOnLine">A point on the line.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RotatedRectangleIntersection(Emgu.CV.Structure.RotatedRect,Emgu.CV.Structure.RotatedRect,Emgu.CV.IOutputArray)">
            <summary>
            Finds out if there is any intersection between two rotated rectangles.
            </summary>
            <param name="rect1">First rectangle</param>
            <param name="rect2">Second rectangle</param>
            <param name="intersectingRegion">The output array of the verticies of the intersecting region. It returns at most 8 vertices. Stored as VectorOfPointF or Mat as Mx1 of type CV_32FC2.</param>
            <returns>The intersect type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxPoints(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Calculates vertices of the input 2d box.
            </summary>
            <param name="box">The box</param>
            <returns>The four vertices of rectangles.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxPoints(Emgu.CV.Structure.RotatedRect,Emgu.CV.IOutputArray)">
            <summary>
            Calculates vertices of the input 2d box.
            </summary>
            <param name="box">The box</param>
            <param name="points">The output array of four vertices of rectangles.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitEllipse(Emgu.CV.IInputArray)">
            <summary>
            Fits an ellipse around a set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns>The ellipse that fits best (in least-squares sense) to a set of 2D points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvexHull(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Finds convex hull of 2D point set using Sklansky's algorithm
            </summary>
            <param name="points">The points to find convex hull from</param>
            <param name="clockwise">Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards.</param>
            <returns>The convex hull of the points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvexHull(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,System.Boolean)">
            <summary>
            The function cvConvexHull2 finds convex hull of 2D point set using Sklansky's algorithm. 
            </summary>
            <param name="points"> Input 2D point set</param>
            <param name="hull">Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves.</param>
            <param name="clockwise">Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards.</param>
            <param name="returnPoints">Operation flag. In case of a matrix, when the flag is true, the function returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std::vector, the flag is ignored, and the output depends on the type of the vector</param>
        </member>
        <member name="F:Emgu.CV.CvInvoke.MorphologyDefaultBorderValue">
            <summary>
            The default morphology value.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Erode(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:
            dst=erode(src,element):  dst(x,y)=min((x',y') in element)) src(x+x',y+y')
            The function supports the in-place mode. Erosion can be applied several (iterations) times. In case of color image each channel is processed independently.
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used.</param>
            <param name="iterations">Number of times erosion is applied.</param>
            <param name="borderType">Pixel extrapolation method</param>
            <param name="borderValue">Border value in case of a constant border, use Constant for default</param>
            <param name="anchor">Position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dilate(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken
            The function supports the in-place mode. Dilation can be applied several (iterations) times. In case of color image each channel is processed independently
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used</param>
            <param name="iterations">Number of times erosion is applied</param>
            <param name="borderType">Pixel extrapolation method</param>
            <param name="borderValue">Border value in case of a constant border </param>
            <param name="anchor">Position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GaussianBlur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using a Gaussian filter.
            </summary>
            <param name="src">input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</param>
            <param name="dst">output image of the same size and type as src.</param>
            <param name="ksize">Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zeros and then they are computed from sigma* .</param>
            <param name="sigmaX">Gaussian kernel standard deviation in X direction.</param>
            <param name="sigmaY">Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height , respectively (see getGaussianKernel() for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</param>
            <param name="borderType">Pixel extrapolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Blur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Drawing.Point,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using the normalized box filter.
            </summary>
            <param name="src">input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="ksize">Blurring kernel size.</param>
            <param name="anchor">Anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MedianBlur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Blurs an image using the median filter.
            </summary>
            <param name="src">Input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.</param>
            <param name="dst">Destination array of the same size and type as src.</param>
            <param name="ksize">Aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Drawing.Size,System.Drawing.Point,System.Boolean,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using the box filter.
            </summary>
            <param name="src">Input image.</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="ddepth">The output image depth (-1 to use src.depth()).</param>
            <param name="ksize">Blurring kernel size.</param>
            <param name="anchor">Anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.</param>
            <param name="normalize">Specifying whether the kernel is normalized by its area or not.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BilateralFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Applies the bilateral filter to an image.
            </summary>
            <param name="src">Source 8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="dst">Destination image of the same size and type as src .</param>
            <param name="d">Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace .</param>
            <param name="sigmaColor">Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace ) will be mixed together, resulting in larger areas of semi-equal color.</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d>0 , it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sobel(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
             <summary>
             The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative. The first case corresponds to
             <pre> 
              |-1  0  1|
              |-2  0  2|
              |-1  0  1|</pre>
             kernel and the second one corresponds to
             <pre>
              |-1 -2 -1|
              | 0  0  0|
              | 1  2  1|</pre>
             or
             <pre>
              | 1  2  1|
              | 0  0  0|
              |-1 -2 -1|</pre>
             kernel, depending on the image origin (origin field of IplImage structure). No scaling is done, so the destination image usually has larger by absolute value numbers than the source image. To avoid overflow, the function requires 16-bit destination image if the source image is 8-bit. The result can be converted back to 8-bit using cvConvertScale or cvConvertScaleAbs functions. Besides 8-bit images the function can process 32-bit floating-point images. Both source and destination must be single-channel images of equal size or ROI size
             </summary>
             <param name="src">Source image.</param>
             <param name="dst">Destination image</param>
             <param name="ddepth">output image depth; the following combinations of src.depth() and ddepth are supported:
             <para> src.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F </para>
             <para> src.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F</para>
             <para> src.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F</para>
             <para>src.depth() = CV_64F, ddepth = -1/CV_64F</para>
             when ddepth=-1, the destination image will have the same depth as the source; in the case of 8-bit input images it will result in truncated derivatives.</param>
             <param name="xorder">Order of the derivative x </param>
             <param name="yorder">Order of the derivative y</param>
             <param name="kSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. </param>
            <param name="borderType">Pixel extrapolation method </param>
            <param name="scale">Optional scale factor for the computed derivative values</param>
            <param name="delta">Optional delta value that is added to the results prior to storing them in <paramref name="dst"/></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Laplacian(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator:
            dst(x,y) = d2src/dx2 + d2src/dy2
            Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            |0  1  0|
            |1 -4  1|
            |0  1  0|
            Similar to cvSobel function, no scaling is done and the same combinations of input and output formats are supported. 
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image. Should have type of float</param>
            <param name="ddepth">Desired depth of the destination image.</param>
            <param name="ksize">Aperture size used to compute the second-derivative filters.</param>
            <param name="scale">Optional scale factor for the computed Laplacian values. By default, no scaling is applied. </param>
            <param name="delta">Optional delta value that is added to the results prior to storing them in dst.</param>
            <param name="borderType"> Pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Canny(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Boolean)">
             <summary>
             Finds the edges on the input <paramref name="image"/> and marks them in the output image edges using the Canny algorithm. The smallest of threshold1 and threshold2 is used for edge linking, the largest - to find initial segments of strong edges.
             </summary>
             <param name="image">Input image</param>
             <param name="edges">Image to store the edges found by the function</param>
             <param name="threshold1">The first threshold</param>
             <param name="threshold2">The second threshold.</param>
             <param name="apertureSize">Aperture parameter for Sobel operator </param>
            <param name="l2Gradient">a flag, indicating whether a more accurate norm should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default norm is enough ( L2gradient=false ).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.IsContourConvex(Emgu.CV.IInputArray)">
            <summary>
            The function tests whether the input contour is convex or not. The contour must be simple, that is, without self-intersections. Otherwise, the function output is undefined.
            </summary>
            <param name="contour">Input vector of 2D points </param>
            <returns>true if input is convex</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PointPolygonTest(Emgu.CV.IInputArray,System.Drawing.PointF,System.Boolean)">
            <summary>
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex). It returns positive, negative or zero value, correspondingly
            </summary>
            <param name="contour">Input contour</param>
            <param name="pt">The point tested against the contour</param>
            <param name="measureDist">If != 0, the function estimates distance from the point to the nearest contour edge</param>
            <returns>
            When measureDist = false, the return value is &gt;0 (inside), &lt;0 (outside) and =0 (on edge), respectively. 
            When measureDist != true, it is a signed distance between the point and the nearest contour edge
            </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvexityDefects(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Finds all convexity defects of the input contour and returns a sequence of the CvConvexityDefect structures. 
            </summary>
            <param name="contour">Input contour</param>
            <param name="convexhull">Convex hull obtained using cvConvexHull2 that should contain pointers or indices to the contour points, not the hull points themselves, i.e. return_points parameter in cvConvexHull2 should be 0</param>
            <param name="storage">Container for output sequence of convexity defects. If it is NULL, contour or hull (in that order) storage is used</param>
            <returns>Pointer to the sequence of the CvConvexityDefect structures. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinAreaRect(System.Drawing.PointF[])">
            <summary>
            Find the bounding rectangle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The bounding rectangle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinAreaRect(Emgu.CV.IInputArray)">
            <summary>
            Finds a rotated rectangle of the minimum area enclosing the input 2D point set.
            </summary>
            <param name="points">Input vector of 2D points</param>
            <returns>a circumscribed rectangle of the minimal area for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingCircle(System.Drawing.PointF[])">
             <summary>
             Finds the minimal circumscribed circle for 2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)
             </summary>
             <param name="points">Sequence or array of 2D points</param>
            <returns>The minimal circumscribed circle for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingCircle(Emgu.CV.IInputArray)">
             <summary>
             Finds the minimal circumscribed circle for 2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)
             </summary>
             <param name="points">Sequence or array of 2D points</param>
            <returns>The minimal circumscribed circle for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingTriangle(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Finds a triangle of minimum area enclosing a 2D point set and returns its area.
            </summary>
            <param name="points">Input vector of 2D points with depth CV_32S or CV_32F</param>
            <param name="triangles">Output vector of three 2D points defining the vertices of the triangle. The depth of the OutputArray must be CV_32F.</param>
            <returns>The triangle's area</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ApproxPolyDP(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Boolean)">
             <summary>
             Approximates a polygonal curve(s) with the specified precision.
             </summary>
            <param name="curve">Input vector of a 2D point</param>
             <param name="approxCurve">Result of the approximation. The type should match the type of the input curve. </param>
             <param name="epsilon">Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation.</param>
             <param name="closed"> If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoundingRectangle(Emgu.CV.IInputArray)">
            <summary>
            Returns the up-right bounding rectangle for 2d point set
            </summary>
            <param name="points"> Input 2D point set, stored in std::vector or Mat.</param>
            <returns>The up-right bounding rectangle for 2d point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ContourArea(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates area of the whole contour or contour section. 
            </summary>
            <param name="contour">Input vector of 2D points (contour vertices), stored in std::vector or Mat. </param>
            <param name="oriented">Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-clockwise).
            Using this feature you can determine orientation of a contour by taking the sign of an area. 
            By default, the parameter is false, which means that the absolute value is returned.</param>
            <returns>The area of the whole contour or contour section</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ArcLength(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length
            </summary>
            <param name="curve">Sequence or array of the curve points</param>
            <param name="isClosed">
            Indicates whether the curve is closed or not.
            </param>
            <returns>Contour perimeter or a curve length</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Threshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.ThresholdType)">
            <summary>
            Applies fixed-level thresholding to single-channel array. The function is typically used to get bi-level (binary) image out of grayscale image (cvCmpS could be also used for this purpose) or for removing a noise, i.e. filtering out pixels with too small or too large values. There are several types of thresholding the function supports that are determined by threshold_type
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="threshold">Threshold value</param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="thresholdType">Thresholding type </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AdaptiveThreshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.AdaptiveThresholdType,Emgu.CV.CvEnum.ThresholdType,System.Int32,System.Double)">
            <summary>
            Transforms grayscale image to binary image. 
            Threshold calculated individually for each pixel. 
            For the method CV_ADAPTIVE_THRESH_MEAN_C it is a mean of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel
            neighborhood, subtracted by param1. 
            For the method CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel neighborhood, subtracted by param1.
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="adaptiveType">Adaptive_method </param>
            <param name="thresholdType">Thresholding type. must be one of CV_THRESH_BINARY, CV_THRESH_BINARY_INV  </param>
            <param name="blockSize">The size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, ... </param>
            <param name="param1">Constant subtracted from mean or weighted mean. It may be negative. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindContours(Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.RetrType,Emgu.CV.CvEnum.ChainApproxMethod,System.Drawing.Point)">
            <summary>
            Retrieves contours from the binary image and returns the number of retrieved contours. The pointer firstContour is filled by the function. It will contain pointer to the first most outer contour or IntPtr.Zero if no contours is detected (if the image is completely black). Other contours may be reached from firstContour using h_next and v_next links. The sample in cvDrawContours discussion shows how to use contours for connected component detection. Contours can be also used for shape analysis and object recognition - see squares.c in OpenCV sample directory
            The function modifies the source image content
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1s, zero pixels remain 0s - that is image treated as binary. To get such a binary image from grayscale, one may use cvThreshold, cvAdaptiveThreshold or cvCanny. The function modifies the source image content</param>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology.</param>
            <param name="mode">Retrieval mode</param>
            <param name="method">Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). </param>
            <param name="offset">Offset, by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context</param>
            <returns>The number of countours</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindContourTree(Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ChainApproxMethod,System.Drawing.Point)">
            <summary>
            Retrieves contours from the binary image as a contour tree. The pointer firstContour is filled by the function. It is provided as a convenient way to obtain the hierarchy value as int[,].
            The function modifies the source image content
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1s, zero pixels remain 0s - that is image treated as binary. To get such a binary image from grayscale, one may use cvThreshold, cvAdaptiveThreshold or cvCanny. The function modifies the source image content</param>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="method">Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). </param>
            <param name="offset">Offset, by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context</param>
            <returns>The contour hierarchy</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RawDataToBitmap(System.IntPtr,System.Int32,System.Drawing.Size,System.Type,System.Int32,System.Type,System.Boolean)">
            <summary>
            Convert raw data to bitmap
            </summary>
            <param name="scan0">The pointer to the raw data</param>
            <param name="step">The step</param>
            <param name="size">The size of the image</param>
            <param name="srcColorType">The source image color type</param>
            <param name="numberOfChannels">The number of channels</param>
            <param name="srcDepthType">The source image depth type</param>
            <param name="tryDataSharing">Try to create Bitmap that shares the data with the image</param>
            <returns>The Bitmap</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEndFindContours(System.IntPtr@)">
            <summary>
            Finishes the scanning process and returns a pointer to the first contour on the
            highest level.
            </summary>
            <param name="scanner">Reference to the contour scanner</param>
            <returns>pointer to the first contour on the highest level</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvtColor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Type,System.Type)">
            <summary>
            Converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </summary>
            <param name="src">The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image</param>
            <param name="dest">The destination image of the same data type as the source one. The number of channels may be different</param>
            <param name="srcColor">Source color type. </param>
            <param name="destColor">Destination color type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvtColor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorConversion,System.Int32)">
            <summary>
            Converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </summary>
            <param name="src">The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image</param>
            <param name="dst">The destination image of the same data type as the source one. The number of channels may be different</param>
            <param name="code">Color conversion operation that can be specifed using CV_src_color_space2dst_color_space constants </param>
            <param name="dstCn">number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code .</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughCircles(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.HoughType,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in grayscale image using some modification of Hough transform
            </summary>
            <param name="image">The input 8-bit single-channel grayscale image</param>
            <param name="circles">The storage for the circles detected. It can be a memory storage (in this case a sequence of circles is created in the storage and returned by the function) or single row/single column matrix (CvMat*) of type CV_32FC3, to which the circles' parameters are written. The matrix header is modified by the function so its cols or rows will contain a number of lines detected. If circle_storage is a matrix and the actual number of lines exceeds the matrix size, the maximum possible number of circles is returned. Every circle is encoded as 3 floating-point numbers: center coordinates (x,y) and the radius</param>
            <param name="method">Currently, the only implemented method is CV_HOUGH_GRADIENT</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="minDist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <param name="param1">The first method-specific parameter. In case of CV_HOUGH_GRADIENT it is the higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller). </param>
            <param name="param2">The second method-specific parameter. In case of CV_HOUGH_GRADIENT it is accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="minRadius">Minimal radius of the circles to search for</param>
            <param name="maxRadius">Maximal radius of the circles to search for. By default the maximal radius is set to max(image_width, image_height). </param>
            <returns>Pointer to the sequence of circles</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughCircles(Emgu.CV.IInputArray,Emgu.CV.CvEnum.HoughType,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in a grayscale image using the Hough transform
            </summary>
            <param name="image">8-bit, single-channel, grayscale input image.</param>
            <param name="method">Detection method to use. Currently, the only implemented method is CV_HOUGH_GRADIENT , which is basically 21HT</param>
            <param name="dp">Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height.</param>
            <param name="minDist">Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.</param>
            <param name="param1">First method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the higher threshold of the two passed to the Canny() edge detector (the lower one is twice smaller).</param>
            <param name="param2">Second method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first.</param>
            <param name="minRadius"> Minimum circle radius.</param>
            <param name="maxRadius">Maximum circle radius.</param>
            <returns>The circles detected</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLines(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines in a binary image using the standard Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="lines">Output vector of lines. Each line is represented by a two-element vector</param>
            <param name="rho">Distance resolution of the accumulator in pixels.</param>
            <param name="theta">Angle resolution of the accumulator in radians.</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt; threshold)</param>
            <param name="srn">For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive.</param>
            <param name="stn"> For the multi-scale Hough transform, it is a divisor for the distance resolution theta</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLinesP(Emgu.CV.IInputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes</param>
            <param name="minLineLength">Minimum line length. Line segments shorter than that are rejected.</param>
            <param name="maxGap">Maximum allowed gap between points on the same line to link them.</param>
            <returns>The found line segments</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLinesP(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="lines"> Output vector of lines. Each line is represented by a 4-element vector (x1, y1, x2, y2)</param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes</param>
            <param name="minLineLength">Minimum line length. Line segments shorter than that are rejected.</param>
            <param name="maxGap">Maximum allowed gap between points on the same line to link them.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Moments(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characeteristics including 7 Hu invariants.
            </summary>
            <param name="arr">Image (1-channel or 3-channel with COI set) or polygon (CvSeq of points or a vector of points)</param>
            <param name="binaryImage">(For images only) If the flag is true, all the zero pixel values are treated as zeroes, all the others are treated as 1s</param>
            <returns>The moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MatchTemplate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.TemplateMatchingType)">
            <summary>
            This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MatchShapes(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.ContoursMatchType,System.Double)">
            <summary>
            Compares two shapes. The 3 implemented methods all use Hu moments
            </summary>
            <param name="contour1">First contour or grayscale image</param>
            <param name="contour2">Second contour or grayscale image</param>
            <param name="method">Comparison method</param>
            <param name="parameter">Method-specific parameter (is not used now)</param>
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetStructuringElement(Emgu.CV.CvEnum.ElementShape,System.Drawing.Size,System.Drawing.Point)">
            <summary>
            Returns a structuring element of the specified size and shape for morphological operations.
            </summary>
            <param name="shape">Element shape</param>
            <param name="ksize">Size of the structuring element.</param>
            <param name="anchor">Anchor position within the element. The value (-1, -1) means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.</param>
            <returns>The structuring element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MorphologyEx(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Performs advanced morphological transformations.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="kernel">Structuring element.</param>
            <param name="operation">Type of morphological operation.</param>
            <param name="iterations">Number of times erosion and dilation are applied.</param>
            <param name="borderType">Pixel extrapolation method.</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="borderValue">Border value in case of a constant border. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EqualizeHist(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            The algorithm normalizes brightness and increases contrast of the image
            </summary>
            <param name="src">The input 8-bit single-channel image</param>
            <param name="dst">The output image of the same size and the same data type as src</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcHist(Emgu.CV.IInputArray,System.Int32[],Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32[],System.Single[],System.Boolean)">
            <summary>
            Calculates a histogram of a set of arrays.
            </summary>
            <param name="images">Source arrays. They all should have the same depth, CV_8U or CV_32F , and the same size. Each of them can have an arbitrary number of channels.</param>
            <param name="channels">List of the channels used to compute the histogram. </param>
            <param name="mask">Optional mask. If the matrix is not empty, it must be an 8-bit array of the same size as images[i] . The non-zero mask elements mark the array elements counted in the histogram.</param>
            <param name="hist">Output histogram</param>
            <param name="histSize">Array of histogram sizes in each dimension.</param>
            <param name="ranges">Array of the dims arrays of the histogram bin boundaries in each dimension.</param>
            <param name="accumulate">Accumulation flag. If it is set, the histogram is not cleared in the beginning when it is allocated. This feature enables you to compute a single histogram from several sets of arrays, or to update the histogram in time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcBackProject(Emgu.CV.IInputArray,System.Int32[],Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single[],System.Double)">
            <summary>
            Calculates the back projection of a histogram.
            </summary>
            <param name="images">Source arrays. They all should have the same depth, CV_8U or CV_32F , and the same size. Each of them can have an arbitrary number of channels.</param>
            <param name="channels">Number of source images.</param>
            <param name="hist">Input histogram that can be dense or sparse.</param>
            <param name="backProject">Destination back projection array that is a single-channel array of the same size and depth as images[0] .</param>
            <param name="ranges">Array of arrays of the histogram bin boundaries in each dimension.</param>
            <param name="scale"> Optional scale factor for the output back projection.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CompareHist(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.HistogramCompMethod)">
            <summary>
            Compares two histograms.
            </summary>
            <param name="h1">First compared histogram.</param>
            <param name="h2">Second compared histogram of the same size as H1 .</param>
            <param name="method">Comparison method</param>
            <returns>The distance between the histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSpatialMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves the spatial moment, which in case of image moments is defined as:
            M_{x_order,y_order}=sum_{x,y}(I(x,y) * x^{x_order} * y^{y_order})
            where I(x,y) is the intensity of the pixel (x, y). 
            </summary>
            <param name="moments">The moment state</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0. </param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The spatial moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCentralMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves the central moment, which in case of image moments is defined as:
            mu_{x_order,y_order}=sum_{x,y}(I(x,y)*(x-x_c)^{x_order} * (y-y_c)^{y_order}),
            where x_c=M10/M00, y_c=M01/M00 - coordinates of the gravity center
            </summary>
            <param name="moments">Reference to the moment state structure</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The center moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetNormalizedCentralMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves normalized central moment, which in case of image moments is defined as:
            eta_{x_order,y_order}=mu_{x_order,y_order} / M00^{(y_order+x_order)/2+1},
            where mu_{x_order,y_order} is the central moment
            </summary>
            <param name="moments">Reference to the moment state structure</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The normalized center moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Accumulate(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds the whole image or its selected region to accumulator sum
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point. (each channel of multi-channel image is processed independently). </param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateSquare(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds the input <paramref name="src"/> or its selected region, raised to power 2, to the accumulator sqsum
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently)</param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateProduct(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds product of 2 images or thier selected regions to accumulator acc
            </summary>
            <param name="src1">First input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently)</param>
            <param name="src2">Second input image, the same format as the first one</param>
            <param name="dst">Accumulator of the same number of channels as input images, 32-bit or 64-bit floating-point</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateWeighted(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,Emgu.CV.IInputArray)">
            <summary>
            Calculates weighted sum of input <paramref name="src"/> and the accumulator acc so that acc becomes a running average of frame sequence:
            acc(x,y)=(1-<paramref name="alpha"/>) * acc(x,y) + <paramref name="alpha"/> * image(x,y) if mask(x,y)!=0
            where <paramref name="alpha"/> regulates update speed (how fast accumulator forgets about previous frames). 
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently). </param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="alpha">Weight of input image</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetHuMoments(Emgu.CV.Structure.MCvMoments@,Emgu.CV.Structure.MCvHuMoments@)">
            <summary>
            Calculates seven Hu invariants
            </summary>
            <param name="moments">Pointer to the moment state structure</param>
            <param name="huMoments">Pointer to Hu moments structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CornerHarris(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size x block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </summary>
            <param name="image">Input image</param>
            <param name="harrisResponse">Image to store the Harris detector responces. Should have the same size as image </param>
            <param name="blockSize">Neighborhood size </param>
            <param name="apertureSize">Aperture parameter for Sobel operator (see cvSobel). format. In the case of floating-point input format this parameter is the number of the fixed float filter used for differencing. </param>
            <param name="k">Harris detector free parameter.</param>
            <param name="borderType">Pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CornerSubPix(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="image">Input image</param>
            <param name="corners">Initial coordinates of the input corners and refined coordinates on output</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Integral(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates one or more integral images for the source image 
            Using these integral images, one may calculate sum, mean, standard deviation over arbitrary up-right or rotated rectangular region of the image in a constant time.
            It makes possible to do a fast blurring or fast block correlation with variable window size etc. In case of multi-channel images sums for each channel are accumulated independently. 
            </summary>
            <param name="image">The source image, WxH, 8-bit or floating-point (32f or 64f) image.</param>
            <param name="sum">The integral image, W+1xH+1, 32-bit integer or double precision floating-point (64f). </param>
            <param name="sqsum">The integral image for squared pixel values, W+1xH+1, double precision floating-point (64f). </param>
            <param name="tiltedSum">The integral for the image rotated by 45 degrees, W+1xH+1, the same data type as sum.</param>
            <param name="sdepth">Desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F.</param>
            <param name="sqdepth">Desired depth of the integral image of squared pixel values, CV_32F or CV_64F.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDistTransform(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.DistType,System.Int32,System.Single[],System.IntPtr)">
            <summary>
            Calculates distance to closest zero pixel for all non-zero pixels of source image
            </summary>
            <param name="src">Source 8-bit single-channel (binary) image.</param>
            <param name="dst">Output image with calculated distances (32-bit floating-point, single-channel). </param>
            <param name="distanceType">Type of distance</param>
            <param name="maskSize">Size of distance transform mask; can be 3 or 5.
            In case of CV_DIST_L1 or CV_DIST_C the parameter is forced to 3, because 3x3 mask gives the same result as 5x5 yet it is faster.</param>
            <param name="userMask">User-defined mask in case of user-defined distance.
            It consists of 2 numbers (horizontal/vertical shift cost, diagonal shift cost) in case of 3x3 mask
            and 3 numbers (horizontal/vertical shift cost, diagonal shift cost, knights move cost) in case of 5x5 mask.</param>
            <param name="labels">The optional output 2d array of labels of integer type and the same size as src and dst.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FloodFill(Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.Connectivity,Emgu.CV.CvEnum.FloodFillType)">
            <summary>
            Fills a connected component with given color.
            </summary>
            <param name="src">Input 1- or 3-channel, 8-bit or floating-point image. It is modified by the function unless CV_FLOODFILL_MASK_ONLY flag is set.</param>
            <param name="seedPoint">The starting point.</param>
            <param name="newVal">New value of repainted domain pixels.</param>
            <param name="loDiff">Maximal lower brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="upDiff">Maximal upper brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="flags">The operation flags.
            Lower bits contain connectivity value, 4 (by default) or 8, used within the function.
            Connectivity determines which neighbors of a pixel are considered.
            Upper bits can be 0 or combination of the following flags:
            CV_FLOODFILL_FIXED_RANGE - if set the difference between the current pixel and seed pixel is considered,
            otherwise difference between neighbor pixels is considered (the range is floating).
            CV_FLOODFILL_MASK_ONLY - if set, the function does not fill the image (new_val is ignored),
            but the fills mask (that must be non-NULL in this case). </param>
            <param name="mask">Operation mask,
            should be singe-channel 8-bit image, 2 pixels wider and 2 pixels taller than image.
            If not IntPtr.Zero, the function uses and updates the mask, so user takes responsibility of initializing mask content.
            Floodfilling can't go across non-zero pixels in the mask, for example, an edge detector output can be used as a mask to stop filling at edges.
            Or it is possible to use the same mask in multiple calls to the function to make sure the filled area do not overlap.
            Note: because mask is larger than the filled image, pixel in mask that corresponds to (x,y) pixel in image will have coordinates (x+1,y+1).</param>
            <param name="rect">Output parameter set by the function to the minimum bounding rectangle of the repainted domain.</param>
            <param name="connectivity">Flood fill connectivity</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrMeanShiftFiltering(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Filters image using meanshift algorithm
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Result image</param>
            <param name="sp">The spatial window radius.</param>
            <param name="sr">The color window radius.</param>
            <param name="maxLevel">Maximum level of the pyramid for the segmentation. Use 1 as default value</param>
            <param name="termcrit">Termination criteria: when to stop meanshift iterations. Use new MCvTermCriteria(5, 1) as default value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertMaps(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Boolean)">
            <summary>
            Converts image transformation maps from one representation to another.
            </summary>
            <param name="map1">The first input map of type CV_16SC2 , CV_32FC1 , or CV_32FC2 .</param>
            <param name="map2">The second input map of type CV_16UC1 , CV_32FC1 , or none (empty matrix), respectively.</param>
            <param name="dstmap1">The first output map that has the type dstmap1type and the same size as src .</param>
            <param name="dstmap2">The second output map.</param>
            <param name="dstmap1Depth">Depth type of the first output map that should be CV_16SC2 , CV_32FC1 , or CV_32FC2.</param>
            <param name="dstmap1Channels">The number of channels in the dst map.</param>
            <param name="nninterpolation">Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Undistort(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Transforms the image to compensate radial and tangential lens distortion. 
            </summary>
            <param name="src">The input (distorted) image</param>
            <param name="dst">The output (corrected) image</param>
            <param name="cameraMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].</param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2].</param>
            <param name="newCameraMatrix">Camera matrix of the distorted image. By default it is the same as cameraMatrix, but you may additionally scale and shift the result by using some different matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InitUndistortRectifyMap(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.DepthType,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            This function is an extended version of cvInitUndistortMap. That is, in addition to the correction of lens distortion, the function can also apply arbitrary perspective transformation R and finally it can scale and shift the image according to the new camera matrix
            </summary>
            <param name="cameraMatrix">The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="R">The rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used</param>
            <param name="newCameraMatrix">The new camera matrix A'=[fx' 0 cx'; 0 fy' cy'; 0 0 1]</param>
            <param name="depthType">Depth type of the first output map that can be CV_32FC1 or CV_16SC2 .</param>
            <param name="map1">The first output map.</param>
            <param name="map2">The second output map.</param>
            <param name="size">Undistorted image size.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.UndistortPoints(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Similar to cvInitUndistortRectifyMap and is opposite to it at the same time. 
            The functions are similar in that they both are used to correct lens distortion and to perform the optional perspective (rectification) transformation. 
            They are opposite because the function cvInitUndistortRectifyMap does actually perform the reverse transformation in order to initialize the maps properly, while this function does the forward transformation. 
            </summary>
            <param name="src">The observed point coordinates</param>
            <param name="dst">The ideal point coordinates, after undistortion and reverse perspective transformation. </param>
            <param name="cameraMatrix">The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1, 1x4, 5x1 or 1x5. </param>
            <param name="R">The rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used.</param>
            <param name="P">The new camera matrix (3x3) or the new projection matrix (3x4). P1 or P2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EMD(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DistType,Emgu.CV.IInputArray,System.Single[],Emgu.CV.IOutputArray)">
            <summary>
            Computes the 'minimal work' distance between two weighted point configurations.
            </summary>
            <param name="signature1">First signature, a size1 x dims + 1  floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used.</param>
            <param name="signature2">Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra 'dummy' point is added to either signature1 or signature2</param>
            <param name="distType"> Used metric. CV_DIST_L1, CV_DIST_L2 , and CV_DIST_C stand for one of the standard metrics. CV_DIST_USER means that a pre-calculated cost matrix cost is used.</param>
            <param name="cost">User-defined size1 x size2 cost matrix. Also, if a cost matrix is used, lower boundary lowerBound cannot be calculated because it needs a metric function.</param>
            <param name="lowerBound">Optional input/output parameter: lower boundary of a distance between the two signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). </param>
            <param name="flow"> Resultant size1 x size2 flow matrix</param>
            <returns>The 'minimal work' distance between two weighted point configurations.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PhaseCorrelate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double@)">
            <summary>
            The function is used to detect translational shifts that occur between two images. The operation takes advantage of the Fourier shift theorem for detecting the translational shift in the frequency domain. It can be used for fast image registration as well as motion estimation. 
            </summary>
            <param name="src1">Source floating point array (CV_32FC1 or CV_64FC1)</param>
            <param name="src2">Source floating point array (CV_32FC1 or CV_64FC1)</param>
            <param name="window">Floating point array with windowing coefficients to reduce edge effects (optional).</param>
            <param name="response">Signal power within the 5x5 centroid around the peak, between 0 and 1 </param>
            <returns>The translational shifts that occur between two images</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CreateHanningWindow(Emgu.CV.IOutputArray,System.Drawing.Size,Emgu.CV.CvEnum.DepthType)">
            <summary>
            This function computes a Hanning window coefficients in two dimensions.
            </summary>
            <param name="dst">Destination array to place Hann coefficients in</param>
            <param name="winSize">The window size specifications</param>
            <param name="type">Created array type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolveLP(Emgu.CV.Mat,Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method). 
            What we mean here by linear programming problem (or LP problem, for short) can be formulated as:
            Maximize c x subject to: Ax &lt;= b and x &gt;= 0 
            </summary>
            <param name="functionMatrix">This row-vector corresponds to c in the LP problem formulation (see above). It should contain 32- or 64-bit floating point numbers. As a convenience, column-vector may be also submitted, in the latter case it is understood to correspond to c^T.</param>
            <param name="constraintMatrix">m-by-n+1 matrix, whose rightmost column corresponds to b in formulation above and the remaining to A. It should containt 32- or 64-bit floating point numbers.</param>
            <param name="zMatrix">The solution will be returned here as a column-vector - it corresponds to c in the formulation above. It will contain 64-bit floating point numbers.</param>
            <returns>The return codes</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DenoiseTVL1(Emgu.CV.Mat[],Emgu.CV.Mat,System.Double,System.Int32)">
            <summary>
            Primal-dual algorithm is an algorithm for solving special types of variational problems (that is, finding a function to minimize some functional).
            As the image denoising, in particular, may be seen as the variational problem, primal-dual algorithm then can be used to perform 
            denoising and this is exactly what is implemented.
            </summary>
            <param name="observations">This array should contain one or more noised versions of the image that is to be restored.</param>
            <param name="result">Here the denoised image will be stored. There is no need to do pre-allocation of storage space, as it will be automatically allocated, if necessary.</param>
            <param name="lambda">Corresponds to  in the formulas above. As it is enlarged, the smooth (blurred) images are treated more favorably than detailed (but maybe more noised) ones. Roughly speaking, as it becomes smaller, the result will be more blur but more sever outliers will be removed.</param>
            <param name="niters">Number of iterations that the algorithm will run. Of course, as more iterations as better, but it is hard to quantitatively refine this statement, so just use the default and increase it if the results are poor.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Inpaint(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.InpaintType)">
            <summary>
            Reconstructs the selected image area from the pixel near the area boundary. The function may be used to remove dust and scratches from a scanned photo, or to remove undesirable objects from still images or video.
            </summary>
            <param name="src">The input 8-bit 1-channel or 3-channel image</param>
            <param name="mask">The inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="dst">The output image of the same format and the same size as input</param>
            <param name="flags">The inpainting method</param>
            <param name="inpaintRadius">The radius of circlular neighborhood of each point inpainted that is considered by the algorithm</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FastNlMeansDenoising(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Int32,System.Int32)">
            <summary>
            Perform image denoising using Non-local Means Denoising algorithm: 
            http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ 
            with several computational optimizations. Noise expected to be a gaussian white noise.
            </summary>
            <param name="src">Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FastNlMeansDenoisingColored(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Perform image denoising using Non-local Means Denoising algorithm (modified for color image): 
            http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ 
            with several computational optimizations. Noise expected to be a gaussian white noise.
            The function converts image to CIELAB colorspace and then separately denoise L and AB components with given h parameters using fastNlMeansDenoising function.
            </summary>
            <param name="src">Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="hColor">The same as h but for color components. For most images value equals 10 will be enought to remove colored noise and do not distort colors.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EdgePreservingFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.EdgePreservingFilterFlag,System.Single,System.Single)">
            <summary>
            Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing filters are used in many different applications.
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst">Output 8-bit 3-channel image</param>
            <param name="flags">Edge preserving filters</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DetailEnhance(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            This filter enhances the details of a particular image.
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst">Output image with the same size and type as src</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PencilSketch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Pencil-like non-photorealistic line drawing
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst1">Output 8-bit 1-channel image</param>
            <param name="dst2">Output image with the same size and type as src</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
            <param name="shadeFactor">Range between 0 to 0.1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Stylization(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            Stylization aims to produce digital imagery with a wide variety of effects not focused on photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low contrast while preserving, or enhancing, high-contrast features.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR"> Range between 0 to 1.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ColorChange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Given an original color image, two differently colored versions of this image can be mixed seamlessly.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src .</param>
            <param name="redMul">R-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
            <param name="greenMul">G-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
            <param name="blueMul">B-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.IlluminationChange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            Applying an appropriate non-linear transformation to the gradient field inside the selection and then integrating back with a Poisson solver, modifies locally the apparent illumination of an image.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="alpha">Value ranges between 0-2.</param>
            <param name="beta">Value ranges between 0-2.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.TextureFlattening(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32)">
            <summary>
            By retaining only the gradients at edge locations, before integrating with the Poisson solver, one washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge Detector is used.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="lowThreshold">Range from 0 to 100.</param>
            <param name="highThreshold">Value &gt; 100</param>
            <param name="kernelSize">The size of the Sobel kernel to be used.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CamShift(Emgu.CV.IInputArray,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Implements CAMSHIFT object tracking algorithm ([Bradski98]). First, it finds an object center using cvMeanShift and, after that, calculates the object size and orientation. 
            </summary>
            <param name="probImage">Back projection of object histogram </param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished</param>
            <returns>Circumscribed box for the object, contains object size and orientation</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanShift(Emgu.CV.IInputArray,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the object center given its back projection and initial position of search window. The iterations are made until the search window center moves by less than the given value and/or until the function has done the maximum number of iterations. 
            </summary>
            <param name="probImage">Back projection of object histogram</param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished. </param>
            <returns>The number of iterations made</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.UpdateMotionHistory(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,System.Double)">
            <summary>
            Updates the motion history image as following:
            mhi(x,y)=timestamp  if silhouette(x,y)!=0
                    0          if silhouette(x,y)=0 and mhi(x,y)&lt;timestamp-duration
                    mhi(x,y)   otherwise
            That is, MHI pixels where motion occurs are set to the current timestamp, while the pixels where motion happened far ago are cleared. 
            </summary>
            <param name="silhouette">Silhouette mask that has non-zero pixels where the motion occurs. </param>
            <param name="mhi">Motion history image, that is updated by the function (single-channel, 32-bit floating-point) </param>
            <param name="timestamp">Current time in milliseconds or other units. </param>
            <param name="duration">Maximal duration of motion track in the same units as timestamp. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcMotionGradient(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32)">
             <summary>
             Calculates the derivatives Dx and Dy of mhi and then calculates gradient orientation as:
            orientation(x,y)=arctan(Dy(x,y)/Dx(x,y))
            where both Dx(x,y)' and Dy(x,y)' signs are taken into account (as in cvCartToPolar function). After that mask is filled to indicate where the orientation is valid (see delta1 and delta2 description). 
             </summary>
             <param name="mhi">Motion history image</param>
             <param name="mask">Mask image; marks pixels where motion gradient data is correct. Output parameter.</param>
             <param name="orientation">Motion gradient orientation image; contains angles from 0 to ~360. </param>
             <param name="delta1">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2). </param>
             <param name="delta2">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2).</param>
             <param name="apertureSize">Aperture size of derivative operators used by the function: CV_SCHARR, 1, 3, 5 or 7 (see cvSobel). </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SegmentMotion(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Util.VectorOfRect,System.Double,System.Double)">
            <summary>
            Finds all the motion segments and marks them in segMask with individual values each (1,2,...). It also returns a sequence of CvConnectedComp structures, one per each motion components. After than the motion direction for every component can be calculated with cvCalcGlobalOrientation using extracted mask of the particular component (using cvCmp) 
            </summary>
            <param name="mhi">Motion history image</param>
            <param name="segMask">Image where the mask found should be stored, single-channel, 32-bit floating-point</param>
            <param name="timestamp">Current time in milliseconds or other units</param>
            <param name="segThresh">Segmentation threshold; recommended to be equal to the interval between motion history "steps" or greater</param>
            <param name="boundingRects">Vector containing ROIs of motion connected components.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcGlobalOrientation(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,System.Double)">
            <summary>
            Calculates the general motion direction in the selected region and returns the angle between 0 and 360. At first the function builds the orientation histogram and finds the basic orientation as a coordinate of the histogram maximum. After that the function calculates the shift relative to the basic orientation as a weighted sum of all orientation vectors: the more recent is the motion, the greater is the weight. The resultant angle is a circular sum of the basic orientation and the shift. 
            </summary>
            <param name="orientation">Motion gradient orientation image; calculated by the function cvCalcMotionGradient.</param>
            <param name="mask">Mask image. It may be a conjunction of valid gradient mask, obtained with cvCalcMotionGradient and mask of the region, whose direction needs to be calculated. </param>
            <param name="mhi">Motion history image.</param>
            <param name="timestamp">Current time in milliseconds or other units, it is better to store time passed to cvUpdateMotionHistory before and reuse it here, because running cvUpdateMotionHistory and cvCalcMotionGradient on large images may take some time.</param>
            <param name="duration">Maximal duration of motion track in milliseconds, the same as in cvUpdateMotionHistory</param>
            <returns>The angle</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateKalman(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocates CvKalman and all its matrices and initializes them somehow. 
            </summary>
            <param name="dynamParams">dimensionality of the state vector</param>
            <param name="measureParams">dimensionality of the measurement vector </param>
            <param name="controlParams">dimensionality of the control vector </param>
            <returns>Pointer to the created Kalman filter</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKalmanCorrect(System.IntPtr,System.IntPtr)">
            <summary>
            Adjusts stochastic model state on the basis of the given measurement of the model state.
            The function stores adjusted state at kalman->state_post and returns it on output
            </summary>
            <param name="kalman">Pointer to the structure to be updated</param>
            <param name="measurement">Pointer to the structure CvMat containing the measurement vector</param>
            <returns>The function stores adjusted state at kalman->state_post and returns it on output</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKalmanCorrect(Emgu.CV.Structure.MCvKalman@,System.IntPtr)">
            <summary>
            Adjusts stochastic model state on the basis of the given measurement of the model state.
            The function stores adjusted state at kalman->state_post and returns it on output
            </summary>
            <param name="kalman">Pointer to the structure to be updated</param>
            <param name="measurement">Pointer to the structure CvMat containing the measurement vector</param>
            <returns>The function stores adjusted state at kalman->state_post and returns it on output</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKalmanPredict(System.IntPtr,System.IntPtr)">
            <summary>
            Estimates the subsequent stochastic model state by its current state and stores it at kalman->state_pre
            The function returns the estimated state
            </summary>
            <param name="kalman">Kalman filter state</param>
            <param name="control">Control vector (uk), should be NULL iff there is no external control (controlParams=0). </param>
            <returns>the estimated state</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKalmanPredict(Emgu.CV.Structure.MCvKalman@,System.IntPtr)">
            <summary>
            Estimates the subsequent stochastic model state by its current state and stores it at kalman->state_pre
            The function returns the estimated state
            </summary>
            <param name="kalman">Kalman filter state</param>
            <param name="control">Control vector (uk), should be NULL iff there is no external control (controlParams=0). </param>
            <returns>the estimated state</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseKalman(System.IntPtr@)">
            <summary>
            Releases the structure CvKalman and all underlying matrices
            </summary>
            <param name="kalman">reference of the pointer to the Kalman filter structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowPyrLK(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.PointF[],System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,System.Drawing.PointF[]@,System.Byte[]@,System.Single[]@,Emgu.CV.CvEnum.LKFlowFlag,System.Double)">
            <summary>
            Calculates optical flow for a sparse feature set using iterative Lucas-Kanade method in pyramids
            </summary>
            <param name="prev">First frame, at time t</param>
            <param name="curr">Second frame, at time t + dt </param>
            <param name="prevFeatures">Array of points for which the flow needs to be found</param>
            <param name="winSize">Size of the search window of each pyramid level</param>
            <param name="level">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc</param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped</param>
            <param name="flags">Flags</param>
            <param name="currFeatures">Array of 2D points containing calculated new positions of input features in the second image</param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise</param>
            <param name="trackError">Array of double numbers containing difference between patches around the original and moved points</param>
            <param name="minEigThreshold">the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in [Bouguet00]), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowPyrLK(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.CvEnum.LKFlowFlag,System.Double)">
            <summary>
            Implements sparse iterative version of Lucas-Kanade optical flow in pyramids ([Bouguet00]). It calculates coordinates of the feature points on the current video frame given their coordinates on the previous frame. The function finds the coordinates with sub-pixel accuracy. 
            </summary>
            <remarks>Both parameters prev_pyr and curr_pyr comply with the following rules: if the image pointer is 0, the function allocates the buffer internally, calculates the pyramid, and releases the buffer after processing. Otherwise, the function calculates the pyramid and stores it in the buffer unless the flag CV_LKFLOW_PYR_A[B]_READY is set. The image should be large enough to fit the Gaussian pyramid data. After the function call both pyramids are calculated and the readiness flag for the corresponding image can be set in the next call (i.e., typically, for all the image pairs except the very first one CV_LKFLOW_PYR_A_READY is set). </remarks>
            <param name="prevImg">First frame, at time t. </param>
            <param name="nextImg">Second frame, at time t + dt .</param>
            <param name="prevPts">Array of points for which the flow needs to be found. </param>
            <param name="nextPts">Array of 2D points containing calculated new positions of input </param>
            <param name="winSize">Size of the search window of each pyramid level.</param>
            <param name="maxLevel">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc. </param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise.</param>
            <param name="err">Array of double numbers containing difference between patches around the original and moved points. Optional parameter; can be NULL </param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped.</param>
            <param name="flags">Miscellaneous flags</param>
            <param name="minEigThreshold">the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in [Bouguet00]), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowFarneback(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OpticalflowFarnebackFlag)">
            <summary>
            Computes dense optical flow using Gunnar Farneback's algorithm
            </summary>
            <param name="prev0">The first 8-bit single-channel input image</param>
            <param name="next0">The second input image of the same size and the same type as prevImg</param>
            <param name="flowX">The computed flow image for x-velocity; will have the same size as prevImg</param>
            <param name="flowY">The computed flow image for y-velocity; will have the same size as prevImg</param>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="levels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="iterations">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowFarneback(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OpticalflowFarnebackFlag)">
            <summary>
            Computes dense optical flow using Gunnar Farneback's algorithm
            </summary>
            <param name="prev0">The first 8-bit single-channel input image</param>
            <param name="next0">The second input image of the same size and the same type as prevImg</param>
            <param name="flow">The computed flow image; will have the same size as prevImg and type CV 32FC2</param>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="levels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="iterations">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateRigidTransform(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Estimate rigid transformation between 2 images or 2 point sets.
            </summary>
            <param name="src">First image or 2D point set (as a 2 channel Matrix&lt;float&gt;)</param>
            <param name="dst">First image or 2D point set (as a 2 channel Matrix&lt;float&gt;)</param>
            <param name="fullAffine">Indicates if full affine should be performed</param>
            <returns>The resulting Matrix&lt;double&gt; that represent the affine transformation</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveInputArrayRelease(System.IntPtr@)">
            <summary>
            Release the InputArray
            </summary>
            <param name="arr">Pointer to the input array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveInputOutputArrayRelease(System.IntPtr@)">
            <summary>
            Release the input / output array
            </summary>
            <param name="arr">Pointer to the input output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveOutputArrayRelease(System.IntPtr@)">
            <summary>
            Release the input / output array
            </summary>
            <param name="arr">Pointer to the input / output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterCreate(System.IntPtr,System.Int32,System.Double,System.Drawing.Size@,System.Boolean)">
            <summary>
            Creates video writer structure.
            </summary>
            <param name="filename">Name of the output video file.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.</param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames.</param>
            <param name="isColor">If != 0, the encoder will expect and encode color frames, otherwise it will work with grayscale frames </param>
            <returns>The video writer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterRelease(System.IntPtr@)">
            <summary>
            Finishes writing to video file and releases the structure.
            </summary>
            <param name="writer">pointer to video file writer structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterWrite(System.IntPtr,System.IntPtr)">
            <summary>
            Writes/appends one frame to video file.
            </summary>
            <param name="writer">video writer structure.</param>
            <param name="image">the written frame</param>
            <returns>True on success, false otherwise</returns>
        </member>
        <member name="P:Emgu.CV.CvInvoke.HaveOpenCL">
            <summary>
            Check if we have OpenCL
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.UseOpenCL">
            <summary>
            Get or set if OpenCL should be used
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.HaveOpenCLCompatibleGpuDevice">
            <summary>
            Gets a value indicating whether this device have open CL compatible gpu device.
            </summary>
            <value><c>true</c> if have open CL compatible gpu device; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Emgu.CV.CvInvoke.CvErrorCallback">
            <summary>
            Define an error callback that can be registered using cvRedirectError function
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.CameraCalibration">
            <summary>
            Camera calibration functions
            </summary>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.CalibrateCamera(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.Size,Emgu.CV.IntrinsicCameraParameters,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.ExtrinsicCameraParameters[]@)">
            <summary>
            Estimates intrinsic camera parameters and extrinsic parameters for each of the views
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints">The 2D image location of the points. The first index is the index of the image, second index is the index of the point</param>
            <param name="imageSize">The size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="intrinsicParam">The intrisinc parameters, might contains some initial values. The values will be modified by this function.</param>
            <param name="calibrationType">cCalibration type</param>
            <param name="termCriteria">The termination criteria</param>
            <param name="extrinsicParams">The output array of extrinsic parameters.</param>
            <returns>The final reprojection error</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.StereoCalibrate(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.PointF[][],Emgu.CV.IntrinsicCameraParameters,Emgu.CV.IntrinsicCameraParameters,System.Drawing.Size,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.ExtrinsicCameraParameters@,Emgu.CV.Matrix{System.Double}@,Emgu.CV.Matrix{System.Double}@)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints1">The 2D image location of the points for camera 1. The first index is the index of the image, second index is the index of the point</param>
            <param name="imagePoints2">The 2D image location of the points for camera 2. The first index is the index of the image, second index is the index of the point</param>
            <param name="intrinsicParam1">The intrisinc parameters for camera 1, might contains some initial values. The values will be modified by this function.</param>
            <param name="intrinsicParam2">The intrisinc parameters for camera 2, might contains some initial values. The values will be modified by this function.</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="flags">Different flags</param>
            <param name="extrinsicParams">The extrinsic parameters which contains:
            R - The rotation matrix between the 1st and the 2nd cameras' coordinate systems; 
            T - The translation vector between the cameras' coordinate systems. </param>
            <param name="essentialMatrix">The essential matrix</param>
            <param name="termCrit">Termination criteria for the iterative optimiziation algorithm </param>
            <param name="foundamentalMatrix">The fundamental matrix</param>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.SolvePnP(Emgu.CV.Structure.MCvPoint3D32f[],System.Drawing.PointF[],Emgu.CV.IntrinsicCameraParameters,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error. 
            </summary>
            <param name="objectPoints">The array of object points</param>
            <param name="imagePoints">The array of corresponding image points</param>
            <param name="intrin">The intrinsic parameters</param>
            <param name="method">Method for solving a PnP problem</param>
            <returns>The extrinsic parameters</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.ProjectPoints(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.ExtrinsicCameraParameters,Emgu.CV.IntrinsicCameraParameters,Emgu.CV.Matrix{System.Single}[])">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. 
            Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. 
            The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. 
            The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters. 
            </summary>
            <remarks>Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points) </remarks>
            <param name="objectPoints">The array of object points.</param>
            <param name="extrin">Extrinsic parameters</param>
            <param name="intrin">Intrinsic parameters</param>
            <param name="mats">Optional matrix supplied in the following order: dpdrot, dpdt, dpdf, dpdc, dpddist</param>
            <returns>The array of image points which is the projection of <paramref name="objectPoints"/></returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.FindHomography(System.Drawing.PointF[],System.Drawing.PointF[],Emgu.CV.CvEnum.HomographyMethod,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Finds perspective transformation H=||h_ij|| between the source and the destination planes
            </summary>
            <param name="srcPoints">Point coordinates in the original plane</param>
            <param name="dstPoints">Point coordinates in the destination plane</param>
            <param name="method">FindHomography method</param>
            <param name="ransacReprojThreshold">
            The maximum allowed reprojection error to treat a point pair as an inlier. 
            The parameter is only used in RANSAC-based homography estimation. 
            E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3
            </param>
            <param name="mask">Optional output mask set by a robust method ( CV_RANSAC or CV_LMEDS ). Note that the input mask values are ignored.</param>
            <returns>The 3x3 homography matrix if found. Null if not found.</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.GetAffineTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Coordinates of 3 triangle vertices in the source image. If the array contains more than 3 points, only the first 3 will be used</param>
            <param name="dest">Coordinates of the 3 corresponding triangle vertices in the destination image. If the array contains more than 3 points, only the first 3 will be used</param>
            <returns>The 2x3 rotation matrix that defines the Affine transform</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.EstimateRigidTransform(System.Drawing.PointF[],System.Drawing.PointF[],System.Boolean)">
            <summary>
            Estimate rigid transformation between 2 point sets.
            </summary>
            <param name="sourcePoints">The points from the source image</param>
            <param name="destinationPoints">The corresponding points from the destination image</param>
            <param name="fullAffine">Indicates if full affine should be performed</param>
            <returns>If success, the 2x3 rotation matrix that defines the Affine transform. Otherwise null is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.GetPerspectiveTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dest">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <returns>The 3x3 Homography matrix</returns>
        </member>
        <member name="T:Emgu.CV.ExtrinsicCameraParameters">
            <summary>
            Extrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.#ctor">
            <summary>
            Create the extrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.#ctor(Emgu.CV.RotationVector3D,Emgu.CV.Matrix{System.Double})">
            <summary>
            Create the extrinsic camera parameters using the specific rotation and translation matrix
            </summary>
            <param name="rotation">The rotation vector</param>
            <param name="translation">The translation vector</param>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.Equals(Emgu.CV.ExtrinsicCameraParameters)">
            <summary>
            Return true if the two extrinsic camera parameters are equal
            </summary>
            <param name="other">The other extrinsic camera parameters to compare with</param>
            <returns>True if the two extrinsic camera parameters are equal</returns>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.RotationVector">
            <summary>
            Get or Set the rodrigus rotation vector
            </summary>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.TranslationVector">
            <summary>
            Get or Set the translation vector ( as 3 x 1 matrix)
            </summary>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.ExtrinsicMatrix">
            <summary>
            Get the 3 x 4 extrinsic matrix: [[r11 r12 r13 t1] [r21 r22 r23 t2] [r31 r32 r33 t2]]
            </summary>
        </member>
        <member name="T:Emgu.CV.HomographyMatrix">
            <summary>
            A 3x3 homography matrix. This matrix defines an perspective transform
            </summary>
        </member>
        <member name="T:Emgu.CV.Matrix`1">
            <summary> 
            A Matrix is a wrapper to cvMat of OpenCV. 
            </summary>
            <typeparam name="TDepth">Depth of this matrix (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="T:Emgu.CV.CvArray`1">
            <summary>
            Wrapped CvArr 
            </summary>
            <typeparam name="TDepth">The type of elements in this CvArray</typeparam> 
        </member>
        <member name="T:Emgu.CV.IInputOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for input/output function parameters.
            </summary>
        </member>
        <member name="T:Emgu.CV.IInputArray">
            <summary>
            This is the proxy class for passing read-only input arrays into OpenCV functions.
            </summary>
        </member>
        <member name="M:Emgu.CV.IInputArray.GetInputArray">
            <summary>
            The unmanaged pointer to the input array.
            </summary>
        </member>
        <member name="T:Emgu.CV.IOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for output function parameters.
            </summary>
        </member>
        <member name="M:Emgu.CV.IOutputArray.GetOutputArray">
            <summary>
            The unmanaged pointer to the output array
            </summary>
        </member>
        <member name="T:Emgu.CV.IInputArrayOfArrays">
            <summary>
            InputArrayOfArrays
            </summary>
        </member>
        <member name="M:Emgu.CV.IInputOutputArray.GetInputOutputArray">
            <summary>
            The unmanaged pointer to the input/output array
            </summary>
        </member>
        <member name="F:Emgu.CV.CvArray`1._sizeOfElement">
            <summary>
            The size of the elements in the CvArray, it is the cached value of Marshal.SizeOf(typeof(TDepth)).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvArray`1._dataHandle">
            <summary>
            The pinned GCHandle to _array;
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels of this cvArray</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DotProduct(Emgu.CV.CvArray{`0})">
            <summary>
            Calculates and returns the Euclidean dot product of two arrays.
            src1 dot src2 = sumI(src1(I)*src2(I))
            </summary>
            <remarks>In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||^2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.</remarks>
            <param name="otherArray">The other Array to apply dot product with</param>
            <returns>src1 dot src2</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.CheckRange(System.Double,System.Double,System.Drawing.Point@)">
            <summary>
            Check that every array element is neither NaN nor +- inf. The functions also check that each value
            is between <paramref name="min"/> and <paramref name="max"/>. in the case of multi-channel arrays each channel is processed
            independently. If some values are out of range, position of the first outlier is stored in pos, 
            and then the functions return false.
            </summary>
            <param name="min">The inclusive lower boundary of valid values range</param>
            <param name="max">The exclusive upper boundary of valid values range</param>
            <param name="position">This will be filled with the position of the first outlier</param>
            <returns>True if all values are in range</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Reduce``1(Emgu.CV.CvArray{``0},Emgu.CV.CvEnum.ReduceDimension,Emgu.CV.CvEnum.ReduceType)">
            <summary>
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <remarks>
            The function can be used to compute horizontal and vertical projections of an raster image. 
            In case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element bit-depth to preserve accuracy. 
            And multi-channel arrays are also supported in these two reduction modes
            </remarks>
            <param name="array1D">The destination single-row/single-column vector that accumulates somehow all the matrix rows/columns</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="type">The reduction operation type</param>
            <typeparam name="TOtherDepth">The type of depth of the reduced array</typeparam>
        </member>
        <member name="M:Emgu.CV.CvArray`1.CopyTo(Emgu.CV.CvArray{`0})">
            <summary>
             Copy the current array to <paramref name="destination"/>
             </summary>
             <param name="destination"> The destination Array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(Emgu.CV.Structure.MCvScalar,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="value"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="value">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(System.Double,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="value"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="value">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandUniform(System.UInt64,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="seed">Seed for the random number generator</param>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandUniform(Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandNormal(System.UInt64,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="seed">Seed for the random number generator</param>
            <param name="mean">the mean value of random numbers</param>
            <param name="std"> the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandNormal(Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="mean">the mean value of random numbers</param>
            <param name="std"> the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetIdentity(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Initializs scaled identity matrix
            </summary>
            <param name="value">The value on the diagonal</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetZero">
            <summary>
            Set the values to zero
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetIdentity">
            <summary>
            Initialize the identity matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(System.Double)">
            <summary>
            Inplace multiply elements of the Array by <paramref name="scale"/>
            </summary>
            <param name="scale">The scale to be multiplyed</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise multiply the current Array with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to be elementwise multiplied with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DisposeObject">
            <summary>
            Free the _dataHandle if it is set
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(System.Double)">
            <summary>
            Inplace compute the elementwise minimum value 
            </summary>
            <param name="value">The value to compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise minimize the current Array with <paramref name="other"/>
            </summary>
            <param name="other">The other array to be elementwise minimized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(System.Double)">
            <summary>
            Inplace compute the elementwise maximum value with <paramref name="value"/>
            </summary>
            <param name="value">The value to be compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise maximize the current Array with <paramref name="other"/>
            </summary>
            <param name="other">The other array to be elementwise maximized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._And(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace And operation with <paramref name="otherArray"/>
            </summary>
            <param name="otherArray">The other array to perform AND operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Or(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace Or operation with <paramref name="otherArray"/>
            </summary>
            <param name="otherArray">The other array to perform OR operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Not">
            <summary> 
            Inplace compute the complement for all array elements
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Save(System.String)">
            <summary>
            Save the CvArray as image
            </summary>
            <param name="fileName">The name of the image to save</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetSchema">
            <summary>
            Get the xml schema
            </summary>
            <returns>the xml schema</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Function to call when deserializing this object from XML
            </summary>
            <param name="reader">The xml reader</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Function to call when serializing this object to XML 
            </summary>
            <param name="writer">The xml writer</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="F:Emgu.CV.CvArray`1._cvMat">
            <summary>
            The Mat header that represent this CvArr
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetInputArray">
            <summary>
            The unmanaged pointer to the input array.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetOutputArray">
            <summary>
            The unmanaged pointer to the output array.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetInputOutputArray">
            <summary>
            The unmanaged pointer to the input output array.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.ToUMat">
            <summary>
            Get the umat representation of this mat
            </summary>
            <returns>The UMat</returns>
        </member>
        <member name="P:Emgu.CV.CvArray`1.SerializationCompressionRatio">
            <summary>
            Get or set the Compression Ratio for serialization. A number between 0 - 9. 
            0 means no compression at all, while 9 means best compression
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.SizeOfElement">
            <summary>
            Get the size of element in bytes
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Ptr">
            <summary> The pointer to the internal structure </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Size">
            <summary> 
             Get the size of the array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Width">
            <summary> 
            Get the width (#Cols) of the cvArray.
            If ROI is set, the width of the ROI 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Height">
            <summary> 
            Get the height (#Rows) of the cvArray.
            If ROI is set, the height of the ROI 
            </summary> 
        </member>
        <member name="P:Emgu.CV.CvArray`1.NumberOfChannels">
            <summary>
            Get the number of channels of the array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Rows">
            <summary>
            The number of rows for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Cols">
            <summary>
            The number of cols for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Bytes">
            <summary>
            Get or Set an Array of bytes that represent the data in this array
            </summary>
            <remarks> Should only be used for serialization &amp; deserialization</remarks>
        </member>
        <member name="P:Emgu.CV.CvArray`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Trace">
            <summary>
            Sum of diagonal elements of the matrix 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Norm">
            <summary> 
            The norm of this Array 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Mat">
            <summary>
            Get the Mat header that represent this CvArr
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor">
            <summary>
            The default constructor which allows Data to be set later on
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <param name="step">The step (row stride in bytes)</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="channels">The number of channels</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <param name="step">The step (row stride in bytes)</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="rows">The number of rows (<b>height</b>)</param>
            <param name="cols">The number of cols (<b>width</b>)</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Drawing.Size)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="size">The size of the matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size and channels
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="channels">The number of channels</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[0:,0:])">
            <summary> 
            Create a matrix using the specific <paramref>data</paramref>
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[])">
            <summary>
            Create a matrix using the specific <paramref name="data"/>
            </summary>
            <param name="data">the data for this matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.CopyBlank">
            <summary>
            Return a matrix of the same size with all elements equals 0
            </summary>
            <returns>A matrix of the same size with all elements equals 0</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Clone">
            <summary>
            Make a copy of this matrix
            </summary>
            <returns>A copy if this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Reshape(System.Int32,System.Int32)">
            <summary>
            Get reshaped matrix which also share the same data with the current matrix
            </summary>
            <param name="newChannels">the new number of channles</param>
            <param name="newRows">The new number of rows</param>
            <returns>A reshaped matrix which also share the same data with the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Convert``1">
            <summary>
            Convert this matrix to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <returns>Matrix of different depth</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Transpose">
            <summary> Returns the transpose of this matrix</summary>
            <returns>The transpose of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels for this matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Get a submatrix corresponding to a specified rectangle
            </summary>
            <param name="rect">the rectangle area of the sub-matrix</param>
            <returns>A submatrix corresponding to a specified rectangle</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetRow(System.Int32)">
            <summary>
            Get the specific row of the matrix
            </summary>
            <param name="row">the index of the row to be reterived</param>
            <returns>the specific row of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetRows(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the matrix corresponding to a specified row span of the input array
            </summary>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <param name="deltaRow">Index step in the row span. That is, the function extracts every delta_row-th row from start_row and up to (but not including) end_row</param>
            <returns>A matrix corresponding to a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetCol(System.Int32)">
            <summary>
            Get the specific column of the matrix
            </summary>
            <param name="col">the index of the column to be reterived</param>
            <returns>the specific column of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetCols(System.Int32,System.Int32)">
            <summary>
            Get the Matrix, corresponding to a specified column span of the input array
            </summary>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <param name="startCol">Zero-based index of the selected column</param>
            <returns>the specific column span of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetDiag(System.Int32)">
            <summary>
            Return the specific diagonal elements of this matrix
            </summary>
            <param name="diag">Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above the main etc., 1 corresponds to the diagonal below the main etc</param>
            <returns>The specific diagonal elements of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetDiag">
            <summary>
            Return the main diagonal element of this matrix
            </summary>
            <returns>The main diagonal element of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.RemoveRows(System.Int32,System.Int32)">
            <summary>
            Return the matrix without a specified row span of the input array
            </summary>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <returns>The matrix without a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.RemoveCols(System.Int32,System.Int32)">
            <summary>
            Return the matrix without a specified column span of the input array
            </summary>
            <param name="startCol">Zero-based index of the starting column (inclusive) of the span</param>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <returns>The matrix without a specified column span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.ConcateVertical(Emgu.CV.Matrix{`0})">
            <summary>
            Concate the current matrix with another matrix vertically. If this matrix is n1 x m and <paramref name="otherMatrix"/> is n2 x m, the resulting matrix is (n1+n2) x m.
            </summary>
            <param name="otherMatrix">The other matrix to concate</param>
            <returns>A new matrix that is the vertical concatening of this matrix and <paramref name="otherMatrix"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.ConcateHorizontal(Emgu.CV.Matrix{`0})">
            <summary>
            Concate the current matrix with another matrix horizontally. If this matrix is n x m1 and <paramref name="otherMatrix"/> is n x m2, the resulting matrix is n x (m1 + m2).
            </summary>
            <param name="otherMatrix">The other matrix to concate</param>
            <returns>A matrix that is the horizontal concatening of this matrix and <paramref name="otherMatrix"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.MinMax(System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,Emgu.CV.IInputArray)">
            <summary>
            Returns the min / max locations and values for the matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Add(Emgu.CV.Matrix{`0})">
            <summary> Elementwise add another matrix with the current matrix </summary>
            <param name="mat2">The matrix to be added to the current matrix</param>
            <returns> The result of elementwise adding mat2 to the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current matrix</summary>
            <param name="val">The value to be added to the current matrix</param>
            <returns> The result of elementwise adding <paramref name="val"/> from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Sub(Emgu.CV.Matrix{`0})">
            <summary> Elementwise subtract another matrix from the current matrix </summary>
            <param name="mat2"> The matrix to be subtracted to the current matrix</param>
            <returns> The result of elementwise subtracting mat2 from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Sub(`0)">
            <summary> Elementwise subtract a color <paramref name="val"/> to the current matrix</summary>
            <param name="val"> The value to be subtracted from the current matrix</param>
            <returns> The result of elementwise subtracting <paramref name="val"/> from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">The value which subtract this matrix</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Mul(System.Double)">
            <summary> Multiply the current matrix with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled matrix </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Mul(Emgu.CV.Matrix{`0})">
            <summary> Multiply the current matrix with <paramref name="mat2"/></summary>
            <param name="mat2">The matrix to be multiplied</param>
            <returns> Result matrix of the multiplication </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            Elementwise add <paramref name="mat1"/> with <paramref name="mat2"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="mat2">The Matrix to be added</param>
            <returns>The elementwise sum of the two matrices</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            Elementwise add <paramref name="mat1"/> with <paramref name="val"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="val">The value to be added</param>
            <returns>The matrix plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="val"/> + <paramref name="mat1"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="val">The value to be added</param>
            <returns>The matrix plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="val"/> - <paramref name="mat1"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="val">The value to be subtracted</param>
            <returns><paramref name="val"/> - <paramref name="mat1"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="mat1"/> - <paramref name="mat2"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="mat2">The matrix to subtract</param>
            <returns><paramref name="mat1"/> - <paramref name="mat2"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> - <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="val">The value to be subtracted</param>
            <returns><paramref name="mat1"/> - <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> * <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be multiplied</param>
            <param name="val">The value to be multiplied</param>
            <returns><paramref name="mat1"/> * <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
             <paramref name="val"/> * <paramref name="mat1"/> 
            </summary>
            <param name="mat1">The matrix to be multiplied</param>
            <param name="val">The value to be multiplied</param>
            <returns> <paramref name="val"/> * <paramref name="mat1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Division(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> / <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be divided</param>
            <param name="val">The value to be divided</param>
            <returns><paramref name="mat1"/> / <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="mat1"/> * <paramref name="mat2"/> 
            </summary>
            <param name="mat1">The Matrix to be multiplied</param>
            <param name="mat2">The Matrix to be multiplied</param>
            <returns><paramref name="mat1"/> * <paramref name="mat2"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.DisposeObject">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Cmp(Emgu.CV.Matrix{`0},Emgu.CV.CvEnum.CmpType)">
            <summary>
            This function compare the current matrix with <paramref name="mat2"/> and returns the comparison mask
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <param name="type">Comparison type</param>
            <returns>The comparison mask</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Split">
            <summary>
            Get all channels for the multi channel matrix
            </summary>
            <returns>Each individual channel of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Equals(Emgu.CV.Matrix{`0})">
            <summary>
            Return true if every element of this matrix equals elements in <paramref name="mat2"/>
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <returns>true if every element of this matrix equals elements in <paramref name="mat2"/></returns>
        </member>
        <member name="P:Emgu.CV.Matrix`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Data">
            <summary>
            Get or Set the data for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.NumberOfChannels">
            <summary>
            Get the number of channels for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.MCvMat">
            <summary>
            The MCvMat structure format  
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Det">
            <summary>
            Returns determinant of the square matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Sum">
            <summary>
            Return the sum of the elements in this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns>The element on the specific <paramref name="row"/> and <paramref name="col"/></returns>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Size">
            <summary> 
             Get the size of the array
            </summary>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize homography matrix
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.#ctor">
            <summary>
            Create an empty homography matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.IsValid(System.Double)">
            <summary>
            Check if the homography matrix is valid.
            </summary>
            <param name="thresholdForDeterminant">A number &gt; 1. A good number will be 10. If the deteminate of the homography matrix is in the range of [1/threshold, threshold], true is returned</param>
            <returns>True, if the deteminate of the homography matrix is in the range of [1/threshold, threshold]</returns>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.ProjectPoints(System.Drawing.PointF[])">
            <summary>
            Get the homography projection of the points. The projected value will be saved to the input point array
            </summary>
            <param name="points">The points to apply homography transform</param>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.Clone">
            <summary>
            Return a clone of the Matrix
            </summary>
            <returns>A clone of the Matrix</returns>
        </member>
        <member name="T:Emgu.CV.IntrinsicCameraParameters">
            <summary>
            Intrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.#ctor">
            <summary>
            Create the intrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.#ctor(System.Int32)">
            <summary>
            Create the intrinsic camera parameters 
            </summary>
            <param name="distortionCoeffsCount">The number of distortion coefficients. Should be either 4, 5 or 8.</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.InitUndistortMap(System.Int32,System.Int32,Emgu.CV.Matrix{System.Single}@,Emgu.CV.Matrix{System.Single}@)">
            <summary>
            Pre-computes the undistortion map - coordinates of the corresponding pixel in the distorted image for every pixel in the corrected image. Then, the map (together with input and output images) can be passed to cvRemap function.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="mapx">The output array of x-coordinates of the map</param>
            <param name="mapy">The output array of y-coordinates of the map</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.GetIntrinsicMatrixValues(System.Int32,System.Int32,System.Double,System.Double,System.Double@,System.Double@,System.Double@,Emgu.CV.Structure.MCvPoint2D64f@,System.Double@)">
            <summary>
            computes various useful camera (sensor/lens) characteristics using the computed camera calibration matrix, image frame resolution in pixels and the physical aperture size
            </summary>
            <param name="imgWidth">Image width in pixels</param>
            <param name="imgHeight">Image height in pixels</param>
            <param name="apertureWidth">Aperture width in realworld units (optional input parameter). Set it to 0 if not used</param>
            <param name="apertureHeight">Aperture width in realworld units (optional input parameter). Set it to 0 if not used</param>
            <param name="fovx">Field of view angle in x direction in degrees</param>
            <param name="fovy">Field of view angle in y direction in degrees </param>
            <param name="focalLength">Focal length in realworld units </param>
            <param name="principalPoint">The principal point in realworld units </param>
            <param name="pixelAspectRatio">The pixel aspect ratio ~ fy/f</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Undistort(System.Drawing.PointF[],Emgu.CV.Matrix{System.Double},Emgu.CV.Matrix{System.Double})">
            <summary>
            Similar to cvInitUndistortRectifyMap and is opposite to it at the same time.
            The functions are similar in that they both are used to correct lens distortion and to perform the optional perspective (rectification) transformation.
            They are opposite because the function cvInitUndistortRectifyMap does actually perform the reverse transformation in order to initialize the maps properly, while this function does the forward transformation.
            </summary>
            <param name="src">The observed point coordinates</param>
            <param name="R">Optional rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If null, the identity matrix is used.</param>
            <param name="P">Optional new camera matrix (3x3) or the new projection matrix (3x4). P1 or P2, computed by cvStereoRectify can be passed here. If null, the identity matrix is used.</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Undistort``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Transforms the image to compensate radial and tangential lens distortion. 
            The camera matrix and distortion parameters can be determined using cvCalibrateCamera2. For every pixel in the output image the function computes coordinates of the corresponding location in the input image using the formulae in the section beginning. Then, the pixel value is computed using bilinear interpolation. If the resolution of images is different from what was used at the calibration stage, fx, fy, cx and cy need to be adjusted appropriately, while the distortion coefficients remain the same
            </summary>
            <typeparam name="TColor">The color type of the image</typeparam>
            <typeparam name="TDepth">The depth of the image</typeparam>
            <param name="src">The distorted image</param>
            <returns>The corrected image</returns>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Equals(Emgu.CV.IntrinsicCameraParameters)">
            <summary>
            Return true if the two intrinsic camera parameters are equal
            </summary>
            <param name="other">The other intrinsic camera parameters to compare with</param>
            <returns>True if the two intrinsic camera parameters are equal</returns>
        </member>
        <member name="P:Emgu.CV.IntrinsicCameraParameters.DistortionCoeffs">
            <summary>
            Get or Set the DistortionCoeffs ( as a 5x1 (default), 4x1 or 8x1 matrix ). 
            The ordering of the distortion coefficients is the following:
            (k1, k2, p1, p2[, k3 [,k4, k5, k6]]).
            That is, the first 2 radial distortion coefficients are followed by 2 tangential distortion coefficients and then, optionally, by the third radial distortion coefficients. Such ordering is used to keep backward compatibility with previous versions of OpenCV
            </summary>
        </member>
        <member name="P:Emgu.CV.IntrinsicCameraParameters.IntrinsicMatrix">
            <summary>
            Get or Set the intrinsic matrix (3x3)
            </summary>
        </member>
        <member name="T:Emgu.CV.Quaternions">
            <summary>
            A unit quaternions that defines rotation in 3D
            </summary>
        </member>
        <member name="M:Emgu.CV.Quaternions.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a quaternion with the specific values
            </summary>
            <param name="w">The W component of the quaternion: the value for cos(rotation angle / 2)</param>
            <param name="x">The X component of the vector: rotation axis * sin(rotation angle / 2)</param>
            <param name="y">The Y component of the vector: rotation axis * sin(rotation angle / 2)</param>
            <param name="z">The Z component of the vector: rotation axis * sin(rotation angle / 2)</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.SetEuler(System.Double,System.Double,System.Double)">
            <summary>
            Set the value of the quaternions using euler angle
            </summary>
            <param name="x">Rotation around x-axis (roll) in radian</param>
            <param name="y">Rotation around y-axis (pitch) in radian</param>
            <param name="z">rotation around z-axis (yaw) in radian</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.GetEuler(System.Double@,System.Double@,System.Double@)">
            <summary>
            Get the equaivalent euler angle
            </summary>
            <param name="x">Rotation around x-axis (roll) in radian</param>
            <param name="y">Rotation around y-axis (pitch) in radian</param>
            <param name="z">rotation around z-axis (yaw) in radian</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.GetRotationMatrix(Emgu.CV.Matrix{System.Double})">
            <summary>
            Fill the (3x3) rotation matrix with the value such that it represent the quaternions
            </summary>
            <param name="rotation">The (3x3) rotation matrix which values will be set to represent this quaternions</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.RotatePoints(Emgu.CV.Matrix{System.Double},Emgu.CV.Matrix{System.Double})">
            <summary>
            Rotate the points in <paramref name="pointsSrc"/> and save the result in <paramref name="pointsDst"/>. Inplace operation is supported (<paramref name="pointsSrc"/> == <paramref name="pointsDst"/>).
            </summary>
            <param name="pointsSrc">The points to be rotated</param>
            <param name="pointsDst">The result of the rotation, should be the same size as <paramref name="pointsSrc"/>, can be <paramref name="pointsSrc"/> as well for inplace rotation</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.RotatePoint(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Rotate the specific point and return the result
            </summary>
            <param name="point">The point to be rotated</param>
            <returns>The rotated point</returns>
        </member>
        <member name="M:Emgu.CV.Quaternions.Multiply(Emgu.CV.Quaternions)">
            <summary>
            Multiply the current Quaternions with <paramref name="quaternionsOther"/> 
            </summary>
            <param name="quaternionsOther">The other rotation</param>
            <return>A composition of the two rotations</return>
        </member>
        <member name="M:Emgu.CV.Quaternions.Slerp(Emgu.CV.Quaternions,System.Double)">
            <summary>
            Perform quaternions linear interpolation
            </summary>
            <param name="quaternionsOther">The other quaternions to interpolate with</param>
            <param name="weightForOther">If 0.0, the result is the same as this quaternions. If 1.0 the result is the same as <paramref name="quaternionsOther"/></param>
            <returns>The linear interpolated quaternions</returns>
        </member>
        <member name="M:Emgu.CV.Quaternions.op_Multiply(Emgu.CV.Quaternions,Emgu.CV.Quaternions)">
            <summary>
            Computes the multiplication of two quaternions
            </summary>
            <param name="q1">The quaternions to be multiplied</param>
            <param name="q2">The quaternions to be multiplied</param>
            <returns>The multiplication of two quaternions</returns>
        </member>
        <member name="F:Emgu.CV.Quaternions.Empty">
            <summary>
            Get the quaternions that represent a rotation of 0 degrees.
            </summary>
        </member>
        <member name="M:Emgu.CV.Quaternions.Conjugate">
            <summary>
            Compute the conjugate of the quaternions
            </summary>
        </member>
        <member name="M:Emgu.CV.Quaternions.Equals(Emgu.CV.Quaternions)">
            <summary>
            Check if this quaternions equals to <paramref name="other"/>
            </summary>
            <param name="other">The quaternions to be compared</param>
            <returns>True if two quaternions equals, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Quaternions.ToString">
            <summary>
            Get the string representation of the Quaternions
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="P:Emgu.CV.Quaternions.W">
            <summary>
            The W component of the quaternion: the value for cos(rotation angle / 2)
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.X">
            <summary>
            The X component of the vector: rotation axis * sin(rotation angle / 2)
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.Y">
            <summary>
            The Y component of the vector: rotation axis * sin(rotation angle / 2)
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.Z">
            <summary>
            The Z component of the vector: rotation axis * sin(rotation angle / 2)
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.AxisAngle">
            <summary>
            Get or set the equaivalent axis angle representation. (x,y,z) is the rotatation axis and |(x,y,z)| is the rotation angle in radians
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.RotationAxis">
            <summary>
            Get the rotation axis of the quaternion
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.RotationAngle">
            <summary>
            Get the rotation angle in radian
            </summary>
        </member>
        <member name="T:Emgu.CV.RotationMatrix2D">
            <summary>
            A (2x3) 2D rotation matrix. This Matrix defines an Affine Transform
            </summary>
        </member>
        <member name="T:Emgu.CV.Mat">
            <summary>
            The equivalent of cv::Mat, should only be used if you know what you are doing.
            In most case you should use the Matrix class instead
            </summary>
        </member>
        <member name="T:Emgu.CV.MatDataAllocator">
            <summary>
            Matrix data allocator. Base class for Mat that handles the matrix data allocation and deallocation
            </summary>
        </member>
        <member name="M:Emgu.CV.MatDataAllocator.DisposeObject">
            <summary>
            Release resource associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.MatDataAllocator.Data">
            <summary>
            Get the managed data used by the Mat
            </summary>
        </member>
        <member name="T:Emgu.CV.IImage">
            <summary>
            IImage interface
            </summary>
        </member>
        <member name="M:Emgu.CV.IImage.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <returns>
            Returns the min / max location and values for the image
            </returns>
        </member>
        <member name="M:Emgu.CV.IImage.Split">
            <summary> 
             Split current IImage into an array of gray scale images where each element 
             in the array represent a single color channel of the original image
            </summary>
            <returns> 
             An array of gray scale images where each element 
             in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.IImage.Save(System.String)">
            <summary>
            Save the image to the specific <paramref name="fileName"/> 
            </summary>
            <param name="fileName">The file name of the image</param>
        </member>
        <member name="P:Emgu.CV.IImage.Bitmap">
            <summary>
            Convert this image into Bitmap, when avaialbe, data is shared with this image.
            </summary>
            <returns>The Bitmap, when avaialbe, data is shared with this image</returns>
        </member>
        <member name="P:Emgu.CV.IImage.Size">
            <summary>
            The size of this image
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.Ptr">
            <summary>
            Get the pointer to the unmanaged memory
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.NumberOfChannels">
            <summary>
            Get the number of channels for this image
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor">
            <summary>
            Create an empty cv::Mat
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Create a mat of the specific type.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Mat header from existing data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.String,Emgu.CV.CvEnum.LoadImageType)">
            <summary>
            Load the Mat from file
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="loadType">File loading method</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(Emgu.CV.Mat,System.Drawing.Rectangle)">
            <summary>
            Create a mat header for the specific ROI
            </summary>
            <param name="mat">The mat where the new Mat header will share data from</param>
            <param name="roi">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.Mat.ToUMat(Emgu.CV.CvEnum.AccessType)">
            <summary>
            Convert this Mat to UMat
            </summary>
            <param name="access">Access type</param>
            <returns>The UMat</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Create(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix element depth type.</param>
            <param name="channels">New matrix number of channels</param>
        </member>
        <member name="M:Emgu.CV.Mat.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Copy the data in this cv::Mat to a CvArray
            </summary>
            <param name="m">The input array to copy to</param>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
        </member>
        <member name="M:Emgu.CV.Mat.ConvertTo(Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">Output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">Optional scale factor.</param>
            <param name="beta">Optional delta added to the scaled values.</param>
        </member>
        <member name="M:Emgu.CV.Mat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns>A new mat header that has different shape</returns>
        </member>
        <member name="M:Emgu.CV.Mat.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetInputArray">
            <summary>
            Pointer to the InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetOutputArray">
            <summary>
            Pointer to the OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetInputOutputArray">
            <summary>
            Pointer to the InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetValueRange">
            <summary>
            Get the minimum and maximum value across all channels of the mat
            </summary>
            <returns>The range that contains the minimum and maximum values</returns>
        </member>
        <member name="M:Emgu.CV.Mat.ToImage``2(System.Boolean)">
            <summary>
            Convert this Mat to Image
            </summary>
            <typeparam name="TColor">The type of Color</typeparam>
            <typeparam name="TDepth">The type of Depth</typeparam>
            <returns>The image</returns>
        </member>
        <member name="M:Emgu.CV.Mat.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray)">
            <summary>
            Set the mat to the specific value
            </summary>
            <param name="value">The value to set to</param>
            <param name="mask">Optional mask</param>
        </member>
        <member name="M:Emgu.CV.Mat.SetTo(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Set the mat to the specific value
            </summary>
            <param name="value">The value to set to</param>
            <param name="mask">Optional mask</param>
        </member>
        <member name="M:Emgu.CV.Mat.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.Mat.GetRow(System.Int32)">
            <summary>
            Create a Mat object with data pointed towards the specific row of the original matrix
            </summary>
            <param name="i">The row number</param>
            <returns>A Mat object with data pointed towards the specific row of the original matrix</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.Mat.Clone">
            <summary>
            Make a clone of the current Mat
            </summary>
            <returns>A clone fo the current Mat</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.Mat.Equals(Emgu.CV.Mat)">
            <summary>
            Compares two Mats and check if they are equal
            </summary>
            <param name="other">The other mat to compare with</param>
            <returns>True if the two Mats are equal</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Dot(Emgu.CV.IInputArray)">
            <summary>
            Computes a dot-product of two vectors.
            </summary>
            <param name="m">Another dot-product operand</param>
            <returns>The dot-product of two vectors.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Cross(Emgu.CV.IInputArray)">
            <summary>
            Computes a cross-product of two 3-element vectors.
            </summary>
            <param name="m">Another cross-product operand.</param>
            <returns>Cross-product of two 3-element vectors.</returns>
        </member>
        <member name="P:Emgu.CV.Mat.Size">
            <summary>
            The size of this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Rows">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Cols">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.DataPointer">
            <summary>
            Pointer to the beginning of the raw data
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Step">
            <summary>
            Step
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.NumberOfChannels">
            <summary>
            Number of channels
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Depth">
            <summary>
            Depth type
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.ElementSize">
            <summary>
            The size of the elements in this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.IsEmpty">
            <summary>
            Indicates if this cv::Mat is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Width">
            <summary>
            Get the width of the mat
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Height">
            <summary>
            Get the height of the mat.
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Bitmap">
            <summary>
            The Get property provide a more efficient way to convert Image&lt;Gray, Byte&gt;, Image&lt;Bgr, Byte&gt; and Image&lt;Bgra, Byte&gt; into Bitmap
            such that the image data is <b>shared</b> with Bitmap. 
            If you change the pixel value on the Bitmap, you change the pixel values on the Image object as well!
            For other types of image this property has the same effect as ToBitmap()
            <b>Take extra caution not to use the Bitmap after the Mat object is disposed</b>
            The Set property convert the bitmap to this Image type.
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.#ctor">
            <summary>
            Create an empty (2x3) 2D rotation matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.#ctor(System.Drawing.PointF,System.Double,System.Double)">
            <summary>
            Create a (2x3) 2D rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image</param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner). </param>
            <param name="scale">Isotropic scale factor.</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.SetRotation(System.Drawing.PointF,System.Double,System.Double)">
            <summary>
            Set the values of the rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image</param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner). </param>
            <param name="scale">Isotropic scale factor.</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.RotatePoints(Emgu.CV.Structure.MCvPoint2D64f[])">
            <summary>
            Rotate the <paramref name="points"/>, the value of the input <paramref name="points"/> will be changed.
            </summary>
            <param name="points">The points to be rotated, its value will be modified</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.RotatePoints(System.Drawing.PointF[])">
            <summary>
            Rotate the <paramref name="points"/>, the value of the input <paramref name="points"/> will be changed.
            </summary>
            <param name="points">The points to be rotated, its value will be modified</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.RotateLines(Emgu.CV.Structure.LineSegment2DF[])">
            <summary>
            Rotate the <paramref name="lineSegments"/>, the value of the input <paramref name="lineSegments"/> will be changed.
            </summary>
            <param name="lineSegments">The line segments to be rotated</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.RotatePoints``1(Emgu.CV.Matrix{``0})">
            <summary>
            Rotate the single channel Nx2 matrix where N is the number of 2D points. The value of the matrix is changed after rotation.
            </summary>
            <typeparam name="TDepth">The depth of the points, must be double or float</typeparam>
            <param name="points">The N 2D-points to be rotated</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.Clone">
            <summary>
            Return a clone of the Matrix
            </summary>
            <returns>A clone of the Matrix</returns>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.CreateRotationMatrix(System.Drawing.PointF,System.Double,System.Drawing.Size,System.Drawing.Size@)">
            <summary>
            Create a rotation matrix for rotating an image
            </summary>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at image centre). </param>
            <param name="center">The rotation center</param>
            <param name="srcImageSize">The source image size</param>
            <param name="dstImageSize">The minimun size of the destination image</param>
            <returns>The rotation matrix that rotate the source image to the destination image.</returns>
        </member>
        <member name="T:Emgu.CV.RotationVector3D">
            <summary>
            A (3x1) Rodrigues rotation vector. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. 
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize 3D rotation vector
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor">
            <summary>
            Create a 3D rotation vector (3x1 Matrix).
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor(System.Double[])">
            <summary>
            Create a rotation vector using the specific values
            </summary>
            <param name="value">The values of the (3 x 1) Rodrigues rotation vector</param>
        </member>
        <member name="P:Emgu.CV.RotationVector3D.RotationMatrix">
            <summary>
            Get or Set the (3x3) rotation matrix represented by this rotation vector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Capture">
            <summary> 
            Capture images from either camera or video file. 
            </summary>
        </member>
        <member name="T:Emgu.CV.IDuplexCapture">
            <summary>
            The interface to request a duplex image capture
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCapture.DuplexQueryFrame">
            <summary>
            Request a frame from server
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCapture.DuplexQuerySmallFrame">
            <summary>
            Request a frame from server which is half width and half height
            </summary>
        </member>
        <member name="T:Emgu.CV.ICapture">
            <summary> The interface that is used for WCF to provide a image capture service</summary>
        </member>
        <member name="M:Emgu.CV.ICapture.QueryFrame">
            <summary> Capture a Bgr image frame </summary>
            <returns> A Bgr image frame</returns>
        </member>
        <member name="M:Emgu.CV.ICapture.QuerySmallFrame">
            <summary> Capture a Bgr image frame that is half width and half heigh</summary>
            <returns> A Bgr image frame that is half width and half height</returns>
        </member>
        <member name="F:Emgu.CV.Capture._flipType">
            <summary>
            the type of flipping
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor(Emgu.CV.CvEnum.CaptureType)">
            <summary>
            Create a capture using the specific camera
            </summary>
            <param name="captureType">The capture type</param>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor">
            <summary> Create a capture using the default camera </summary>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor(System.Int32)">
            <summary> Create a capture using the specific camera</summary>
            <param name="camIndex"> The index of the camera to create capture from, starting from 0</param>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor(System.String)">
            <summary>
            Create a capture from file or a video stream
            </summary>
            <param name="fileName">The name of a file, or an url pointed to a stream.</param>
        </member>
        <member name="M:Emgu.CV.Capture.DisposeObject">
            <summary>
            Release the resource for this capture
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.GetCaptureProperty(Emgu.CV.CvEnum.CapProp)">
            <summary>
            Obtain the capture property
            </summary>
            <param name="index">The index for the property</param>
            <returns>The value of the specific property</returns>
        </member>
        <member name="M:Emgu.CV.Capture.SetCaptureProperty(Emgu.CV.CvEnum.CapProp,System.Double)">
            <summary>
            Sets the specified property of video capturing
            </summary>
            <param name="property">Property identifier</param>
            <param name="value">Value of the property</param>
            <returns>True if success</returns>
        </member>
        <member name="M:Emgu.CV.Capture.Grab">
            <summary>
            Grab a frame
            </summary>
            <returns>True on success</returns>
        </member>
        <member name="M:Emgu.CV.Capture.Start">
            <summary>
            Start the grab process in a separate thread. Once started, use the ImageGrabbed event handler and RetrieveGrayFrame/RetrieveBgrFrame to obtain the images.
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.Pause">
            <summary>
            Pause the grab process if it is running.
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.Stop">
            <summary>
            Stop the grabbing thread
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.Retrieve(Emgu.CV.IOutputArray,System.Int32)">
            <summary> 
            Retrieve a Gray image frame after Grab()
            </summary>
            <param name="image">The output image</param>
            <param name="flag">retrieve flags</param>
            <returns> A Gray image frame</returns>
        </member>
        <member name="M:Emgu.CV.Capture.QueryFrame">
            <summary> 
            Capture a Bgr image frame
            </summary>
            <returns> A Bgr image frame. If no more frames are available, null will be returned.</returns>
        </member>
        <member name="M:Emgu.CV.Capture.QuerySmallFrame">
            <summary> 
             Capture a Bgr image frame that is half width and half height. 
             Mainly used by WCF when sending image to remote locations in a bandwidth conservative scenario 
            </summary>
            <remarks>Internally, this is a cvQueryFrame operation follow by a cvPyrDown</remarks>
            <returns> A Bgr image frame that is half width and half height</returns>
        </member>
        <member name="M:Emgu.CV.Capture.DuplexQueryFrame">
            <summary>
            Query a frame duplexly over WCF
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.DuplexQuerySmallFrame">
            <summary>
            Query a small frame duplexly over WCF
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.CaptureSource">
            <summary>
            Get the type of the capture module
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.FlipType">
            <summary>
            Get and set the flip type
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.FlipHorizontal">
            <summary>
            Get or Set if the captured image should be flipped horizontally
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.FlipVertical">
            <summary>
            Get or Set if the captured image should be flipped vertically
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.Width">
            <summary> The width of this capture</summary>
        </member>
        <member name="P:Emgu.CV.Capture.Height">
            <summary> The height of this capture </summary>
        </member>
        <member name="E:Emgu.CV.Capture.ImageGrabbed">
            <summary>
            The event to be called when an image is grabbed
            </summary>
        </member>
        <member name="T:Emgu.CV.Capture.CaptureModuleType">
            <summary>
            The type of capture source
            </summary>
        </member>
        <member name="F:Emgu.CV.Capture.CaptureModuleType.Camera">
            <summary>
            Capture from camera
            </summary>
        </member>
        <member name="F:Emgu.CV.Capture.CaptureModuleType.Highgui">
            <summary>
            Capture from file using HighGUI
            </summary>
        </member>
        <member name="T:Emgu.CV.IDuplexCaptureCallback">
            <summary>
            The interface for DuplexCaptureCallback
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCaptureCallback.ReceiveFrame(Emgu.CV.Mat)">
            <summary>
            Function to call when an image is received
            </summary>
            <param name="img">The image received</param>
        </member>
        <member name="T:Emgu.CV.KinectCapture">
            <summary>
            Kinect Camera capture
            </summary>
        </member>
        <member name="M:Emgu.CV.KinectCapture.#ctor(Emgu.CV.KinectCapture.DeviceType,Emgu.CV.KinectCapture.ImageGeneratorOutputMode)">
            <summary>
            Create the Kinect Camera capture object
            </summary>
            <param name="type">The kinect device type</param>
            <param name="outputMode">The output mode</param>
        </member>
        <member name="M:Emgu.CV.KinectCapture.RetrieveGrayFrame(Emgu.CV.IOutputArray)">
            <summary>
            Retrieve Gray frame from Kinect
            </summary>
            <returns>A Gray frame from Kinect</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.RetrieveBgrFrame(Emgu.CV.IOutputArray)">
            <summary>
            Retrieve Bgr frame from Kinect
            </summary>
            <returns>A Bgr frame from Kinect</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.RetrieveDisparityMap(Emgu.CV.IOutputArray)">
            <summary>
            Retrieve disparity map (in pixels) from Kinect
            </summary>
            <returns>The disparity map from Kinect</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.RetrieveDisparityMap32f(Emgu.CV.IOutputArray)">
            <summary>
            Retrieve disparity map (in pixels) from Kinect
            </summary>
            <returns>The disparity map from Kinect</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.RetrieveValidDepthMap(Emgu.CV.IOutputArray)">
            <summary>
            Retrieve the valid depth map from Kinect
            </summary>
            <returns>The valid depth map from Kinect</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.RetrieveDepthMap(Emgu.CV.IOutputArray)">
            <summary>
            Retrieve the depth map from Kinect (in mm)
            </summary>
            <returns>The depth map from Kinect (in mm)</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.RetrievePointCloudMap(Emgu.CV.IOutputArray)">
            <summary>
            Retrieve all the points (x, y, z position in meters) from Kinect, row by row.
            </summary>
            <returns>All the points (x, y, z position in meters) from Kinect, row by row.</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.GetColorPoints(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Get an enumerator of the colored points from Kinect. This function can only be called after the Grab() function.
            </summary>
            <param name="mask">The mask that controls which points should be returned. You can use the result from RetrieveValidDepthMap() function. Use null if you want all points to be returned</param>
            <returns>An enumerator of the colored points from Kinect</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.GetMaxDisparity(System.Double)">
            <summary>
            Given the minimum distance in mm, return the maximum valid disparity value.
            </summary>
            <param name="minDistance">The minimum distance that an object is away from the camera</param>
            <returns>The maximum valid disparity</returns>
        </member>
        <member name="M:Emgu.CV.KinectCapture.GetOpenNIContext">
            <summary>
            Get the unmanaged OpenNI Context from the capture.
            </summary>
            <returns>Pointer to the OpenNI context</returns>
            <remarks>This function required the opencv_highgui module patched by EMGU CV, otherwise it will throw entry point not found exception.</remarks>
        </member>
        <member name="T:Emgu.CV.KinectCapture.ImageGeneratorOutputMode">
            <summary>
            Camera output mode
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ImageGeneratorOutputMode.Vga30Hz">
            <summary>
            VGA resolution
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ImageGeneratorOutputMode.Sxga15Hz">
            <summary>
            SXVGA resolution
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ImageGeneratorOutputMode.Sxga30Hz">
            <summary>
            SXVGA resolution
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ImageGeneratorOutputMode.Qvga30Hz">
            <summary>
            QVGA resolution
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ImageGeneratorOutputMode.Qvga60Hz">
            <summary>
            QVGA resolution
            </summary>
        </member>
        <member name="T:Emgu.CV.KinectCapture.OpenNIDataType">
            <summary>
            Open ni data type used by the retrieve functions
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.OpenNIDataType.DepthMap">
            <summary>
            Depth values in mm (CV_16UC1)
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.OpenNIDataType.PointCloudMap">
            <summary>
            XYZ in meters (CV_32FC3)
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.OpenNIDataType.DisparityMap">
            <summary>
            Disparity in pixels (CV_8UC1)
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.OpenNIDataType.DisparityMap32f">
            <summary>
            Disparity in pixels (CV_32FC1)
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.OpenNIDataType.ValidDepthMask">
            <summary>
             CV_8UC1
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.OpenNIDataType.BgrImage">
            <summary>
            Bgr image 
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.OpenNIDataType.GrayImage">
            <summary>
            Gray Image
            </summary>
        </member>
        <member name="T:Emgu.CV.KinectCapture.DeviceType">
            <summary>
            Kinect device type
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.DeviceType.Kinect">
            <summary>
            kinect
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.DeviceType.Xtion">
            <summary>
            Asus xtion
            </summary>
        </member>
        <member name="T:Emgu.CV.KinectCapture.ColorPoint">
            <summary>
            A point with Bgr color information
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ColorPoint.Position">
            <summary>
            The position in meters
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ColorPoint.Blue">
            <summary>
            The blue color
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ColorPoint.Green">
            <summary>
            The green color
            </summary>
        </member>
        <member name="F:Emgu.CV.KinectCapture.ColorPoint.Red">
            <summary>
            The red color
            </summary>
        </member>
        <member name="T:Emgu.CV.CascadeClassifier">
            <summary>
            The Cascade Classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.#ctor">
            <summary>
            A dummy constructor that mainly aimed for those who would like to inherite this class
            </summary>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.#ctor(System.String)">
            <summary> Create a CascadeClassifier from the specific file</summary>
            <param name="fileName"> The name of the file that contains the CascadeClassifier</param>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.DetectMultiScale(Emgu.CV.IInputArray,System.Double,System.Int32,System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles. 
            The function scans the image several times at different scales. Each time it considers overlapping regions in the image. 
            It may also apply some heuristics to reduce number of analyzed regions, such as Canny prunning. 
            After it has proceeded and collected the candidate rectangles (regions that passed the classifier cascade), it groups them and returns a sequence of average rectangles for each large enough group. 
            </summary>
            <param name="image">The image where the objects are to be detected from</param>
            <param name="scaleFactor">The factor by which the search window is scaled between the subsequent scans, for example, 1.1 means increasing window by 10%</param>
            <param name="minNeighbors">Minimum number (minus 1) of neighbor rectangles that makes up an object. All the groups of a smaller number of rectangles than min_neighbors-1 are rejected. If min_neighbors is 0, the function does not any grouping at all and returns all the detected candidate rectangles, which may be useful if the user wants to apply a customized grouping procedure. Use 3 for default.</param>
            <param name="minSize">Minimum window size. Use Size.Empty for default, where it is set to the size of samples the classifier has been trained on (~20x20 for face detection)</param>
            <param name="maxSize">Maxumum window size. Use Size.Empty for default, where the parameter will be ignored.</param>
            <returns>The objects detected, one array per channel</returns>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.DisposeObject">
            <summary>
            Release the CascadeClassifier Object and all the memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.CascadeClassifier.IsOldFormatCascade">
            <summary>
            Get if the cascade is old format
            </summary>
        </member>
        <member name="P:Emgu.CV.CascadeClassifier.OriginalWindowSize">
            <summary>
            Get the original window size
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Bgr">
            <summary> 
            Defines a Bgr (Blue Green Red) color
            </summary>
        </member>
        <member name="T:Emgu.CV.IColor">
            <summary>
             A color type
            </summary>
        </member>
        <member name="P:Emgu.CV.IColor.MCvScalar">
            <summary>
            The equivalent MCvScalar value
            </summary>
        </member>
        <member name="P:Emgu.CV.IColor.Dimension">
            <summary>
            Get the dimension of the color type
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgr._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a BGR color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.#ctor(System.Drawing.Color)">
            <summary>
            Create a Bgr color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.Equals(Emgu.CV.Structure.Bgr)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Bgra">
            <summary> 
            Defines a Bgra (Blue Green Red Alpha) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgra._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary> Create a BGRA color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
            <param name="alpha"> The alpha value for this color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.Equals(Emgu.CV.Structure.Bgra)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Alpha">
            <summary> Get or set the intensity of the alpha color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.ColorInfoAttribute">
            <summary>
            Attribute used to specify color information
            </summary>
        </member>
        <member name="F:Emgu.CV.ColorInfoAttribute._conversionCodename">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="M:Emgu.CV.ColorInfoAttribute.#ctor">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="P:Emgu.CV.ColorInfoAttribute.ConversionCodename">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Gray">
            <summary> Defines a Gray color </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Gray._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.#ctor(System.Double)">
            <summary> Create a Gray color with the given intensity</summary>
            <param name="intensity"> The intensity for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.GetHashCode">
            <summary>
            Returns the hash code for this color
            </summary>
            <returns>the hash code</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.Equals(Emgu.CV.Structure.Gray)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.Intensity">
            <summary> The intensity of the gray color </summary>
            <value> The intensity of the gray color</value>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Hls">
            <summary> 
            Defines a Hls (Hue Lightness Satuation) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Hls._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Hls color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation for this color </param>
            <param name="lightness"> The lightness for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.Equals(Emgu.CV.Structure.Hls)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Hue">
            <summary> Get or set the intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Lightness">
            <summary> Get or set the intensity of the lightness color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Satuation">
            <summary> Get or set the intensity of the satuation color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Hsv">
            <summary> 
            Defines a HSV (Hue Satuation Value) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Hsv._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a HSV color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation value for this color </param>
            <param name="value"> The value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.Equals(Emgu.CV.Structure.Hsv)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Hue">
            <summary> Get or set the intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Satuation">
            <summary> Get or set the intensity of the satuation color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Value">
            <summary> Get or set the intensity of the value color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Lab">
            <summary> 
            Defines a CIE Lab color 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Lab._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.Equals(Emgu.CV.Structure.Lab)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.X">
            <summary> Get or set the intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Y">
            <summary> Get or set the intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Z">
            <summary> Get or set the intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Luv">
            <summary> 
            Defines a CIE Luv color 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Luv._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.Equals(Emgu.CV.Structure.Luv)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.X">
            <summary> The intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Y">
            <summary> The intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Z">
            <summary> The intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Rgb">
            <summary> 
            Defines a Rgb (Red Green Blue) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Rgb._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a RGB color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.#ctor(System.Drawing.Color)">
            <summary>
            Create a Rgb color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.Equals(Emgu.CV.Structure.Rgb)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Bgr565">
            <summary> 
            Defines a Bgr565 (Blue Green Red) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgr565._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Bgr565 color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.#ctor(System.Drawing.Color)">
            <summary>
            Create a Bgr565 color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.Equals(Emgu.CV.Structure.Bgr565)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Rgba">
            <summary> 
            Defines a Rgba (Red Green Blue Alpha) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Rgba._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary> Create a RGBA color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
            <param name="alpha"> The alpha value for this color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.Equals(Emgu.CV.Structure.Rgba)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Alpha">
            <summary> Get or set the intensity of the alpha color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Xyz">
            <summary> 
            Defines a Xyz color (CIE XYZ.Rec 709 with D65 white point)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Xyz._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Xyz color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.Equals(Emgu.CV.Structure.Xyz)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.X">
            <summary> Get or set the intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Y">
            <summary> Get or set the intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Z">
            <summary> Get or set the intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Ycc">
            <summary> 
            Defines a Ycc color (YCrCb JPEG)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Ycc._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Ycc color using the specific values</summary>
            <param name="y"> The Y value for this color </param>
            <param name="cr"> The Cr value for this color </param>
            <param name="cb"> The Cb value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.Equals(Emgu.CV.Structure.Ycc)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Y">
            <summary> Get or set the intensity of the Y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Cr">
            <summary> Get or set the intensity of the Cr color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Cb">
            <summary> Get or set the intensity of the Cb color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Contour`1">
            <summary>
            Wrapped class for Contour
            </summary>
            <typeparam name="T">The type of elements in the Contour, either PointF or Point.</typeparam>
        </member>
        <member name="T:Emgu.CV.Seq`1">
            <summary>
             Wrapper to cvSeq of OpenCV. 
            </summary>
            <typeparam name="T">The type of elements in this sequence, must be a structure</typeparam>
        </member>
        <member name="F:Emgu.CV.Seq`1._ptr">
            <summary>
            The pointer to this sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.Seq`1._stor">
            <summary>
            The pointer to the storage used by this sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.Seq`1._sizeOfElement">
            <summary>
            The size of the elements in this sequence
            </summary>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(System.Int32,Emgu.CV.MemStorage)">
            <summary>
            Create a sequence using the specific <paramref name="seqFlag"/> and <paramref name="storage"/>
            </summary>
            <param name="seqFlag">Flags of the created sequence. If the sequence is not passed to any function working with a specific type of sequences, the sequence value may be set to 0, otherwise the appropriate type must be selected from the list of predefined sequence types</param>
            <param name="storage">the storage</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(Emgu.CV.CvEnum.SeqEltype,Emgu.CV.CvEnum.SeqKind,Emgu.CV.CvEnum.SeqFlag,Emgu.CV.MemStorage)">
            <summary>
            Create a contour of the specific kind, type and flag
            </summary>
            <param name="kind">The kind of the sequence</param>
            <param name="eltype">The type of the sequence</param>
            <param name="flag">The flag of the sequence</param>
            <param name="stor">The storage</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(Emgu.CV.MemStorage)">
            <summary>
            Create a sequence using the specific <paramref name="storage"/>
            </summary>
            <param name="storage">the storage</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.FixElementType(System.Int32)">
            <summary>
            Fix the input element type and return the correct one
            </summary>
            <param name="seqType">The input sequence type</param>
            <returns>The best element type that match this sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(System.IntPtr,Emgu.CV.MemStorage)">
            <summary>
            Create a sequence from the unmanaged pointer and the storage used by the pointer
            </summary>
            <param name="seq">The unmanaged sequence</param>
            <param name="storage">The memory storage this sequence utilize</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.Push(`0)">
            <summary>
            Push the data to the sequence
            </summary>
            <param name="data">The data to be pushed into the sequence</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.PushFront(`0)">
            <summary>
            Push the data to the sequence
            </summary>
            <param name="data">The data to be pushed into the sequence</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.PushMulti(`0[],Emgu.CV.CvEnum.BackOrFront)">
            <summary>
            Push multiple elements to the sequence
            </summary>
            <param name="data">The data to push to the sequence</param>
            <param name="backOrFront">Specify if pushing to the back or front</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.Pop">
            <summary>
            Pop an element from the back of the sequence 
            </summary>
            <returns>An element from the back of the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.PopFront">
            <summary>
            Pop an element from the front of the sequence 
            </summary>
            <returns>An element from the front of the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.PopMulti(System.Int32,Emgu.CV.CvEnum.BackOrFront)">
            <summary>
            Pop multiple elements from the sequence
            </summary>
            <param name="count">The number of elements to be poped</param>
            <param name="backOrFront">The location the pop operation is started</param>
            <returns>The elements poped from the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.RemoveAt(System.Int32)">
            <summary>
            Removes element from sequence middle
            </summary>
            <param name="index">Index of removed element</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.Insert(System.Int32,`0)">
            <summary>
            Inserts element in sequence middle
            </summary>
            <param name="index">Index before which the element is inserted. Inserting before 0 (the minimal allowed value of the parameter) is equal to cvSeqPushFront and inserting before seq->total (the maximal allowed value of the parameter) is equal to cvSeqPush</param>
            <param name="data">Inserted element</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.ToArray">
            <summary>
            Convert this sequence to array
            </summary>
            <returns>the array representation of this sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetEnumerator">
            <summary>
            return an enumerator of the elements in the sequence
            </summary>
            <returns>an enumerator of the elements in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            return an enumerator of the elements in the sequence
            </summary>
            <returns>an enumerator of the elements in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.Slice(Emgu.CV.Structure.MCvSlice,Emgu.CV.MemStorage,System.Boolean)">
            <summary>
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function
            </summary>
            <param name="slice">The part of the sequence to extract</param>
            <param name="storage">The destination storage to keep the new sequence header and the copied data if any. If it is NULL, the function uses the storage containing the input sequence.</param>
            <param name="copy_data">The flag that indicates whether to copy the elements of the extracted slice </param>
            <returns>A sequence that represents the specified slice of the input sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.Clear">
            <summary>
            Removes all elements from the sequence. The function does not return the memory to the storage, but this memory is reused later when new elements are added to the sequence. This function time complexity is O(1). 
            </summary>
        </member>
        <member name="M:Emgu.CV.Seq`1.op_Implicit(Emgu.CV.Seq{`0})~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="sequence">The sequence</param>
            <returns>The unmanaged pointer for this object</returns>
        </member>
        <member name="P:Emgu.CV.Seq`1.Ptr">
            <summary>
            Get the pointer of this sequence
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.ElementType">
            <summary>
            Get or Set the element Type
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Storage">
            <summary>
            A Pointer to the storage used by this Seq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.MCvSeq">
            <summary>
            Get the MCvSeq structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Item(System.Int32)">
            <summary>
            Obtain the <paramref name="index"/> element in this sequence
            </summary>
            <param name="index">the index of the element</param>
            <returns>the <paramref name="index"/> element in this sequence</returns>
        </member>
        <member name="P:Emgu.CV.Seq`1.HNext">
            <summary>
            Same as h_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.HPrev">
            <summary>
            Same as h_prev pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.VNext">
            <summary>
            Same as v_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.VPrev">
            <summary>
            Same as v_prev pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Total">
            <summary> Get the number of eelments in the sequence</summary>
        </member>
        <member name="M:Emgu.CV.Contour`1.#ctor(System.IntPtr,Emgu.CV.MemStorage)">
            <summary>
            Craete a contour from the specific IntPtr and storage
            </summary>
            <param name="ptr">The unmanged Pointer to the sequence</param>
            <param name="storage">The storage used by this contour</param>
        </member>
        <member name="M:Emgu.CV.Contour`1.#ctor(System.Int32,Emgu.CV.MemStorage)">
            <summary>
            Create a contour using the specific <paramref name="seqFlag"/> and <paramref name="storage"/>
            </summary>
            <param name="seqFlag">Flags of the created contour. If the contour is not passed to any function working with a specific type of sequences, the sequence value may be set to 0, otherwise the appropriate type must be selected from the list of predefined contour types</param>
            <param name="storage">The storage</param>
        </member>
        <member name="M:Emgu.CV.Contour`1.#ctor(Emgu.CV.CvEnum.SeqEltype,Emgu.CV.CvEnum.SeqKind,Emgu.CV.CvEnum.SeqFlag,Emgu.CV.MemStorage)">
            <summary>
            Create a contour of the specific kind, type and flag
            </summary>
            <param name="kind">The kind of the sequence</param>
            <param name="eltype">The type of the sequence</param>
            <param name="flag">The flag of the sequence</param>
            <param name="stor">The storage</param>
        </member>
        <member name="M:Emgu.CV.Contour`1.#ctor(Emgu.CV.MemStorage)">
            <summary>
            Create a contour using the specific <paramref name="storage"/>
            </summary>
            <param name="storage">The storage to be used</param>
        </member>
        <member name="P:Emgu.CV.Contour`1.MCvContour">
            <summary>
            Return the MCvContour structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Contour`1.HNext">
            <summary>
            Same as h_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Contour`1.HPrev">
            <summary>
            Same as h_prev pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Contour`1.VNext">
            <summary>
            Same as v_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Contour`1.VPrev">
            <summary>
            Same as v_prev pointer in CvSeq
            </summary>
        </member>
        <member name="T:Emgu.CV.ConvolutionKernelF">
            <summary>
            A convolution kernel 
            </summary>
        </member>
        <member name="F:Emgu.CV.ConvolutionKernelF._center">
            <summary>
            The center of the convolution kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a convolution kernel with the specific number of <paramref name="rows"/> and <paramref name="cols"/>
            </summary>
            <param name="rows">The number of raws for the convolution kernel</param>
            <param name="cols">The number of columns for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(Emgu.CV.Matrix{System.Single},System.Drawing.Point)">
            <summary>
            Create a convolution kernel using the specific matrix and center
            </summary>
            <param name="kernel">The values for the convolution kernel</param>
            <param name="center">The center of the kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Single[0:,0:])">
            <summary>
            Create a convolution kernel using the specific floating point matrix
            </summary>
            <param name="kernel">The values for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Single[0:,0:],System.Drawing.Point)">
            <summary>
            Create a convolution kernel using the specific floating point matrix and center
            </summary>
            <param name="kernel">The values for the convolution kernel</param>
            <param name="center">The center for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.Flip(Emgu.CV.CvEnum.FlipType)">
            <summary> Get a flipped copy of the convolution kernel</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.Transpose">
            <summary>
            Obtain the transpose of the convolution kernel
            </summary>
            <returns>A transposed convolution kernel</returns>
        </member>
        <member name="P:Emgu.CV.ConvolutionKernelF.Center">
            <summary>
            The center of the convolution kernel
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlob">
            <summary>
            CvBlob
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlob.GetContour(Emgu.CV.MemStorage)">
            <summary>
            Get the contour that defines the blob
            </summary>
            <param name="storage">The memory storage when the resulting contour will be allocated</param>
            <returns>The contour of the blob</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlob.op_Implicit(Emgu.CV.Cvb.CvBlob)~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The CvBlob</param>
            <returns>The unmanaged pointer for this object</returns>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.Label">
            <summary>
            Get the blob label
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.BoundingBox">
            <summary>
            The minimum bounding box of the blob
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.BlobMoments">
            <summary>
            Get the Blob Moments
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.Centroid">
            <summary>
            The centroid of the blob
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.Area">
            <summary>
            The number of pixels in this blob
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.Ptr">
            <summary>
            Pointer to the blob
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlob.Moments">
            <summary>
            Blob Moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M00">
            <summary>
            Mement 00
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M10">
            <summary>
            Moment 10
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M01">
            <summary>
            Moment 01
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M11">
            <summary>
            Moment 11
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M20">
            <summary>
            Moment 20
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M02">
            <summary>
             Moment 02
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.U11">
            <summary>
            Central moment 11
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.U20">
            <summary>
            Central moment 20
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.U02">
            <summary>
            Central moment 02
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.N11">
            <summary>
            Normalized central moment 11
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.N20">
            <summary>
            Normalized central moment 20
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.N02">
            <summary>
            Normalized central moment 02
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.P1">
            <summary>
            Hu moment 1
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.P2">
            <summary>
            Hu moment 2
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlobDetector">
            <summary>
            Wrapper for the CvBlob detection functions.
            The Ptr property points to the label image of the cvb::cvLabel function.
            </summary>
            <remarks>Algorithm based on paper "A linear-time component-labeling algorithm using contour tracing technique" of Fu Chang, Chun-Jen Chen and Chi-Jen Lu.</remarks>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.Detect(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Cvb.CvBlobs)">
            <summary>
            Detect blobs from input image.
            </summary>
            <param name="img">The input image</param>
            <param name="blobs">The storage for the detected blobs</param>
            <returns>Number of pixels that has been labeled.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.MeanColor(Emgu.CV.Cvb.CvBlob,Emgu.CV.Image{Emgu.CV.Structure.Bgr,System.Byte})">
            <summary>
            Calculates mean color of a blob in an image.
            </summary>
            <param name="blob">The blob.</param>
            <param name="originalImage">The original image</param>
            <returns>Average color</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.DrawBlobs(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Cvb.CvBlobs,Emgu.CV.Cvb.CvBlobDetector.BlobRenderType,System.Double)">
            <summary>
            Draw the blobs on the image
            </summary>
            <param name="image">The binary mask.</param>
            <param name="blobs">The blobs.</param>
            <param name="type">Drawing type.</param>
            <param name="alpha">The alpha value. 1.0 for solid color and 0.0 for transparent</param>
            <returns>The images with the blobs drawn</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.DrawBlobsMask(Emgu.CV.Cvb.CvBlobs)">
            <summary>
            Get the binary mask for the blobs listed in the CvBlobs
            </summary>
            <param name="blobs">The blobs</param>
            <returns>The binary mask for the specific blobs</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this Blob detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType">
            <summary>
            Blob rendering type
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.Color">
            <summary>
            Render each blog with a different color. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.Centroid">
            <summary>
            Render centroid. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.BoundingBox">
            <summary>
            Render bounding box. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.Angle">
            <summary>
            Render angle. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.ToLog">
            <summary>
            Print blob data to log out. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.ToStd">
            <summary>
            Print blob data to std out. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.Default">
            <summary>
            The default rendering type
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlobs">
            <summary>
            CvBlobs
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.#ctor">
            <summary>
            Create a new CvBlobs
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.DisposeObject">
            <summary>
            Release all the unmanaged resources used by this CvBlobs
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.FilterByArea(System.Int32,System.Int32)">
            <summary>
            Filter blobs by area. Those blobs whose areas are not in range will be erased from the input list of blobs.
            </summary>
            <param name="minArea">Minimun area</param>
            <param name="maxArea">Maximun area</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Add(System.UInt32,Emgu.CV.Cvb.CvBlob)">
            <summary>
            Adds the specified label and blob to the dictionary.
            </summary>
            <param name="label">The label of the blob</param>
            <param name="blob">The blob</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.ContainsKey(System.UInt32)">
            <summary>
            Determines whether the CvBlobs contains the specified label.
            </summary>
            <param name="label">The label (key) to be located</param>
            <returns>True if the CvBlobs contains an element with the specific label</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Remove(System.UInt32)">
            <summary>
            Removes the blob with the specific label
            </summary>
            <param name="label">The label of the blob</param>
            <returns>True if the element is successfully found and removed; otherwise, false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.TryGetValue(System.UInt32,Emgu.CV.Cvb.CvBlob@)">
            <summary>
            Gets the blob associated with the specified label.
            </summary>
            <param name="label">The blob label</param>
            <param name="blob">When this method returns, contains the blob associated with the specified labe, if the label is found; otherwise, null. This parameter is passed uninitialized.</param>
            <returns>True if the blobs contains a blob with the specific label; otherwise, false</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Add(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvBlob})">
             <summary>
             Adds the specified label and blob to the CvBlobs.
             </summary>
            <param name="item">The structure representing the label and blob to add to the CvBlobs</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Clear">
            <summary>
            Removes all keys and values
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Contains(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvBlob})">
            <summary>
            Determines whether the CvBlobs contains a specific label and CvBlob.
            </summary>
            <param name="item">The label and blob to be located</param>
            <returns>True if the specific label and blob is found in the CvBlobs; otherwise, false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.CopyTo(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvBlob}[],System.Int32)">
            <summary>
            Copies the elements to the <paramref name="array"/>, starting at the specific arrayIndex.
            </summary>
            <param name="array">The one-dimensional array that is the defination of the elements copied from the CvBlobs. The array must have zero-base indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Remove(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvBlob})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="item">The structure representing the key and value to be removed</param>
            <returns>True if the key are value is sucessfully found and removed; otherwise false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.cvbCvBlobsCreate">
            <summary>
            Returns a pointer to CvBlobs
            </summary>
            <returns>Pointer to CvBlobs</returns>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.Keys">
            <summary>
            Get a collection containing the labels in the CvBlobs
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.Values">
            <summary>
            Get a collection containing the blobs in the CvBlobs.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.Item(System.UInt32)">
            <summary>
            Get the blob with the speicific label. Set function is not implemented
            </summary>
            <param name="label">The label for the blob</param>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.Count">
            <summary>
            Gets the number of label/Blob pairs contained in the collection
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.IsReadOnly">
            <summary>
            Always false
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvTrack">
            <summary>
            CvTrack
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Id">
            <summary>
            Track identification number
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.BlobLabel">
            <summary>
            Label assigned to the blob related to this track
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.MinX">
            <summary>
            X min
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.MaxX">
            <summary>
            X max
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.MinY">
            <summary>
            Y min
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.MaxY">
            <summary>
            y max
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Centroid">
            <summary>
             Centroid
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Lifetime">
            <summary>
            Indicates how much frames the object has been in scene
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Active">
            <summary>
            Indicates number of frames that has been active from last inactive period.
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Inactive">
            <summary>
            Indicates number of frames that has been missing.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTrack.Equals(Emgu.CV.Cvb.CvTrack)">
            <summary>
            Compares CvTrack for equality
            </summary>
            <param name="other">The other track to compares with</param>
            <returns>True if the two CvTrack are equal; otherwise false.</returns>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTrack.BoundingBox">
            <summary>
            Get the minimun bounding rectanble for this track 
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvTracks">
             <summary>
             Blobs tracking
             </summary>
             <remarks>
             Tracking based on:
             A.Senior,A.Hampapur,Y-LTian,L.Brown,S.Pankanti,R.Bolle.AppearanceModelsfor
             OcclusionHandling.SecondInternationalworkshoponPerformanceEvaluationofTrackingand
             SurveillanceSystems&amp;CVPR'01.December,2001.
             (http://www.research.ibm.com/peoplevision/PETS2001.pdf)
            </remarks>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.#ctor">
            <summary>
            Create a new CvTracks
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.DisposeObject">
            <summary>
            Release all the unmanaged resources used by this CvBlobs
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Update(Emgu.CV.Cvb.CvBlobs,System.Double,System.UInt32,System.UInt32)">
            <summary>
            Updates list of tracks based on current blobs.
            </summary>
            <param name="blobs">List of blobs</param>
            <param name="thDistance">Distance Max distance to determine when a track and a blob match</param>
            <param name="thInactive">Inactive Max number of frames a track can be inactive</param>
            <param name="thActive">Active If a track becomes inactive but it has been active less than thActive frames, the track will be deleted.</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Add(System.UInt32,Emgu.CV.Cvb.CvTrack)">
            <summary>
            Adds the specified id and track to the dictionary.
            </summary>
            <param name="id">The id of the track</param>
            <param name="track">The track</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.ContainsKey(System.UInt32)">
            <summary>
            Determines whether the CvTracks contains the specified id.
            </summary>
            <param name="id">The id (key) to be located</param>
            <returns>True if the CvTracks contains an element with the specific id</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Remove(System.UInt32)">
            <summary>
            Removes the track with the specific id
            </summary>
            <param name="id">The id of the track</param>
            <returns>True if the element is successfully found and removed; otherwise, false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.TryGetValue(System.UInt32,Emgu.CV.Cvb.CvTrack@)">
            <summary>
            Gets the track associated with the specified id.
            </summary>
            <param name="id">The track id</param>
            <param name="track">When this method returns, contains the track associated with the specified id, if the id is found; otherwise, an empty track. This parameter is passed uninitialized.</param>
            <returns>True if the tracks contains a track with the specific id; otherwise, false</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Add(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvTrack})">
             <summary>
             Adds the specified id and track to the CvTracks.
             </summary>
            <param name="item">The structure representing the id and track to add to the CvTracks</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Clear">
            <summary>
            Removes all keys and values
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Contains(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvTrack})">
            <summary>
            Determines whether the CvTracks contains a specific id and CvTrack.
            </summary>
            <param name="item">The id and CvTrack to be located</param>
            <returns>True if the <paramref name="item"/> is found in the CvTracks; otherwise, false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.CopyTo(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvTrack}[],System.Int32)">
            <summary>
            Copies the elements to the <paramref name="array"/>, starting at the specific arrayIndex.
            </summary>
            <param name="array">The one-dimensional array that is the defination of the elements copied from the CvTracks. The array must have zero-base indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Remove(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvTrack})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="item">The structure representing the key and value to be removed</param>
            <returns>True if the key are value is sucessfully found and removed; otherwise false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.cvbCvTracksCreate">
            <summary>
            Returns a pointer to CvBlobs
            </summary>
            <returns>Pointer to CvBlobs</returns>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.Keys">
            <summary>
            Get a collection containing the ids in the CvTracks.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.Values">
            <summary>
            Get a collection containing the tracks in the CvTracks.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.Item(System.UInt32)">
            <summary>
            Get or Set the Track with the specific id.
            </summary>
            <param name="id">The id of the Track</param>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.Count">
            <summary>
            Gets the number of id/track pairs contained in the collection.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.IsReadOnly">
            <summary>
            Always false.
            </summary>
        </member>
        <member name="T:Emgu.CV.DenseHistogram">
            <summary> 
             A Uniform Multi-dimensional Dense Histogram 
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.#ctor(System.Int32,Emgu.CV.Structure.RangeF)">
            <summary>
            Creates a uniform 1-D histogram of the specified size
            </summary>
            <param name="binSize">The number of bins in this 1-D histogram. </param>
            <param name="range">The upper and lower boundary of the bin</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.#ctor(System.Int32[],Emgu.CV.Structure.RangeF[])">
            <summary>
            Creates a uniform multi-dimension histogram of the specified size
            </summary>
            <param name="binSizes">The length of this array is the dimension of the histogram. The values of the array contains the number of bins in each dimension. The total number of bins eaquals the multiplication of all numbers in the array</param>
            <param name="ranges">the upper and lower boundaries of the bins</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Clear">
            <summary> 
             Clear this histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Calculate``1(Emgu.CV.Image{Emgu.CV.Structure.Gray,``0}[],System.Boolean,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Project the images to the histogram bins 
            </summary>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
            <param name="imgs">images to project</param>
            <param name="accumulate">If it is true, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online. </param>
            <param name="mask">Can be null if not needed. The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Calculate``1(Emgu.CV.Matrix{``0}[],System.Boolean,Emgu.CV.Matrix{System.Byte})">
            <summary>
            Project the matrices to the histogram bins 
            </summary>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
            <param name="matrices">Matrices to project</param>
            <param name="accumulate">If it is true, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online. </param>
            <param name="mask">Can be null if not needed. The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.BackProject``1(Emgu.CV.Image{Emgu.CV.Structure.Gray,``0}[])">
            <summary> 
             Backproject the histogram into a gray scale image
            </summary>
            <param name="srcs">Source images, all are of the same size and type</param>
            <returns>Destination back projection image of the same type as the source images</returns>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.BackProject``1(Emgu.CV.Matrix{``0}[])">
            <summary> 
             Backproject the histogram into a matrix
            </summary>
            <param name="srcs">Source matrices, all are of the same size and type</param>
            <returns>Destination back projection matrix of the sametype as the source matrices</returns>
            <typeparam name="TDepth">The type of depth of the matrix</typeparam>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.BinDimension">
            <summary>
            Get the size of the bin dimensions
            </summary>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.Ranges">
            <summary>
            Get the ranges of this histogram
            </summary>
        </member>
        <member name="T:Emgu.CV.DenseOpticalFlow">
            <summary>
            Dense Optical flow
            </summary>
        </member>
        <member name="T:Emgu.CV.IAlgorithm">
            <summary>
            This is the algorithm class
            </summary>
        </member>
        <member name="P:Emgu.CV.IAlgorithm.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
            <returns>The pointer to the algorithm object</returns>
        </member>
        <member name="M:Emgu.CV.DenseOpticalFlow.Calc(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray)">
            <summary>
            Calculates an optical flow.
            </summary>
            <param name="i0">First 8-bit single-channel input image.</param>
            <param name="i1">Second input image of the same size and the same type as prev.</param>
            <param name="flow">Computed flow image that has the same size as prev and type CV_32FC2 </param>
        </member>
        <member name="M:Emgu.CV.DenseOpticalFlow.DisposeObject">
            <summary>
            Release the unmanaged object related to this dense optical flow
            </summary>
        </member>
        <member name="T:Emgu.CV.OpticalFlowDualTVL1">
            <summary>
            Dual TV L1 Optical Flow Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.OpticalFlowDualTVL1.#ctor">
            <summary>
            Create Dual TV L1 Optical Flow.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.DistanceType">
            <summary>
            The match distance type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Inf">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L1">
            <summary>
            Manhattan distance (city block distance)
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L2">
            <summary>
            Squared Euclidean distance
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L2Sqr">
            <summary>
            Euclidean distance
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Hamming">
            <summary>
            Hamming distance functor - counts the bit differences between two strings - useful for the Brief descriptor, 
            bit count of A exclusive XOR'ed with B. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Hamming2">
            <summary>
            Hamming distance functor - counts the bit differences between two strings - useful for the Brief descriptor, 
            bit count of A exclusive XOR'ed with B. 
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BFMatcher">
            <summary>
            Wrapped BFMatcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.DescriptorMatcher">
            <summary>
            Descriptor matcher
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.KnnMatch(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfDMatch,System.Int32,Emgu.CV.IInputArray)">
            <summary>
            Find the k-nearest match
            </summary>
            <param name="queryDescriptor">An n x m matrix of descriptors to be query for nearest neighbours. n is the number of descriptor and m is the size of the descriptor</param>
            <param name="k">Number of nearest neighbors to search for</param>
            <param name="mask">Can be null if not needed. An n x 1 matrix. If 0, the query descriptor in the corresponding row will be ignored.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.Add(Emgu.CV.IInputArray)">
            <summary>
            Add the model descriptors
            </summary>
            <param name="modelDescriptors">The model descriptors</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BFMatcher.#ctor(Emgu.CV.Features2D.DistanceType,System.Boolean)">
            <summary>
            Create a BFMatcher of the specific distance type
            </summary>
            <param name="distanceType">The distance type</param>
            <param name="crossCheck">Specify whether or not cross check is needed. Use false for default.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BFMatcher.DisposeObject">
            <summary>
            Release the unmanaged resource associated with the BFMatcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BOWImgDescriptorExtractor">
            <summary>
            Class to compute an image descriptor using the bag of visual words. Such a computation consists of the following
            steps:
            1. Compute descriptors for a given image and its key points set.
            2. Find the nearest visual words from the vocabulary for each key point descriptor.
            3. Compute the bag-of-words image descriptor as is a normalized histogram of vocabulary words encountered in
            the image. The i-th bin of the histogram is a frequency of i-th word of the vocabulary in the given image.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.#ctor(Emgu.CV.Features2D.IDescriptorExtractor,Emgu.CV.Features2D.DescriptorMatcher)">
            <summary>
            
            </summary>
            <param name="descriptorExtractor">Descriptor extractor that is used to compute descriptors for an input image and its key points.</param>
            <param name="descriptorMatcher">Descriptor matcher that is used to find the nearest word of the trained vocabulary for each key point descriptor of the image.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.SetVocabulary(Emgu.CV.Mat)">
            <summary>
            Sets a visual vocabulary.
            </summary>
            <param name="vocabulary">The vocabulary</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.Compute(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Mat)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="image">Image, for which the descriptor is computed</param>
            <param name="keypoints">Key points detected in the input image.</param>
            <param name="imgDescriptors">The output image descriptors.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BOWKMeansTrainer">
            <summary>
            Kmeans-based class to train visual vocabulary using the bag of visual words approach.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.#ctor(System.Int32,Emgu.CV.Structure.MCvTermCriteria,System.Int32,Emgu.CV.CvEnum.KMeansInitType)">
            <summary>
            Create a new BOWKmeans trainer
            </summary>
            <param name="clusterCount">Number of clusters to split the set by.</param>
            <param name="termcrit">Specifies maximum number of iterations and/or accuracy (distance the centers move by between the subsequent iterations). Use empty termcrit for default.</param>
            <param name="attempts">The number of attemps. Use 3 for default</param>
            <param name="flags">Kmeans initialization flag. Use PPCenters for default.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.Add(Emgu.CV.Mat)">
            <summary>
            Add the descriptors to the trainer
            </summary>
            <param name="descriptors">The descriptors to be added to the trainer</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.Cluster(Emgu.CV.IOutputArray)">
            <summary>
            Cluster the descriptors and return the cluster centers
            </summary>
            <returns>The cluster centers</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.BOWKMeansTrainer.DescriptorCount">
            <summary>
            Get the number of descriptors
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Brisk">
            <summary>
            BRISK: Binary Robust Invariant Scalable Keypoints
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Feature2D">
            <summary>
            The feature 2D base class
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.IFeatureDetector">
            <summary>
            An interface for feature detector
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.IFeatureDetector.FeatureDetectorPtr">
            <summary>
            Get the pointer to the feature detector. 
            </summary>
            <returns>The feature detector</returns>
        </member>
        <member name="T:Emgu.CV.Features2D.IDescriptorExtractor">
            <summary>
            An interface for a descriptor generator
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.IDescriptorExtractor.DescriptorExtratorPtr">
            <summary>
            Get the pointer to the descriptor extractor. 
            </summary>
            <returns>The descriptor extractor</returns>
        </member>
        <member name="F:Emgu.CV.Features2D.Feature2D._featureDetectorPtr">
            <summary>
            The pointer to the feature detector
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Feature2D._descriptorExtractorPtr">
            <summary>
            The pointer to the descriptor extractor.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.DetectAndCompute(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Detect keypoints in an image and compute the descriptors on the image from the keypoint locations.
            </summary>
            <param name="image">The image</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <param name="keyPoints">The detected keypoints will be stored in this vector</param>
            <param name="descriptors">The descriptors from the keypoints</param>
            <param name="useProvidedKeyPoints">If true, the method will skip the detection phase and will compute descriptors for the provided keypoints</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.DisposeObject">
            <summary>
            Reset the pointers
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.Feature2D.FeatureDetectorPtr">
            <summary>
            Get the pointer to the feature detector. 
            </summary>
            <returns>The feature detector</returns>
        </member>
        <member name="P:Emgu.CV.Features2D.Feature2D.DescriptorExtratorPtr">
            <summary>
            Get the pointer to the descriptor extractor. 
            </summary>
            <returns>The descriptor extractor</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.Brisk.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Create a BRISK keypoint detector and descriptor extractor.
            </summary>
            <param name="thresh">Feature parameters.</param>
            <param name="octaves">The number of octave layers.</param>
            <param name="patternScale">Pattern scale</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Brisk.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.FastDetector">
            <summary>
            FAST(Features from Accelerated Segment Test) keypoint detector. 
            See Detects corners using FAST algorithm by E. Rosten (Machine learning for high-speed corner
            detection, 2006).
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.FastDetector.#ctor(System.Int32,System.Boolean)">
            <summary>
            Create a fast detector with the specific parameters
            </summary>
            <param name="threshold">Threshold on difference between intensity of center pixel and pixels on circle around
            this pixel.</param>
            <param name="nonmaxSupression">Specifiy if non-maximum supression should be used.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.FastDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.FastDetector.Threshold">
            <summary>
            Threshold on difference between intensity of center pixel and pixels on circle around
            this pixel. See description of the algorithm.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.FastDetector.NonmaxSupression">
            <summary>
            If it is true then non-maximum supression will be applied to detected corners
            (keypoints)
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.FastDetector.Emgu#CV#Features2D#IFeatureDetector#FeatureDetectorPtr">
            <summary>
            Get the feature detector. 
            </summary>
            <returns>The feature detector</returns>
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DExtensions">
            <summary>
            A collection of Extension methods for IKeyPointDetector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DExtensions.DetectRaw(Emgu.CV.Features2D.IFeatureDetector,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputArray)">
            <summary>
            Detect the features in the image
            </summary>
            <param name="detector">The feature detector</param>
            <param name="keypoints">The result vector of keypoints</param>
            <param name="image">The image from which the features will be detected from</param>
            <param name="mask">The optional mask.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DExtensions.Detect(Emgu.CV.Features2D.IFeatureDetector,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Detect the keypoints from the image
            </summary>
            <param name="detector">The keypoint detector</param>
            <param name="image">The image to extract keypoints from</param>
            <param name="mask">The optional mask.</param>
            <returns>An array of key points</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DExtensions.Compute(Emgu.CV.Features2D.IDescriptorExtractor,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IOutputArray)">
            <summary>
            Compute the descriptors on the image from the given keypoint locations.
            </summary>
            <param name="extractor">The descriptor extractor</param>
            <param name="image">The image to compute descriptors from</param>
            <param name="keyPoints">The keypoints where the descriptor computation is perfromed</param>
            <param name="descriptors">The descriptors from the given keypoints</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DExtensions.GetDescriptorSize(Emgu.CV.Features2D.IDescriptorExtractor)">
            <summary>
            Get the number of elements in the descriptor.
            </summary>
            <param name="extractor">The descriptor extractor</param>
            <returns>The number of elements in the descriptor</returns>
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DToolbox">
            <summary>
            Tools for features 2D
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.DrawKeypoints(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.Bgr,Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType)">
            <summary>
            Draw the keypoints found on the image.
            </summary>
            <param name="image">The image</param>
            <param name="keypoints">The keypoints to be drawn</param>
            <param name="color">The color used to draw the keypoints</param>
            <param name="type">The drawing type</param>
            <param name="outImage">The image with the keypoints drawn</param> 
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.DrawMatches(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray,Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType)">
            <summary>
            Draw the matched keypoints between the model image and the observered image.
            </summary>
            <param name="modelImage">The model image</param>
            <param name="modelKeypoints">The keypoints in the model image</param>
            <param name="observerdImage">The observed image</param>
            <param name="observedKeyPoints">The keypoints in the observed image</param>
            <param name="matchColor">The color for the match correspondence lines</param>
            <param name="singlePointColor">The color for highlighting the keypoints</param>
            <param name="mask">The mask for the matches. Use null for all matches.</param>
            <param name="flags">The drawing type</param>
            <param name="result">The image where model and observed image is displayed side by side. Matches are drawn as indicated by the flag</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.VoteForSizeAndOrientation(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.Matrix{System.Byte},System.Double,System.Int32)">
            <summary>
            Eliminate the matched features whose scale and rotation do not aggree with the majority's scale and rotation.
            </summary>
            <param name="rotationBins">The numbers of bins for rotation, a good value might be 20 (which means each bin covers 18 degree)</param>
            <param name="scaleIncrement">This determins the different in scale for neighbour hood bins, a good value might be 1.5 (which means matched features in bin i+1 is scaled 1.5 times larger than matched features in bin i</param>
            <param name="modelKeyPoints">The keypoints from the model image</param>
            <param name="observedKeyPoints">The keypoints from the observed image</param>
            <param name="mask">This is both input and output. This matrix indicates which row is valid for the matches.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
            <returns> The number of non-zero elements in the resulting mask</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.GetHomographyMatrixFromMatchedFeatures(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.Matrix{System.Byte},System.Double)">
            <summary>
            Recover the homography matrix using RANDSAC. If the matrix cannot be recovered, null is returned.
            </summary>
            <param name="model">The model keypoints</param>
            <param name="observed">The observed keypoints</param>
            <param name="ransacReprojThreshold">
            The maximum allowed reprojection error to treat a point pair as an inlier. 
            If srcPoints and dstPoints are measured in pixels, it usually makes sense to set this parameter somewhere in the range 1 to 10.
            </param>
            <param name="mask">
            The mask matrix of which the value might be modified by the function. 
            As input, if the value is 0, the corresponding match will be ignored when computing the homography matrix. 
            If the value is 1 and RANSAC determine the match is an outlier, the value will be set to 0.
            </param>
            <returns>The homography matrix, if it cannot be found, null is returned</returns>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.VoteForUniqueness(Emgu.CV.Util.VectorOfVectorOfDMatch,System.Double,Emgu.CV.Matrix{System.Byte})">
            <summary>
            Filter the matched Features, such that if a match is not unique, it is rejected.
            </summary>
            <param name="uniquenessThreshold">The distance different ratio which a match is consider unique, a good number will be 0.8</param>
            <param name="mask">This is both input and output. This matrix indicates which row is valid for the matches.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param> 
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType">
            <summary>
            Define the Keypoint draw type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.Default">
            <summary>
            Two source image, matches and single keypoints will be drawn.
            For each keypoint only the center point will be drawn (without
            the circle around keypoint with keypoint size and orientation).
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.NotDrawSinglePoints">
            <summary>
            Single keypoints will not be drawn.
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.DrawRichKeypoints">
            <summary>
            For each keypoint the circle around keypoint with keypoint size and
            orientation will be drawn.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.GFTTDetector">
            <summary>
             Wrapping class for feature detection using the goodFeaturesToTrack() function.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.GFTTDetector.#ctor(System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            Create a Good Feature to Track detector
            </summary>
            <remarks>The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). The next step is rejecting the corners with the minimal eigenvalue less than quality_level?max(eig_image(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features</remarks>
            <param name="maxCorners">The maximum number of features to be detected.</param>
            <param name="qualityLevel">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners.</param>
            <param name="minDistance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used.</param>
            <param name="blockSize">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function.</param>
            <param name="useHarrisDetector">If true, will use Harris corner detector.</param>
            <param name="k">K</param>
        </member>
        <member name="M:Emgu.CV.Features2D.GFTTDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.GFTTDetector.Emgu#CV#Features2D#IFeatureDetector#FeatureDetectorPtr">
            <summary>
            Get the feature detector. 
            </summary>
            <returns>The feature detector</returns>
        </member>
        <member name="T:Emgu.CV.Features2D.ImageFeature`1">
            <summary>
            An ImageFeature contains a keypoint and its descriptor
            </summary>
            <typeparam name="TDescriptor">The type of data used for the descriptor. Either float or Byte</typeparam>
        </member>
        <member name="M:Emgu.CV.Features2D.ImageFeature`1.ConvertFromRaw(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Matrix{`0})">
            <summary>
            Convert the raw keypoints and descriptors to ImageFeature
            </summary>
            <param name="keyPointsVec">The raw keypoints vector</param>
            <param name="descriptors">The raw descriptor matrix</param>
            <returns>An array of image features</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.ImageFeature`1.ConvertToRaw(Emgu.CV.Features2D.ImageFeature{`0}[],Emgu.CV.Util.VectorOfKeyPoint@,Emgu.CV.Matrix{`0}@)">
            <summary>
            Convert the image features to keypoint vector and descriptor matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.ImageFeature`1.Descriptor">
            <summary>
            The descriptor to the keypoint
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.ImageFeature`1.KeyPoint">
            <summary>
            The keypoint
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.KAZE">
            <summary>
            Wrapped KAZE detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.KAZE.#ctor(System.Boolean,System.Boolean,System.Single,System.Int32,System.Int32,Emgu.CV.Features2D.KAZE.Diffusivity)">
            <summary>
            Create KAZE using the specific values
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.KAZE.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.KAZE.Diffusivity">
            <summary>
            The diffusivity
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.PmG1">
            <summary>
            PM G1
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.PmG2">
            <summary>
            PM G2
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.Weickert">
            <summary>
            Weickert
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.Charbonnier">
            <summary>
            Charbonnier
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.MSERDetector">
            <summary>
            Wrapped CvMSERParams structure
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.MSERDetector.#ctor(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Create a MSER detector using the specific parameters
            </summary>
            <param name="delta">In the code, it compares (size_{i}-size_{i-delta})/size_{i-delta}</param>
            <param name="maxArea">Prune the area which bigger than max_area</param>
            <param name="minArea">Prune the area which smaller than min_area</param>
            <param name="maxVariation">Prune the area have similar size to its children</param>
            <param name="minDiversity">Trace back to cut off mser with diversity &lt; min_diversity</param>
            <param name="maxEvolution">For color image, the evolution steps</param>
            <param name="areaThreshold">The area threshold to cause re-initialize</param>
            <param name="minMargin">Ignore too small margin</param>
            <param name="edgeBlurSize">The aperture size for edge blur</param>
        </member>
        <member name="M:Emgu.CV.Features2D.MSERDetector.#ctor">
            <summary>
            Create the default MSER detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.MSERDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.MSERDetector.FeatureDetectorPtr">
            <summary>
            Get the feature detector. 
            </summary>
            <returns>The feature detector</returns>
        </member>
        <member name="T:Emgu.CV.Features2D.ORBDetector">
            <summary>
            Wrapped ORB detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.ORBDetector.#ctor(System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.Features2D.ORBDetector.ScoreType,System.Int32)">
            <summary>
            Create a ORBDetector using the specific values
            </summary>
            <param name="numberOfFeatures">The number of desired features. </param>
            <param name="scaleFactor">Coefficient by which we divide the dimensions from one scale pyramid level to the next.</param>
            <param name="nLevels">The number of levels in the scale pyramid. </param>
            <param name="firstLevel">The level at which the image is given. If 1, that means we will also look at the image.<paramref name="scaleFactor"/> times bigger</param>
            <param name="edgeThreshold">How far from the boundary the points should be.</param>
            <param name="WTK_A">How many random points are used to produce each cell of the descriptor (2, 3, 4 ...).</param>
            <param name="scoreType">Type of the score to use.</param>
            <param name="patchSize">Patch size.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.ORBDetector.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.ORBDetector.ScoreType">
            <summary>
            The score type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.ORBDetector.ScoreType.Harris">
            <summary>
            Harris
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.ORBDetector.ScoreType.Fast">
            <summary>
            Fast
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.SimpleBlobDetector">
            <summary>
            Simple Blob detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetector.#ctor">
            <summary>
            Create a simple blob detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetector.Emgu#CV#Features2D#IFeatureDetector#FeatureDetectorPtr">
            <summary>
            Get the feature detector. 
            </summary>
            <returns>The feature detector</returns>
        </member>
        <member name="T:Emgu.CV.Flann.CenterInitType">
            <summary>
            The Kmeans center initiation types
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Random">
            <summary>
            Random
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Gonzales">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Kmeanspp">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.Index">
            <summary>
            Flann index
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.Index.#ctor(Emgu.CV.IInputArray,Emgu.CV.Flann.IIndexParams)">
            <summary>
            Create a flann index
            </summary>
            <param name="values">A row by row matrix of descriptors</param>
            <param name="ip">The index parameter</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.KnnSearch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32)">
            <summary>
            Perform k-nearest-neighbours (KNN) search
            </summary>
            <param name="queries">A row by row matrix of descriptors to be query for nearest neighbours</param>
            <param name="indices">The result of the indices of the k-nearest neighbours</param>
            <param name="squareDistances">The square of the Eculidean distance between the neighbours</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="checks">The number of times the tree(s) in the index should be recursively traversed. A
            higher value for this parameter would give better search precision, but also take more
            time. If automatic configuration was used when the index was created, the number of
            checks required to achieve the specified precision was also computed, in which case
            this parameter is ignored </param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.RadiusSearch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Single,System.Int32,System.Int32)">
            <summary>
            Performs a radius nearest neighbor search for multiple query points
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="squareDistances">The square of the Eculidean distance between the neighbours</param>
            <param name="radius">The search radius</param>
            <param name="maxResults">The maximum number of results</param>
            <param name="checks">The number of times the tree(s) in the index should be recursively traversed. A
            higher value for this parameter would give better search precision, but also take more
            time. If automatic configuration was used when the index was created, the number of
            checks required to achieve the specified precision was also computed, in which case
            this parameter is ignored </param>
            <returns>The number of points in the search radius</returns>
        </member>
        <member name="M:Emgu.CV.Flann.Index.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Flann Index
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.Index3D">
            <summary>
            Create index for 3D points
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.#ctor(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Flann.IIndexParams)">
            <summary>
            Create a flann index for 3D points
            </summary>
            <param name="points">The IPosition3D array</param>
            <param name="ip">The index parameters</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.ApproximateNearestNeighbour(Emgu.CV.Structure.MCvPoint3D32f,System.Double@)">
            <summary>
            Find the approximate nearest position in 3D
            </summary>
            <param name="position">The position to start the search from</param>
            <param name="squareDist">The square distance of the nearest neighbour</param>
            <returns>The index with the nearest 3D position</returns>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.DisposeObject">
            <summary>
            Release the resource used by this object
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.LinearIndexParamses.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.KdTreeIndexParamses.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.LshIndexParamses.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.KMeansIndexParamses.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.CompositeIndexParamses.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.AutotunedIndexParamses.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.HierarchicalClusteringIndexParamses.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.SearchParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Geodetic.GeodeticCoordinate">
            <summary>
            A geodetic coordinate that is defined by its latitude, longitude and altitude
            </summary>
        </member>
        <member name="F:Emgu.CV.Geodetic.GeodeticCoordinate.Empty">
            <summary>
            Indicates the origin of the Geodetic Coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a geodetic coordinate using the specific values
            </summary>
            <param name="latitude">Latitude in radian</param>
            <param name="longitude">Longitude in radian</param>
            <param name="altitude">Altitude in meters</param>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Addition(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Compute the sum of two GeodeticCoordinates
            </summary>
            <param name="coor1">The first coordinate to be added</param>
            <param name="coor2">The second coordinate to be added</param>
            <returns>The sum of two GeodeticCoordinates</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Subtraction(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Compute <paramref name="coor1"/> - <paramref name="coor2"/>
            </summary>
            <param name="coor1">The first coordinate</param>
            <param name="coor2">The coordinate to be subtracted</param>
            <returns><paramref name="coor1"/> - <paramref name="coor2"/></returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Multiply(Emgu.CV.Geodetic.GeodeticCoordinate,System.Double)">
            <summary>
            Compute <paramref name="coor"/> * <paramref name="scale"/>
            </summary>
            <param name="coor">The coordinate</param>
            <param name="scale">The scale to be multiplied</param>
            <returns><paramref name="coor"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.Equals(Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Check if this Geodetic coordinate equals <paramref name="other"/>
            </summary>
            <param name="other">The other coordinate to be compared with</param>
            <returns>True if two coordinates equals</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.RadianToDegree(System.Double)">
            <summary>
            Convert radian to degree
            </summary>
            <param name="radian">radian</param>
            <returns>degree</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.DegreeToRadian(System.Double)">
            <summary>
            Convert degree to radian
            </summary>
            <param name="degree">degree</param>
            <returns>radian</returns>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Latitude">
            <summary>
            Latitude (phi) in radian
            </summary>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Longitude">
            <summary>
            Longitude (lambda) in radian
            </summary>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Altitude">
            <summary>
            Altitude (height) in meters
            </summary>
        </member>
        <member name="T:Emgu.CV.HOGDescriptor">
            <summary>
            A HOG descriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.#ctor">
            <summary>
            Create a new HOGDescriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.#ctor(System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Create a new HOGDescriptor using the specific parameters.
            </summary>
            <param name="blockSize">Block size in cells. Use (16, 16) for default.</param>
            <param name="cellSize">Cell size. Use (8, 8) for default.</param>
            <param name="blockStride">Block stride. Must be a multiple of cell size. Use (8,8) for default.</param>
            <param name="gammaCorrection">Do gamma correction preprocessing or not. Use true for default.</param>
            <param name="L2HysThreshold">L2-Hys normalization method shrinkage.</param>
            <param name="nbins">Number of bins.</param>
            <param name="winSigma">Gaussian smoothing window parameter.</param>
            <param name="winSize">Detection window size. Must be aligned to block size and block stride. Must match the size of the training image. Use (64, 128) for default.</param>
            <param name="derivAperture"></param>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Bgr,System.Byte},System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Create a new HOGDescriptor using the specific parameters.
            </summary>
            <param name="template">The template image to be detected.</param>
            <param name="blockSize">Block size in cells. Use (16, 16) for default.</param>
            <param name="cellSize">Cell size. Use (8, 8) for default.</param>
            <param name="blockStride">Block stride. Must be a multiple of cell size. Use (8,8) for default.</param>
            <param name="gammaCorrection">Do gamma correction preprocessing or not. Use true for default.</param>
            <param name="L2HysThreshold">L2-Hys normalization method shrinkage. Use 0.2 for default.</param>
            <param name="nbins">Number of bins. Use 9 for default.</param>
            <param name="winSigma">Gaussian smoothing window parameter. Use -1 for default. </param>
            <param name="derivAperture">Use 1 for default.</param>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Bgr,System.Byte})">
            <summary>
            Create a new HogDescriptor using the specific template and default parameters.
            </summary>
            <param name="template">The template image to be detected.</param>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.GetDefaultPeopleDetector">
            <summary>
            Return the default people detector
            </summary>
            <returns>The default people detector</returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.SetSVMDetector(System.Single[])">
            <summary>
            Set the SVM detector 
            </summary>
            <param name="detector">The SVM detector</param>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.DetectMultiScale(Emgu.CV.IInputArray,System.Double,System.Drawing.Size,System.Drawing.Size,System.Double,System.Double,System.Boolean)">
             <summary>
             Performs object detection with increasing detection window.
             </summary>
             <param name="image">The image to search in</param>
             <param name="hitThreshold">
             Threshold for the distance between features and SVM classifying plane.
             Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient).
             But if the free coefficient is omitted (which is allowed), you can specify it manually here.
            </param>
             <param name="winStride">Window stride. Must be a multiple of block stride.</param>
             <param name="padding"></param>
             <param name="scale">Coefficient of the detection window increase.</param>
             <param name="finalThreshold">After detection some objects could be covered by many rectangles. This coefficient regulates similarity threshold. 0 means don't perform grouping. Should be an integer if not using meanshift grouping. Use 2.0 for default</param>
             <param name="useMeanshiftGrouping">If true, it will use meanshift grouping.</param>
             <returns>The regions where positives are found</returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.Compute(Emgu.CV.IInputArray,System.Drawing.Size,System.Drawing.Size,System.Drawing.Point[])">
            <summary>
            
            </summary>
            <param name="image">The image</param>
            <param name="winStride">Window stride. Must be a multiple of block stride. Use Size.Empty for default</param>
            <param name="padding">Padding. Use Size.Empty for default</param>
            <param name="locations">Locations for the computation. Can be null if not needed</param>
            <returns>The descriptor vector</returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this HOGDescriptor
            </summary>
        </member>
        <member name="P:Emgu.CV.HOGDescriptor.DescriptorSize">
            <summary>
            Get the size of the descriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.IImageExtensions.ForEachDuplicateChannel``1(Emgu.CV.IImage,System.Func{Emgu.CV.IImage,System.Int32,``0})">
            <summary>
            Apply convertor and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <typeparam name="TReturn">The return type</typeparam>
            <param name="image">The source image</param>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.IImageExtensions.ForEachDuplicateChannel(Emgu.CV.IImage,System.Action{Emgu.CV.IImage,System.Int32})">
            <summary>
            Apply convertor and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <param name="image">The source image</param>
            <param name="action">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="T:Emgu.CV.Image`2">
            <summary>
            An Image is a wrapper to IplImage of OpenCV. 
            </summary>
            <typeparam name="TColor">Color type of this image (either Gray, Bgr, Bgra, Hsv, Hls, Lab, Luv, Xyz, Ycc, Rgb or Rbga)</typeparam>
            <typeparam name="TDepth">Depth of this image (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="F:Emgu.CV.Image`2._numberOfChannels">
            <summary>
            The dimension of color
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor">
            <summary>
            Create an empty Image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(`1[0:,0:,0:])">
            <summary>
            Create image from the specific multi-dimensional data, where the 1st dimesion is # of rows (height), the 2nd dimension is # cols (width) and the 3rd dimension is the channel
            </summary>
            <param name="data">The multi-dimensional data where the 1st dimension is # of rows (height), the 2nd dimension is # cols (width) and the 3rd dimension is the channel </param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create an Image from unmanaged data. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="stride">Size of aligned image row in bytes</param>
            <param name="scan0">Pointer to aligned image data, <b>where each row should be 4-align</b> </param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the scan0 parameter, however, the memory should not be released until the related Image is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.IntPtr)">
            <summary>
            Allocate the image from the image header. 
            </summary>
            <param name="ptr">This should be only a header to the image. When the image is disposed, the cvReleaseImageHeader will be called on the pointer.</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.String)">
            <summary>
            Read image from a file
            </summary>
            <param name="fileName">the name of the file that contains the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadFileUsingBitmap(System.IO.FileInfo)">
            <summary>
            Load the specific file using Bitmap
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageUsingOpenCV(System.IO.FileInfo)">
            <summary>
            Load the specific file using OpenCV
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Drawing.Bitmap)">
            <summary>
            Obtain the image from the specific Bitmap
            </summary>
            <param name="bmp">The bitmap which will be converted to the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a blank Image of the specified width and height. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Drawing.Size)">
            <summary>
            Create a blank Image of the specific size
            </summary>
            <param name="size">The size of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels of this image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Gray,`1}[])">
            <summary>
            Create a multi-channel image from multiple gray scale images
            </summary>
            <param name="channels">The image channels to be merged into a single image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.GetAverage">
            <summary>
            Get the average value on this image
            </summary>
            <returns>The average color of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetAverage(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Get the average value on this image, using the specific mask
            </summary>
            <param name="mask">The mask for find the average value</param>
            <returns>The average color of the masked area</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetSum">
            <summary>Get the sum for each color channel </summary>
            <returns>The sum for each color channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0)">
            <summary>
            Set every pixel of the image to the specific color 
            </summary>
            <param name="color">The color to be set</param>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Set every pixel of the image to the specific color, using a mask
            </summary>
            <param name="color">The color to be set</param>
            <param name="mask">The mask for setting color</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Copy the masked area of this image to destination
            </summary>
            <param name="dest">the destination to copy to</param>
            <param name="mask">the mask for copy</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
             Make a copy of the image using a mask, if ROI is set, only copy the ROI 
             </summary> 
             <param name="mask">the mask for coping</param>
            <returns> A copy of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(System.Drawing.Rectangle)">
            <summary>
            Make a copy of the specific ROI (Region of Interest) from the image
            </summary>
            <param name="roi">The roi to be copied</param>
            <returns>The roi region on the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Get a copy of the boxed region of the image
            </summary>
            <param name="box">The boxed region of the image</param>
            <returns>A copy of the boxed region of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy">
            <summary> Make a copy of the image, if ROI is set, only copy the ROI</summary>
            <returns> A copy of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.CopyBlank">
            <summary> 
            Create an image of the same size
            </summary>
            <remarks>The initial pixel in the image equals zero</remarks>
            <returns> The image of the same size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Clone">
            <summary>
            Make a clone of the current image. All image data as well as the COI and ROI are cloned
            </summary>
            <returns>A clone of the current image. All image data as well as the COI and ROI are cloned</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Get a subimage which image data is shared with the current image.
            </summary>
            <param name="rect">The rectangle area of the sub-image</param>
            <returns>A subimage which image data is shared with the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.Drawing.Rectangle,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw an Rectangle of the specific color and thickness </summary>
            <param name="rect"> The rectangle to be drawn</param>
            <param name="color"> The color of the rectangle </param>
            <param name="thickness"> If thickness is less than 1, the rectangle is filled up </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.Cross2DF,`0,System.Int32)">
            <summary> Draw a 2D Cross using the specific color and thickness </summary>
            <param name="cross"> The 2D Cross to be drawn</param>
            <param name="color"> The color of the cross </param>
            <param name="thickness"> Must be &gt; 0 </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.LineSegment2DF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a line segment using the specific color and thickness </summary>
            <param name="line"> The line segment to be drawn</param>
            <param name="color"> The color of the line segment </param>
            <param name="thickness"> The thickness of the line segment </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.LineSegment2D,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a line segment using the specific color and thickness </summary>
            <param name="line"> The line segment to be drawn</param>
            <param name="color"> The color of the line segment </param>
            <param name="thicknes"> The thickness of the line segment </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.IConvexPolygonF,`0,System.Int32)">
            <summary> Draw a convex polygon using the specific color and thickness </summary>
            <param name="polygon"> The convex polygon to be drawn</param>
            <param name="color"> The color of the triangle </param>
            <param name="thickness"> If thickness is less than 1, the triangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.FillConvexPoly(System.Drawing.Point[],`0,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Fill the convex polygon with the specific color
            </summary>
            <param name="pts">The array of points that define the convex polygon</param>
            <param name="color">The color to fill the polygon with</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DrawPolyline(System.Drawing.Point[],System.Boolean,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw the polyline defined by the array of 2D points
            </summary>
            <param name="pts">A polyline defined by its point</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DrawPolyline(System.Drawing.Point[][],System.Boolean,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw the polylines defined by the array of array of 2D points
            </summary>
            <param name="pts">An array of polylines each represented by an array of points</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.CircleF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be drawn</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.Ellipse,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a Ellipse of the specific color and thickness </summary>
            <param name="ellipse"> The ellipse to be draw</param>
            <param name="color"> The color of the ellipse </param>
            <param name="thickness"> If thickness is less than 1, the ellipse is filled up </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.IInputArray,System.Int32,`0,System.Int32,Emgu.CV.CvEnum.LineType,Emgu.CV.IInputArray,System.Int32,System.Drawing.Point)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours </param>
            <param name="maxLevel">Maximal level for drawn contours. If 0, only contour is drawn. If 1, the contour and all contours after it on the same level are drawn. If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level. </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrived in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.Drawing.Point[],`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Drawing.Point)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="contours">The input contour stored as a point vector.</param>
            <param name="color">Color of the contours </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrived in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughLinesBinary(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Apply Probabilistic Hough transform to find line segments.
            The current image must be a binary image (eg. the edges as a result of the Canny edge detector)
            </summary>
            <param name="rhoResolution">Distance resolution in pixel-related units.</param>
            <param name="thetaResolution">Angle resolution measured in radians</param>
            <param name="threshold">A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="minLineWidth">Minimum width of a line</param>
            <param name="gapBetweenLines">Minimum gap between lines</param>
            <returns>The line segments detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughLines(System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
             Apply Canny Edge Detector follows by Probabilistic Hough transform to find line segments in the image
            </summary>
            <param name="cannyThreshold"> The threshhold to find initial segments of strong edges</param>
            <param name="cannyThresholdLinking"> The threshold used for edge Linking</param>
            <param name="rhoResolution">Distance resolution in pixel-related units.</param>
            <param name="thetaResolution">Angle resolution measured in radians</param>
            <param name="threshold">A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="minLineWidth">Minimum width of a line</param>
            <param name="gapBetweenLines">Minimum gap between lines</param>
            <returns>The line segments detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughCircles(`0,`0,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            First apply Canny Edge Detector on the current image,
            then apply Hough transform to find circles
            </summary>
            <param name="cannyThreshold">The higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller).</param>
            <param name="accumulatorThreshold">Accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="minRadius">Minimal radius of the circles to search for</param>
            <param name="maxRadius">Maximal radius of the circles to search for</param>
            <param name="minDist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <returns>The circle detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.RoiParam(System.IntPtr,System.Int64@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Return parameters based on ROI
            </summary>
            <param name="ptr">The Pointer to the IplImage</param>
            <param name="start">The address of the pointer that point to the start of the Bytes taken into consideration ROI</param>
            <param name="elementCount">ROI.Width * ColorType.Dimension</param>
            <param name="byteWidth">The number of bytes in a row taken into consideration ROI</param>
            <param name="rows">The number of rows taken into consideration ROI</param>
            <param name="widthStep">The width step required to jump to the next row</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachChannel``1(System.Func{System.IntPtr,System.Int32,``0})">
            <summary>
            Apply convertor and compute result for each channel of the image.
            </summary>
            <remarks>
            For single channel image, apply converter directly.
            For multiple channel image, set the COI for the specific channel before appling the convertor
            </remarks>
            <typeparam name="TResult">The return type</typeparam>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachDuplicateChannel``1(System.Action{Emgu.CV.IImage,Emgu.CV.IImage,System.Int32},Emgu.CV.Image{`0,``0})">
            <summary>
            If the image has only one channel, apply the action directly on the IntPtr of this image and <paramref name="dest"/>,
            otherwise, make copy each channel of this image to a temperary one, apply action on it and another temperory image and copy the resulting image back to image2
            </summary>
            <typeparam name="TOtherDepth">The type of the depth of the <paramref name="dest"/> image</typeparam>
            <param name="act">The function which acepts the src IntPtr, dest IntPtr and index of the channel as input</param>
            <param name="dest">The destination image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Sobel(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the image derivative by convolving the image with the appropriate kernel
            The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative.
            </summary>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="apertureSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. In all cases except 1, aperture_size xaperture_size separable kernel will be used to calculate the derivative.</param>
            <returns>The result of the sobel edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Laplace(System.Int32)">
             <summary>
             Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator.
             Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            
             |0  1  0|
             |1 -4  1|
             |0  1  0|
             </summary>
             <param name="apertureSize">Aperture size </param>
             <returns>The Laplacian of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Canny(System.Double,System.Double)">
            <summary> Find the edges on this image and marked them in the returned image.</summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Canny(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary> Find the edges on this image and marked them in the returned image.</summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <param name="apertureSize">The aperture size, use 3 for default</param>
            <param name="l2Gradient">a flag, indicating whether a more accurate norm should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default norm is enough ( L2gradient=false ).</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.FindCornerSubPix(System.Drawing.PointF[][],System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="corners">Coordinates of the input corners, the values will be modified by this function call</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
            <returns>Refined corner coordinates</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MatchTemplate(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.TemplateMatchingType)">
            <summary>
            The function slids through image, compares overlapped patches of size wxh with templ using the specified method and return the comparison results 
            </summary>
            <param name="template">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <returns>The comparison result: width = this.Width - template.Width + 1; height = this.Height - template.Height + 1 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise AND operation with another image and return the result</summary>
            <param name="img2">The second image for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
            Perform an elementwise AND operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0)">
            <summary> Perform an binary AND operation with some color</summary>
            <param name="val">The color for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an binary AND operation with some color using a mask</summary>
            <param name="val">The color for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with another image, using a mask, and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0)">
            <summary> Perform an elementwise OR operation with some color</summary>
            <param name="val">The value for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with some color using a mask</summary>
            <param name="val">The color for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise XOR operation with another image and return the result</summary>
            <param name="img2">The second image for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perform an elementwise XOR operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns>The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0)">
            <summary> 
            Perform an binary XOR operation with some color
            </summary>
            <param name="val">The value for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perform an binary XOR operation with some color using a mask
            </summary>
            <param name="val">The color for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Not">
            <summary> 
            Compute the complement image
            </summary>
            <returns> The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise maximum value </summary>
            <param name="img2">The second image for the Max operation</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(System.Double)">
            <summary> Find the elementwise maximum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise minimum value </summary>
            <param name="img2">The second image for the Min operation</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(System.Double)">
            <summary> Find the elementwise minimum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(`0,`0)">
            <summary>Checks that image elements lie between two scalars</summary>
            <param name="lower"> The inclusive lower limit of color value</param>
            <param name="higher"> The inclusive upper limit of color value</param>
            <returns> res[i,j] = 255 if <paramref name="lower"/> &lt;= this[i,j] &lt;= <paramref name="higher"/>, 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>Checks that image elements lie between values defined by two images of same size and type</summary>
            <param name="lower"> The inclusive lower limit of color value</param>
            <param name="higher"> The inclusive upper limit of color value</param>
            <returns> res[i,j] = 255 if <paramref name="lower"/>[i,j] &lt;= this[i,j] &lt;= <paramref name="higher"/>[i,j], 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compare the current image with <paramref name="img2"/> and returns the comparison mask
            </summary>
            <param name="img2">The other image to compare with</param>
            <param name="cmpType">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(System.Double,Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compare the current image with <paramref name="value"/> and returns the comparison mask
            </summary>
            <param name="value">The value to compare with</param>
            <param name="comparisonType">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Equals(Emgu.CV.Image{`0,`1})">
            <summary>
            Compare two images, returns true if the each of the pixels are equal, false otherwise
            </summary>
            <param name="img2">The other image to compare with</param>
            <returns>true if the each of the pixels for the two images are equal, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GrabCut(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Use grabcut to perform background foreground segmentation.
            </summary>
            <param name="rect">The initial rectangle region for the foreground</param>
            <param name="iteration">The number of iterations to run GrabCut</param>
            <returns>The background foreground mask where 2 indicates background and 3 indicates foreground</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise subtract another image from the current image </summary>
            <param name="img2">The second image to be subtracted from the current image</param>
            <returns> The result of elementwise subtracting img2 from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Elementwise subtract another image from the current image, using a mask</summary>
            <param name="img2">The image to be subtracted from the current image</param>
            <param name="mask">The mask for the subtract operation</param>
            <returns> The result of elementwise subtrating img2 from the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(`0)">
            <summary> Elementwise subtract a color from the current image</summary>
            <param name="val">The color value to be subtracted from the current image</param>
            <returns> The result of elementwise subtracting color 'val' from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">the value which subtract this image</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            result = val - this, using a mask
            </summary>
            <param name="val">The value which subtract this image</param>
            <param name="mask">The mask for subtraction</param>
            <returns>val - this, with mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise add another image with the current image </summary>
            <param name="img2">The image to be added to the current image</param>
            <returns> The result of elementwise adding img2 to the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Elementwise add <paramref name="img2"/> with the current image, using a mask</summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">The mask for the add operation</param>
            <returns> The result of elementwise adding img2 to the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current image</summary>
            <param name="val">The color value to be added to the current image</param>
            <returns> The result of elementwise adding color <paramref name="val"/> from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> Elementwise multiply another image with the current image and the <paramref name="scale"/></summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <param name="scale">The scale to be multiplied</param>
            <returns> this .* img2 * scale </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise multiply <paramref name="img2"/> with the current image</summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <returns> this .* img2 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(System.Double)">
            <summary> Elementwise multiply the current image with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Accumulate(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Accumulate <paramref name="img2"/> to the current image using the specific mask
            </summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">the mask</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Accumulate(Emgu.CV.Image{`0,`1})">
            <summary>
            Accumulate <paramref name="img2"/> to the current image using the specific mask
            </summary>
            <param name="img2">The image to be added to the current image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AddWeighted(Emgu.CV.Image{`0,`1},System.Double,System.Double,System.Double)">
            <summary> 
            Return the weighted sum such that: res = this * alpha + img2 * beta + gamma
            </summary>
            <param name="img2">img2 in: res = this * alpha + img2 * beta + gamma </param>
            <param name="alpha">alpha in: res = this * alpha + img2 * beta + gamma</param>
            <param name="beta">beta in: res = this * alpha + img2 * beta + gamma</param>
            <param name="gamma">gamma in: res = this * alpha + img2 * beta + gamma</param>
            <returns>this * alpha + img2 * beta + gamma</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AccumulateWeighted(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> 
             Update Running Average. <i>this</i> = (1-alpha)*<i>this</i> + alpha*img
            </summary>
            <param name="img">Input image, 1- or 3-channel, Byte or Single (each channel of multi-channel image is processed independently). </param>
            <param name="alpha">the weight of <paramref name="img"/></param>
        </member>
        <member name="M:Emgu.CV.Image`2.AccumulateWeighted(Emgu.CV.Image{`0,`1},System.Double,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
             Update Running Average. <i>this</i> = (1-alpha)*<i>this</i> + alpha*img, using the mask
            </summary>
            <param name="img">Input image, 1- or 3-channel, Byte or Single (each channel of multi-channel image is processed independently). </param>
            <param name="alpha">The weight of <paramref name="img"/></param>
            <param name="mask">The mask for the running average</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(Emgu.CV.Image{`0,`1})">
            <summary> 
            Computes absolute different between <i>this</i> image and the other image
            </summary>
            <param name="img2">The other image to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(`0)">
            <summary> 
            Computes absolute different between <i>this</i> image and the specific color
            </summary>
            <param name="color">The color to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Pow(System.Double)">
            <summary>
            Raises every element of input array to p
            dst(I)=src(I)^p, if p is integer
            dst(I)=abs(src(I))^p, otherwise
            </summary>
            <param name="power">The exponent of power</param>
            <returns>The power image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Exp">
            <summary>
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            </summary>
            <remarks>Maximum relative error is ~7e-6. Currently, the function converts denormalized values to zeros on output.</remarks>
            <returns>The exponent image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Log">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array
            </summary>
            <returns>Natural logarithm of absolute value of every element of input array</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sample(Emgu.CV.Structure.LineSegment2D)">
            <summary> Sample the pixel values on the specific line segment </summary>
            <param name="line"> The line to obtain samples</param>
            <returns>The values on the (Eight-connected) line </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sample(Emgu.CV.Structure.LineSegment2D,Emgu.CV.CvEnum.Connectivity)">
            <summary>
            Sample the pixel values on the specific line segment
            </summary>
            <param name="line">The line to obtain samples</param>
            <param name="type">The sampling type</param>
            <returns>The values on the line, the first dimension is the index of the point, the second dimension is the index of color channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,Emgu.CV.CvEnum.Inter)">
            <summary>
            Scale the image to the specific size 
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="interpolationType">The type of interpolation</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,System.Boolean)">
            <summary>
            Scale the image to the specific size
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="interpolationType">The type of interpolation</param>
            <param name="preserveScale">if true, the scale is preservered and the resulting image has maximum width(height) possible that is &lt;= <paramref name="width"/> (<paramref name="height"/>), if false, this function is equaivalent to Resize(int width, int height)</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Double,Emgu.CV.CvEnum.Inter)">
            <summary>
            Scale the image to the specific size: width *= scale; height *= scale  
            </summary>
            <param name="scale">The scale to resize</param>
            <param name="interpolationType">The type of interpolation</param>
            <returns>The scaled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0)">
            <summary>
            Rotate the image the specified angle cropping the result to the original size
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>   
            <returns>The image rotates by the specific angle</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpAffine(Emgu.CV.Mat,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpAffine(Emgu.CV.Mat,System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="width">The width of the resulting image</param>
            <param name="height">the height of the resulting image</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpPerspective``1(Emgu.CV.Matrix{``0},Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpPerspective``1(Emgu.CV.Matrix{``0},System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="width">The width of the resulting image</param>
            <param name="height">the height of the resulting image</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderType">Border type</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0,System.Boolean)">
            <summary>
            Rotate this image the specified <paramref name="angle"/>
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,System.Drawing.PointF,Emgu.CV.CvEnum.Inter,`0,System.Boolean)">
            <summary>
            Rotate this image the specified <paramref name="angle"/>
            </summary>
            <param name="angle">The angle of rotation in degrees. Positive means clockwise.</param>
            <param name="background">The color with wich to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <param name="center">The center of rotation</param>
            <param name="interpolationMethod">The intepolation method</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.LogPolar(System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
             Convert the image to log polar, simulating the human foveal vision
             </summary>
             <param name="center">The transformation center, where the output precision is maximal</param>
             <param name="magnitude">Magnitude scale parameter</param>
             <param name="interpolationType">interpolation type</param>
             <param name="warpType">Warp type</param>
             <returns>The converted image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2">
            <summary> Convert the current image to the specific color and depth </summary>
            <typeparam name="TOtherColor"> The type of color to be converted to </typeparam>
            <typeparam name="TOtherDepth"> The type of pixel depth to be converted to </typeparam>
            <returns> Image of the specific color and depth </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertFrom``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <typeparam name="TSrcColor">The color type of the source image</typeparam>
            <typeparam name="TSrcDepth">The color depth of the source image</typeparam>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertFrom(Emgu.CV.Mat)">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertScale``1(System.Double,System.Double)">
            <summary> Convert the current image to the specific depth, at the same time scale and shift the values of the pixel</summary>
            <param name="scale"> The value to be multipled with the pixel </param>
            <param name="shift"> The value to be added to the pixel</param>
             <typeparam name="TOtherDepth"> The type of depth to convert to</typeparam>
            <returns> Image of the specific depth, val = val * scale + shift </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.CopyFromBitmap(System.Drawing.Bitmap)">
            <summary>
            Utility function for Bitmap Set property
            </summary>
            <param name="bmp"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.ToBitmap">
            <summary> 
            Convert this image into Bitmap, the pixel values are copied over to the Bitmap
            </summary>
            <remarks> For better performance on Image&lt;Gray, Byte&gt; and Image&lt;Bgr, Byte&gt;, consider using the Bitmap property </remarks>
            <returns> This image in Bitmap format, the pixel data are copied over to the Bitmap</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ToBitmap(System.Int32,System.Int32)">
            <summary> Create a Bitmap image of certain size</summary>
            <param name="width">The width of the bitmap</param>
            <param name="height"> The height of the bitmap</param>
            <returns> This image in Bitmap format of the specific size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrDown">
            <summary>
             Performs downsampling step of Gaussian pyramid decomposition. 
             First it convolves <i>this</i> image with the specified filter and then downsamples the image 
             by rejecting even rows and columns.
            </summary>
            <returns> The downsampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrUp">
            <summary>
             Performs up-sampling step of Gaussian pyramid decomposition. 
             First it upsamples <i>this</i> image by injecting even zero rows and columns and then convolves 
             result with the specified filter multiplied by 4 for interpolation. 
             So the resulting image is four times larger than the source image.
            </summary>
            <returns> The upsampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.BuildPyramid(System.Int32)">
            <summary>
            Compute the image pyramid
            </summary>
            <param name="maxLevel">The number of level's for the pyramid; Level 0 referes to the current image, level n is computed by calling the PyrDown() function on level n-1</param>
            <returns>The image pyramid</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InPaint(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Double)">
            <summary> Use inpaint to recover the intensity of the pixels which location defined by <paramref>mask</paramref> on <i>this</i> image </summary>
            <param name="mask">The inpainting mask. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="radius">The radius of circular neighborhood of each point inpainted that is considered by the algorithm</param>
            <returns> The inpainted image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MorphologyEx(Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Perform advanced morphological transformations using erosion and dilation as basic operations.
            </summary>
            <param name="kernel">Structuring element</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="operation">Type of morphological operation</param>
            <param name="iterations">Number of times erosion and dilation are applied</param>
            <param name="borderType">Border type</param>
            <param name="borderValue">Border value</param>
            <returns>The result of the morphological operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._MorphologyEx(Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Perform inplace advanced morphological transformations using erosion and dilation as basic operations.
            </summary>
            <param name="kernel">Structuring element</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="operation">Type of morphological operation</param>
            <param name="iterations">Number of times erosion and dilation are applied</param>
            <param name="borderType">Border type</param>
            <param name="borderValue">Border value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image using a 3x3 rectangular structuring element.
            Erosion are applied several (iterations) times
            </summary>
            <param name="iterations">The number of erode iterations</param>
            <returns> The eroded image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image using a 3x3 rectangular structuring element.
            Dilation are applied several (iterations) times
            </summary>
            <param name="iterations">The number of dilate iterations</param>
            <returns> The dialated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Erosion are applied several (iterations) times
            </summary>
            <param name="iterations">The number of erode iterations</param>
        </member>
        <member name="M:Emgu.CV.Image`2._Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Dilation are applied several (iterations) times
            </summary>
            <param name="iterations">The number of dilate iterations</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Action(System.Action{`1})">
            <summary> 
            perform an generic action based on each element of the image
            </summary>
            <param name="action">The action to be applied to each element of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Action``1(Emgu.CV.Image{`0,``0},System.Action{`1,``0})">
            <summary>
            Perform an generic operation based on the elements of the two images
            </summary>
            <typeparam name="TOtherDepth">The depth of the second image</typeparam>
            <param name="img2">The second image to perform action on</param>
            <param name="action">An action such that the first parameter is the a single channel of a pixel from the first image, the second parameter is the corresponding channel of the correspondind pixel from the second image </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Func{`1,System.Int32,System.Int32,``0})">
            <summary> 
            Compute the element of a new image based on the value as well as the x and y positions of each pixel on the image
            </summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Converter{`1,``0})">
            <summary> Compute the element of the new image based on element of this image</summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2(Emgu.CV.Image{`0,``0},System.Func{`1,``0,``1})">
            <summary> Compute the element of the new image based on the elements of the two image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``3(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},System.Func{`1,``0,``1,``2})">
            <summary> Compute the element of the new image based on the elements of the three image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``4(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},Emgu.CV.Image{`0,``2},System.Func{`1,``0,``1,``2,``3})">
            <summary> Compute the element of the new image based on the elements of the four image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.DisposeObject">
            <summary>
            Release all unmanaged memory associate with the image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation on the two images
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="img2">The second image to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <param name="img1">The first image to apply bitwise OR operation</param>
            <param name="img2">The second image to apply bitwise OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(System.Double,Emgu.CV.Image{`0,`1})">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},`0)">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(`0,Emgu.CV.Image{`0,`1})">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_OnesComplement(Emgu.CV.Image{`0,`1})">
            <summary>Compute the complement image</summary>
            <param name="image">The image to be inverted</param>
            <returns>The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="img2"/>
            </summary>
            <param name="img1">The first image to be added</param>
            <param name="img2">The second image to be added</param>
            <returns>The sum of the two images</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="val"/>
            </summary>
            <param name="img1">The image to be added</param>
            <param name="val">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image1">The image to be subtracted</param>
            <param name="image2">The second image to be subtracted from <paramref name="image1"/></param>
            <returns> The result of elementwise subtracting img2 from <paramref name="image1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> The result of elementwise subtracting <paramred name="val"/> from <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> <paramred name="val"/> - <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            <paramred name="val"/> - <paramref name="image"/>
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramred name="val"/> - <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="image"/> - <paramred name="val"/>   </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="image"/> * <paramref name="scale"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="image"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/>*<paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="scale"/>*<paramref name="image"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},Emgu.CV.ConvolutionKernelF)">
            <summary>
            Perform the convolution with <paramref name="kernel"/> on <paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="kernel">The kernel</param>
            <returns>Result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="image"/> / <paramref name="scale"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The division scale</param>
            <returns><paramref name="image"/> / <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/> / <paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The scale</param>
            <returns><paramref name="scale"/> / <paramref name="image"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBlur(System.Int32,System.Int32)">
            <summary>
            Summation over a pixel param1 x param2 neighborhood with subsequent scaling by 1/(param1 x param2)
            </summary>
            <param name="width">The width of the window</param>
            <param name="height">The height of the window</param>
            <returns>The result of blur</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBlur(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Summation over a pixel param1 x param2 neighborhood. If scale is true, the result is subsequent scaled by 1/(param1 x param2)
            </summary>
            <param name="width">The width of the window</param>
            <param name="height">The height of the window</param>
            <param name="scale">If true, the result is subsequent scaled by 1/(param1 x param2)</param>
            <returns>The result of blur</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothMedian(System.Int32)">
            <summary>
            Finding median of <paramref name="size"/>x<paramref name="size"/> neighborhood 
            </summary>
            <param name="size">The size (width &amp; height) of the window</param>
            <returns>The result of mediam smooth</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBilatral(System.Int32,System.Int32,System.Int32)">
            <summary>
            Applying bilateral 3x3 filtering
            </summary>
            <param name="colorSigma">Color sigma</param>
            <param name="spaceSigma">Space sigma</param>
            <param name="kernelSize">The size of the bilatral kernel</param>
            <returns>The result of bilateral smooth</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothGaussian(System.Int32)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref name="kernelSize"/> x <paramref name="kernelSize"/>)</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothGaussian(System.Int32,System.Int32,System.Double,System.Double)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma1"> The standard deviation of the Gaussian kernel in the horizontal dimwnsion</param>
            <param name="sigma2"> The standard deviation of the Gaussian kernel in the vertical dimwnsion</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._SmoothGaussian(System.Int32)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref name="kernelSize"/> x <paramref name="kernelSize"/>)</param>
        </member>
        <member name="M:Emgu.CV.Image`2._SmoothGaussian(System.Int32,System.Int32,System.Double,System.Double)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma1"> The standard deviation of the Gaussian kernel in the horizontal dimwnsion</param>
            <param name="sigma2"> The standard deviation of the Gaussian kernel in the vertical dimwnsion</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convolution(Emgu.CV.ConvolutionKernelF)">
            <summary> 
            Performs a convolution using the specific <paramref name="kernel"/> 
            </summary>
            <param name="kernel">The convolution kernel</param>
            <returns>The result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral">
            <summary>
            Calculates integral images for the source image
            </summary>
            <returns>The integral image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral(Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@)">
            <summary>
            Calculates integral images for the source image
            </summary>
            <param name="sum">The integral image</param>
            <param name="squareSum">The integral image for squared pixel values</param>
            <returns>The integral image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral(Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@)">
            <summary>
            Calculates one or more integral images for the source image
            </summary>
            <param name="sum">The integral image</param>
            <param name="squareSum">The integral image for squared pixel values</param>
            <param name="titledSum">The integral for the image rotated by 45 degrees</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdAdaptive(`0,Emgu.CV.CvEnum.AdaptiveThresholdType,Emgu.CV.CvEnum.ThresholdType,System.Int32,`0)">
            <summary>
            Transforms grayscale image to binary image. 
            Threshold calculated individually for each pixel. 
            For the method CV_ADAPTIVE_THRESH_MEAN_C it is a mean of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel
            neighborhood, subtracted by param1. 
            For the method CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel neighborhood, subtracted by param1.
            </summary>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="adaptiveType">Adaptive_method </param>
            <param name="thresholdType">Thresholding type. must be one of CV_THRESH_BINARY, CV_THRESH_BINARY_INV  </param>
            <param name="blockSize">The size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, ... </param>
            <param name="param1">Constant subtracted from mean or weighted mean. It may be negative. </param>
            <returns>The result of the adaptive threshold</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBase(Emgu.CV.Image{`0,`1},`0,`0,Emgu.CV.CvEnum.ThresholdType)">
            <summary> 
            the base threshold method shared by public threshold functions 
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZero(`0)">
            <summary> Threshold the image such that: dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <returns> dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZeroInv(`0)">
            <summary> 
            Threshold the image such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <returns>The image such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdTrunc(`0)">
            <summary>
            Threshold the image such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <returns>The image such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinary(`0,`0)">
            <summary> 
            Threshold the image such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise 
            </summary>
            <returns>The image such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
            <returns>The image such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZero(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZeroInv(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdTrunc(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinary(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AvgSdv(`0@,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <param name="average">The avg color</param>
            <param name="sdv">The standard deviation for each channel</param>
            <param name="mask">The operation mask</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AvgSdv(`0@,Emgu.CV.Structure.MCvScalar@)">
            <summary>
            Calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <param name="avg">The avg color</param>
            <param name="sdv">The standard deviation for each channel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.CountNonzero">
            <summary>
            Count the non Zero elements for each channel
            </summary>
            <returns>Count the non Zero elements for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Flip(Emgu.CV.CvEnum.FlipType)">
            <summary> Return a flipped copy of the current image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2._Flip(Emgu.CV.CvEnum.FlipType)">
            <summary> Inplace flip the image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConcateVertical(Emgu.CV.Image{`0,`1})">
            <summary>
            Concate the current image with another image vertically.
            </summary>
            <param name="otherImage">The other image to concate</param>
            <returns>A new image that is the vertical concatening of this image and <paramref name="otherImage"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConcateHorizontal(Emgu.CV.Image{`0,`1})">
            <summary>
            Concate the current image with another image horizontally. 
            </summary>
            <param name="otherImage">The other image to concate</param>
            <returns>A new image that is the horizontal concatening of this image and <paramref name="otherImage"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetMoments(System.Boolean)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characteristics including 7 Hu invariants.
            </summary>
            <param name="binary">If the flag is true, all the zero pixel values are treated as zeroes, all the others are treated as 1's</param>
            <returns>spatial and central moments up to the third order</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._GammaCorrect(System.Double)">
            <summary>
            Gamma corrects this image inplace. The image must have a depth type of Byte.
            </summary>
            <param name="gamma">The gamma value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.Image`2._EqualizeHist">
            <summary>
            The algorithm inplace normalizes brightness and increases contrast of the image.
            For color images, a HSV representation of the image is first obtained and the V (value) channel is histogram normalized
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageFromMat(Emgu.CV.Mat)">
            <summary>
            This function load the image data from Mat
            </summary>
            <param name="mat">The Mat</param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageFromIplImagePtr(System.IntPtr)">
            <summary>
            This function load the image data from the iplImage pointer
            </summary>
            <param name="iplImage">The pointer to the iplImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.FromIplImagePtr(System.IntPtr)">
            <summary>
            Get the managed image from an unmanaged IplImagePointer
            </summary>
            <param name="iplImage">The pointer to the iplImage</param>
            <returns>The managed image from the iplImage pointer</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ToJpegData(System.Int32)">
            <summary>
            Get the jpeg representation of the image
            </summary>
            <returns>An byte array that contains the image as jpeg data</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Data">
            <summary>
            Get or Set the data for this matrix. The Get function has O(1) complexity. The Set function make a copy of the data
            </summary>
            <remarks>
            If the image contains Byte and width is not a multiple of 4. The second dimension of the array might be larger than the Width of this image.  
            This is necessary since the length of a row need to be 4 align for OpenCV optimization. 
            The Set function always make a copy of the specific value. If the image contains Byte and width is not a multiple of 4. The second dimension of the array created might be larger than the Width of this image.  
            </remarks>
        </member>
        <member name="P:Emgu.CV.Image`2.MIplImage">
            <summary>
            The IplImage structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ROI">
            <summary> 
             Get or Set the region of interest for this image. To clear the ROI, set it to System.Drawing.Rectangle.Empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.NumberOfChannels">
            <summary>
            Get the number of channels for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.CvDepth">
            <summary>
            Get the equivalent opencv depth type for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.IsROISet">
            <summary> 
            Indicates if the region of interest has been set
            </summary> 
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32)">
            <summary>
            Get or Set the specific channel of the current image.
            For Get operation, a copy of the specific channel is returned.
            For Set operation, the specific channel is copied to this image.
            </summary>
            <param name="channel">The channel to get from the current image, zero based index</param>
            <returns>The specific channel of the current image</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the color in the <paramref name="row"/>th row (y direction) and <paramref name="column"/>th column (x direction)
            </summary>
            <param name="row">The zero-based row (y direction) of the pixel </param>
            <param name="column">The zero-based column (x direction) of the pixel</param>
            <returns>The color in the specific <paramref name="row"/> and <paramref name="column"/></returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Drawing.Point)">
            <summary>
            Get or Set the color in the <paramref name="location"/>
            </summary>
            <param name="location">the location of the pixel </param>
            <returns>the color in the <paramref name="location"/></returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Bitmap">
            <summary>
            The Get property provide a more efficient way to convert Image&lt;Gray, Byte&gt;, Image&lt;Bgr, Byte&gt; and Image&lt;Bgra, Byte&gt; into Bitmap
            such that the image data is <b>shared</b> with Bitmap. 
            If you change the pixel value on the Bitmap, you change the pixel values on the Image object as well!
            For other types of image this property has the same effect as ToBitmap()
            <b>Take extra caution not to use the Bitmap after the Image object is disposed</b>
            The Set property convert the bitmap to this Image type.
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Size">
            <summary> 
             Get the size of the array
            </summary>
        </member>
        <member name="T:Emgu.CV.ImageConstants">
            <summary>
            Constants used by the image class
            </summary>
        </member>
        <member name="F:Emgu.CV.ImageConstants.RoiOffset">
            <summary>
            Offset of roi
            </summary>
        </member>
        <member name="T:Emgu.CV.IStereoMatcher">
            <summary>
            The stereo matcher interface
            </summary>
        </member>
        <member name="P:Emgu.CV.IStereoMatcher.StereoMatcherPtr">
            <summary>
            Pointer to the stereo matcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Kalman">
            <summary>
            Kalman Filter 
            </summary>
        </member>
        <member name="M:Emgu.CV.Kalman.#ctor(Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single})">
            <summary>
            Create a Kalman Filter using the specific values
            </summary>
            <param name="initialState">The m x 1 matrix</param>
            <param name="transitionMatrix">The m x m matrix (A) </param>
            <param name="controlMatrix">The m x n matrix (B)</param>
            <param name="measurementMatrix">The n x m matrix (H)</param>
            <param name="processNoiseCovarianceMatrix">The n x n matrix (Q)</param>
            <param name="measurementNoiseCovarianceMatrix">The m x m matrix (R)</param>
        </member>
        <member name="M:Emgu.CV.Kalman.#ctor(Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single})">
            <summary>
            Create a Kalman Filter using the specific values
            </summary>
            <param name="initialState">The m x 1 matrix</param>
            <param name="transitionMatrix">The m x m matrix (A) </param>
            <param name="measurementMatrix">The n x m matrix (H)</param>
            <param name="processNoiseCovarianceMatrix">The n x n matrix (Q)</param>
            <param name="measurementNoiseCovarianceMatrix">The m x m matrix (R)</param>
        </member>
        <member name="M:Emgu.CV.Kalman.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocates CvKalman and all its matrices and initializes them somehow. 
            </summary>
            <param name="dynamParams">dimensionality of the state vector</param>
            <param name="measureParams">dimensionality of the measurement vector </param>
            <param name="controlParams">dimensionality of the control vector </param>
        </member>
        <member name="M:Emgu.CV.Kalman.Predict(Emgu.CV.Matrix{System.Single})">
            <summary>
            Estimates the subsequent stochastic model state by its current state and stores it at PredictedState
            </summary>
            <param name="control">the control vector</param>
            <returns>The predicted state</returns>
        </member>
        <member name="M:Emgu.CV.Kalman.Correct(Emgu.CV.Matrix{System.Single})">
            <summary>
            Adjusts stochastic model state on the basis of the given measurement of the model state
            </summary>
            <remarks>The function stores adjusted state at kalman->state_post and returns it on output</remarks>
            <param name="measurement">The measurement data</param>
            <returns>The corrected state</returns>
        </member>
        <member name="M:Emgu.CV.Kalman.Predict">
            <summary>
            Estimates the subsequent stochastic model state by its current state
            </summary>
            <returns>The predicted state</returns>
        </member>
        <member name="M:Emgu.CV.Kalman.DisposeObject">
            <summary>
            Release unmanaged resource
            </summary>
        </member>
        <member name="M:Emgu.CV.Kalman.ReleaseManagedResources">
            <summary>
            Release all the matrix associated to this object
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.MCvKalman">
            <summary>
            Get the MCvKalman structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.PredictedState">
            <summary>
            Get or Set the Predicted State
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.CorrectedState">
            <summary>
            Get or Set the Corrected State
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.MeasurementMatrix">
            <summary>
            Get or Set the measurement matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.TransitionMatrix">
            <summary>
            Get or Set the state transition matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.ProcessNoiseCovariance">
            <summary>
            Get or Set the process noise covariance matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.MeasurementNoiseCovariance">
            <summary>
            Get or Set the measurement noise covariance matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.ErrorCovariancePost">
            <summary>
            Get or Set the posteriori error estimate covariance matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.ErrorCovariancePre">
            <summary>
            Get or Set the prior error convariance matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.ControlMatrix">
            <summary>
            Get or Set the control matrix 
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.Gain">
            <summary>
            Get or Set the Kalman Gain
            </summary>
        </member>
        <member name="T:Emgu.CV.Map`2">
            <summary>
            A Map is similar to an Image, except that the location of the pixels is defined by 
            its area and resolution
            </summary>
            <typeparam name="TColor">The color of this map</typeparam>
            <typeparam name="TDepth">The depth of this map</typeparam>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Drawing.RectangleF,System.Drawing.PointF,`0)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle.
            </summary>
            <param name="area"></param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
            <param name="color"> The initial color of the map</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Drawing.RectangleF,System.Drawing.PointF)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle. The initial value of the map is 0.0
            </summary>
            <param name="area"></param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPointToImagePoint(Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPointToImagePoint(System.Drawing.PointF)">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Map`2.ImagePointToMapPoint(System.Drawing.Point)">
            <summary>
            Map an image point to a Map point
            </summary>
            <param name="pt">The point on image</param>
            <returns>The point on map</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.Copy(System.Drawing.RectangleF)">
            <summary>
            Get a copy of the map in the specific area
            </summary>
            <param name="area">the area of the map to be retrieve</param>
            <returns>The area of the map</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(System.Drawing.RectangleF,`0,System.Int32)">
            <summary>
            Draw a rectangle in the map
            </summary>
            <param name="rect">The rectangle to draw</param>
            <param name="color">The color for the rectangle</param>
            <param name="thickness">The thickness of the rectangle, any value less than or equal to 0 will result in a filled rectangle</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.Structure.LineSegment2DF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw a line segment in the map
            </summary>
            <param name="line">The line to be draw</param>
            <param name="color">The color for the line</param>
            <param name="thickness">The thickness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.Structure.CircleF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be drawn</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.IConvexPolygonF,`0,System.Int32)">
            <summary> Draw a convex polygon of the specific color and thickness </summary>
            <param name="polygon"> The convex polygon to be drawn</param>
            <param name="color"> The color of the convex polygon </param>
            <param name="thickness"> If thickness is less than 1, the triangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.Map`2.DrawPolyline(System.Drawing.PointF[],System.Boolean,`0,System.Int32)">
            <summary>
            Draw the polyline defined by the array of 2D points
            </summary>
            <param name="pts">the points that defines the poly line</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Map`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="P:Emgu.CV.Map`2.Area">
            <summary>
            Get the area of this map as a rectangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Map`2.Resolution">
            <summary>
            Get the resolution of this map as a 2D point
            </summary>
        </member>
        <member name="P:Emgu.CV.Map`2.ROI">
            <summary> 
             Get or Set the region of interest for this map. To clear the ROI, set it to System.Drawing.RectangleF.Empty
            </summary>
        </member>
        <member name="T:Emgu.CV.MatND`1">
            <summary>
            A MatND is a wrapper to cvMatND of OpenCV. 
            </summary>
            <typeparam name="TDepth">The type of depth</typeparam>
        </member>
        <member name="M:Emgu.CV.MatND`1.#ctor(System.Int32[])">
            <summary>
            Create a N-dimensional matrix 
            </summary>
            <param name="sizes">The size for each dimension</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            This function is not implemented for MatND
            </summary>
            <param name="rows">Not implemented</param>
            <param name="cols">Not implemented</param>
            <param name="numberOfChannels">Not implemented</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.DisposeObject">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.MatND`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Not Implemented
            </summary>
            <param name="reader">The XmlReader</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Not Implemented
            </summary>
            <param name="writer">The XmlWriter</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.Convert``1">
            <summary>
            Convert this matrix to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <returns>Matrix of different depth</returns>
        </member>
        <member name="M:Emgu.CV.MatND`1.Equals(Emgu.CV.MatND{`0})">
            <summary>
            Check if the two MatND are equal
            </summary>
            <param name="other">The other MatND to compares to</param>
            <returns>True if the two MatND equals</returns>
        </member>
        <member name="P:Emgu.CV.MatND`1.NumberOfChannels">
            <summary>
            This function is not implemented for MatND
            </summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.CvDepth">
            <summary> Get the depth representation for openCV</summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.MCvMatND">
            <summary>
            The MCvMatND structure
            </summary>
        </member>
        <member name="T:Emgu.CV.MemStorage">
            <summary>
            A MemStorage is a wrapper to cvMemStorage of OpenCV. 
            </summary>
        </member>
        <member name="M:Emgu.CV.MemStorage.#ctor">
            <summary>
            Create a OpenCV MemStorage
            </summary>
        </member>
        <member name="M:Emgu.CV.MemStorage.Clear">
            <summary>
            Resets the top (free space boundary) of the storage to the very beginning. This function does not deallocate any memory. If the storage has a parent, the function returns all blocks to the parent
            </summary>
        </member>
        <member name="M:Emgu.CV.MemStorage.CreateChildMemStorage">
            <summary>
            Creates a child memory storage that is similar to simple memory storage except for the differences in the memory allocation/deallocation mechanism. When a child storage needs a new block to add to the block list, it tries to get this block from the parent. The first unoccupied parent block available is taken and excluded from the parent block list. If no blocks are available, the parent either allocates a block or borrows one from its own parent, if any. In other words, the chain, or a more complex structure, of memory storages where every storage is a child/parent of another is possible. When a child storage is released or even cleared, it returns all blocks to the parent. In other aspects, the child storage is the same as the simple storage
            </summary>
            <returns>Child MemStorage</returns>
        </member>
        <member name="M:Emgu.CV.MemStorage.DisposeObject">
            <summary>
            Release the storage
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeExposures">
            <summary>
            The base class algorithms that can merge exposure sequence to a single image.
            </summary>
        </member>
        <member name="F:Emgu.CV.MergeExposures._mergeExposuresPtr">
            <summary>
            The pointer to the unmanaged MergeExposure object
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeExposures.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Merges images.
            </summary>
            <param name="src">Vector of input images</param>
            <param name="dst">Result image</param>
            <param name="times">Vector of exposure time values for each image</param>
            <param name="response">256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images.</param>
        </member>
        <member name="T:Emgu.CV.MotionHistory">
            <summary>
            The motion history class
            </summary>
            <remarks>
            For help on using this class, take a look at the Motion Detection example
            </remarks>
        </member>
        <member name="M:Emgu.CV.MotionHistory.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a motion history object
            </summary>
            <param name="mhiDuration">In second, the duration of motion history you wants to keep</param>
            <param name="maxTimeDelta">In second. Any change happens between a time interval greater than this will not be considerred</param>
            <param name="minTimeDelta">In second. Any change happens between a time interval smaller than this will not be considerred.</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.#ctor(System.Double,System.Double,System.Double,System.DateTime)">
            <summary>
            Create a motion history object
            </summary>
            <param name="mhiDuration">In second, the duration of motion history you wants to keep</param>
            <param name="maxTimeDelta">In second. Any change happens between a time interval larger than this will not be considerred</param>
            <param name="minTimeDelta">In second. Any change happens between a time interval smaller than this will not be considerred.</param>
            <param name="startTime">The start time of the motion history</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.Update(Emgu.CV.Mat)">
            <summary>
            Update the motion history with the specific image and current timestamp
            </summary>
            <param name="image">The image to be added to history</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.Update(Emgu.CV.Mat,System.DateTime)">
            <summary>
            Update the motion history with the specific image and the specific timestamp
            </summary>
            <param name="foregroundMask">The foreground of the image to be added to history</param>
            <param name="timestamp">The time when the image is captured</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.GetMotionComponents(Emgu.CV.IOutputArray,Emgu.CV.Util.VectorOfRect)">
            <summary>
            Get a sequence of motion component
            </summary>
            <returns>A sequence of motion components</returns>
        </member>
        <member name="M:Emgu.CV.MotionHistory.MotionInfo(Emgu.CV.Mat,System.Drawing.Rectangle,System.Double@,System.Double@)">
            <summary>
            Given a rectangle area of the motion, output the angle of the motion and the number of pixels that are considered to be motion pixel 
            </summary>
            <param name="motionRectangle">The rectangle area of the motion</param>
            <param name="angle">The orientation of the motion</param>
            <param name="motionPixelCount">Number of motion pixels within silhouette ROI</param>
            <param name="forgroundMask">The foreground mask used to calculate the motion info.</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.DisposeObject">
            <summary>
            Release unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.MotionHistory.ReleaseManagedResources">
            <summary>
            Release any images associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.MotionHistory.Mask">
            <summary>
            The motion mask. 
            Do not dispose this image.
            </summary>
        </member>
        <member name="T:Emgu.CV.OclDevice">
            <summary>
            This class contains ocl runtime information
            </summary>
        </member>
        <member name="M:Emgu.CV.OclDevice.#ctor">
            <summary>
            Create a empty OclDevice object
            </summary>
        </member>
        <member name="M:Emgu.CV.OclDevice.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this OclInfo
            </summary>
        </member>
        <member name="M:Emgu.CV.OclDevice.ToString">
            <summary>
            Get the string represetation of this oclDevice
            </summary>
            <returns>A string represetation of this oclDevice</returns>
        </member>
        <member name="P:Emgu.CV.OclDevice.Version">
            <summary>
            Get the device version
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.VendorName">
            <summary>
            Get the device vendor name
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.DriverVersion">
            <summary>
            Get the device driver version
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.Extensions">
            <summary>
            Get the device extensions
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.Name">
            <summary>
            Get the device name
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.Type">
            <summary>
            Get the ocl device type
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.MaxWorkGroupSize">
            <summary>
            The maximum work group size
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.MaxComputeUnits">
            <summary>
            The max compute unit
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.LocalMemorySize">
            <summary>
            The local memory size
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.MaxMemAllocSize">
            <summary>
            The maximum memory allocation size
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.DeviceVersionMajor">
            <summary>
            The device major version number
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.DeviceVersionMinor">
            <summary>
            The Device minor version number
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.DoubleFPConfig">
            <summary>
            The device double float point configuration
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.HostUnifiedMemory">
            <summary>
            True if the device use unified memory
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.OpenCLVersion">
            <summary>
            Get the opencl version
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.GlobalMemorySize">
            <summary>
            Get the global memory size
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.Image2DMaxWidth">
            <summary>
            Get the image 2d max width
            </summary>
        </member>
        <member name="P:Emgu.CV.OclDevice.Image2DMaxHeight">
            <summary>
            Get the image2d max height
            </summary>
        </member>
        <member name="T:Emgu.CV.OclDeviceType">
            <summary>
            Ocl Device Type
            </summary>
        </member>
        <member name="F:Emgu.CV.OclDeviceType.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Emgu.CV.OclDeviceType.Cpu">
            <summary>
            Cpu
            </summary>
        </member>
        <member name="F:Emgu.CV.OclDeviceType.Gpu">
            <summary>
            Gpu
            </summary>
        </member>
        <member name="F:Emgu.CV.OclDeviceType.Accelerator">
            <summary>
            Accerlerator
            </summary>
        </member>
        <member name="F:Emgu.CV.OclDeviceType.DGpu">
            <summary>
            DGpu
            </summary>
        </member>
        <member name="F:Emgu.CV.OclDeviceType.IGpu">
            <summary>
            IGpu
            </summary>
        </member>
        <member name="F:Emgu.CV.OclDeviceType.All">
            <summary>
            All
            </summary>
        </member>
        <member name="T:Emgu.CV.OclInvoke">
            <summary>
            Class that contains ocl functions.
            </summary>
        </member>
        <member name="M:Emgu.CV.OclInvoke.GetPlatformInfo">
            <summary>
            Get all the platform info as a vector
            </summary>
            <returns>The vector of Platfom info</returns>
        </member>
        <member name="T:Emgu.CV.OclPlatformInfo">
            <summary>
            This class contains ocl runtime information
            </summary>
        </member>
        <member name="M:Emgu.CV.OclPlatformInfo.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this OclInfo
            </summary>
        </member>
        <member name="M:Emgu.CV.OclPlatformInfo.GetDevice(System.Int32)">
            <summary>
            Get the OclDevice with the specific index
            </summary>
            <param name="d">The index of the ocl device</param>
            <returns>The ocl device with the specific index</returns>
        </member>
        <member name="M:Emgu.CV.OclPlatformInfo.ToString">
            <summary>
            Get the string that represent this oclPlatformInfo object
            </summary>
            <returns>A string that represent this oclPlatformInfo object</returns>
        </member>
        <member name="P:Emgu.CV.OclPlatformInfo.Version">
            <summary>
            Get the platform version
            </summary>
        </member>
        <member name="P:Emgu.CV.OclPlatformInfo.Name">
            <summary>
            Get the platform name
            </summary>
        </member>
        <member name="P:Emgu.CV.OclPlatformInfo.Vendor">
            <summary>
            Get the platform vendor
            </summary>
        </member>
        <member name="P:Emgu.CV.OclPlatformInfo.DeviceNumber">
            <summary>
            Get the number of device that belongs to the 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.NormType">
            <summary>
            Type for cvNorm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.C">
            <summary>
            if arr2 is NULL, norm = ||arr1||_C = max_I abs(arr1(I));
            if arr2 is not NULL, norm = ||arr1-arr2||_C = max_I abs(arr1(I)-arr2(I))
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.L1">
            <summary>
            if arr2 is NULL, norm = ||arr1||_L1 = sum_I abs(arr1(I));
            if arr2 is not NULL, norm = ||arr1-arr2||_L1 = sum_I abs(arr1(I)-arr2(I))
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.L2">
            <summary>
            if arr2 is NULL, norm = ||arr1||_L2 = sqrt( sum_I arr1(I)^2);
            if arr2 is not NULL, norm = ||arr1-arr2||_L2 = sqrt( sum_I (arr1(I)-arr2(I))^2 )
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.NormMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.Relative">
            <summary>
            It is used in combination with either CV_C, CV_L1 or CV_L2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.Diff">
            <summary>
            It is used in combination with either CV_C, CV_L1 or CV_L2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.MinMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.DiffC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.DiffL1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.DiffL2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.RelativeC">
            <summary>
            norm = ||arr1-arr2||_C/||arr2||_C
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.RelativeL1">
            <summary>
            norm = ||arr1-arr2||_L1/||arr2||_L1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.RelativeL2">
            <summary>
            norm = ||arr1-arr2||_L2/||arr2||_L2
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ReduceType">
            <summary>
            Type used for cvReduce function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceType.ReduceSum">
            <summary>
            The output is the sum of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceType.ReduceAvg">
            <summary>
            The output is the mean vector of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceType.ReduceMax">
            <summary>
            The output is the maximum (column/row-wise) of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceType.ReduceMin">
            <summary>
            The output is the minimum (column/row-wise) of all the matrix rows/columns
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ReduceDimension">
            <summary>
            Type used for cvReduce function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceDimension.SingleRow">
            <summary>
            The matrix is reduced to a single row
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceDimension.SingleCol">
            <summary>
            The matrix is reduced to a single column
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceDimension.Auto">
            <summary>
            The dimension is chosen automatically by analysing the dst size
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CmpType">
            <summary>
            Type used for cvCmp function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.Equal">
            <summary>
            src1(I) "equal to" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.GreaterThan">
            <summary>
            src1(I) "greater than" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.GreaterEqual">
            <summary>
            src1(I) "greater or equal" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.LessThan">
            <summary>
            src1(I) "less than" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.LessEqual">
            <summary>
            src1(I) "less or equal" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.NotEqual">
            <summary>
            src1(I) "not equal to" src2(I)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CapProp">
            <summary>
            CV Capture property identifier
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.DC1394Off">
            <summary>
            Turn the feature off (not controlled manually nor automatically)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.DC1394ModeManual">
            <summary>
            Set automatically when a value of the feature is set by the user
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.DC1394ModeAuto">
            <summary>
            DC1394 mode auto
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.DC1394ModeOnePushAuto">
            <summary>
            DC1394 mode one push auto
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PosMsec">
            <summary>
            Film current position in milliseconds or video capture timestamp
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PosFrames">
            <summary>
            0-based index of the frame to be decoded/captured next
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PosAviRatio">
            <summary>
            Position in relative units (0 - start of the file, 1 - end of the file)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.FrameWidth">
            <summary>
            Width of frames in the video stream
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.FrameHeight">
            <summary>
            Height of frames in the video stream
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Fps">
            <summary>
            Frame rate 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.FourCC">
            <summary>
            4-character code of codec
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.FrameCount">
            <summary>
            Number of frames in video file
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Format">
            <summary>
            Format
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Mode">
            <summary>
            Mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Brightness">
            <summary>
            Brightness
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Contrast">
            <summary>
            Contrast
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Staturation">
            <summary>
            Saturation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Hue">
            <summary>
            Hue
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Gain">
            <summary>
            Gain
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Exposure">
            <summary>
            Exposure
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.ConvertRgb">
            <summary>
            Convert RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.WhiteBalanceBlueU">
            <summary>
            White balance blue u
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Rectification">
            <summary>
            Rectification
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Monochrome">
            <summary>
            Monochrome
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Sharpness">
            <summary>
            Sharpness
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AutoExposure">
            <summary>
            Exposure control done by camera, user can adjust reference level using this feature
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Gamma">
            <summary>
            Gamma
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Temperature">
            <summary>
            Temperature
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Trigger">
            <summary>
            Trigger
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.TriggerDelay">
            <summary>
            Trigger delay
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.WhiteBalanceRedV">
            <summary>
            White balance red v
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Zoom">
            <summary>
            Zoom
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Focus">
            <summary>
            Focus
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Guid">
            <summary>
            GUID
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IsoSpeed">
            <summary>
            ISO SPEED
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.MaxDC1394">
            <summary>
            MAX DC1394
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Backlight">
            <summary>
            Backlight
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Pan">
            <summary>
            Pan
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Tilt">
            <summary>
            Tilt
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Roll">
            <summary>
            Roll
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Iris">
            <summary>
            Iris
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Settings">
            <summary>
            Settings
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Autograb">
            <summary>
            property for highgui class CvCapture_Android only
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.SupportedPreviewSizesString">
            <summary>
            readonly, tricky property, returns cpnst char* indeed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PreviewFormat">
            <summary>
            readonly, tricky property, returns cpnst char* indeed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGenerator">
            <summary>
            OpenNI map generators
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniImageGenerator">
            <summary>
            OpenNI map generators
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniGeneratorsMask">
            <summary>
            OpenNI map generators
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniOutputMode">
            <summary>
            Properties of cameras available through OpenNI interfaces
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniFrameMaxDepth">
            <summary>
            Properties of cameras available through OpenNI interfaces, in mm.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniBaseline">
            <summary>
            Properties of cameras available through OpenNI interfaces, in mm.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniFocalLength">
            <summary>
            Properties of cameras available through OpenNI interfaces, in pixels.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniRegistration">
            <summary>
            Flag that synchronizes the remapping depth map to image map
            by changing depth generator's view point (if the flag is "on") or
            sets this view point to its normal one (if the flag is "off").
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniRegistrationOn">
            <summary>
            Flag that synchronizes the remapping depth map to image map
            by changing depth generator's view point (if the flag is "on") or
            sets this view point to its normal one (if the flag is "off").
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniApproxFrameSync">
            <summary>
            Approx frame sync
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniMaxBufferSize">
            <summary>
            Max buffer size
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniCircleBuffer">
            <summary>
            Circle buffer
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniMaxTimeDuration">
            <summary>
            Max time duration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniGeneratorPresent">
            <summary>
            Generator present
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniImageGeneratorPresent">
            <summary>
            Openni image generator present
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniImageGeneratorOutputMode">
            <summary>
            Image generator output mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorBaseline">
            <summary>
            Depth generator baseline, in mm.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorFocalLength">
            <summary>
            Depth generator focal length, in pixels.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorRegistration">
            <summary>
            Openni generator registration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorRegistrationOn">
            <summary>
            Openni generator registration on
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GstreamerQueueLength">
            <summary>
            Properties of cameras available through GStreamer interface. Default is 1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PvapiMulticastip">
            <summary>
            Ip for enable multicast master mode. 0 for disable multicast
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDownsampling">
            <summary>
            Change image resolution by binning or skipping.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDataFormat">
            <summary>
            Output data format
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiOffsetX">
            <summary>
            Horizontal offset from the origin to the area of interest (in pixels).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiOffsetY">
            <summary>
            Vertical offset from the origin to the area of interest (in pixels).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTrgSource">
            <summary>
            Defines source of trigger.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTrgSoftware">
            <summary>
            Generates an internal trigger. PRM_TRG_SOURCE must be set to TRG_SOFTWARE.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpiSelector">
            <summary>
            Selects general purpose input
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpiMode">
            <summary>
            Set general purpose input mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpiLevel">
            <summary>
            Get general purpose level
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpoSelector">
            <summary>
            Selects general purpose output
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpoMode">
            <summary>
            Set general purpose output mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLedSelector">
            <summary>
            Selects camera signaling LED
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLedMode">
            <summary>
            Define camera signaling LED functionality
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiManualWb">
            <summary>
            Calculates White Balance(must be called during acquisition)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAutoWb">
            <summary>
            Automatic white balance
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeag">
            <summary>
            Automatic exposure/gain
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiExpPriority">
            <summary>
            Exposure priority (0.5 - exposure 50%, gain 50%).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeMaxLimit">
            <summary>
            Maximum limit of exposure in AEAG procedure
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAgMaxLimit">
            <summary>
            Maximum limit of gain in AEAG procedure
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeagLevel">
            <summary>
            Average intensity of output signal AEAG should achieve(in %)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTimeout">
            <summary>
            Image capture timeout in milliseconds
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFlashMode">
            <summary>
            Android flash mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocusMode">
            <summary>
            Android focus mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidWhiteBalance">
            <summary>
            Android white balance
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidAntibanding">
            <summary>
            Android anti banding
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocalLength">
            <summary>
            Android focal length
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocusDistanceNear">
            <summary>
            Android focus distance near
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocusDistanceOptimal">
            <summary>
            Android focus distance optimal
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocusDistanceFar">
            <summary>
            Android focus distance far
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceFocus">
            <summary>
            iOS device focus
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceExposure">
            <summary>
            iOS device exposure
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceFlash">
            <summary>
            iOS device flash
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceWhitebalance">
            <summary>
            iOS device white-balance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceTorch">
            <summary>
            iOS device torch
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameOffsetX">
            <summary>
            Smartek Giganetix Ethernet Vision: frame offset X
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameOffsetY">
            <summary>
            Smartek Giganetix Ethernet Vision: frame offset Y
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameWidthMax">
            <summary>
            Smartek Giganetix Ethernet Vision: frame width max
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameHeighMax">
            <summary>
            Smartek Giganetix Ethernet Vision: frame height max
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameSensWidth">
            <summary>
            Smartek Giganetix Ethernet Vision: frame sens width
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameSensHeigh">
            <summary>
            Smartek Giganetix Ethernet Vision: frame sens height
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ChainApproxMethod">
            <summary>
            contour approximation method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainCode">
            <summary>
            output contours in the Freeman chain code. All other methods output polygons (sequences of vertices). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxNone">
            <summary>
            translate all the points from the chain code into points;
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxSimple">
            <summary>
            compress horizontal, vertical, and diagonal segments, that is, the function leaves only their ending points; 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxTc89L1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxTc89Kcos">
            <summary>
            apply one of the flavors of Teh-Chin chain approximation algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.LinkRuns">
            <summary>
            use completely different contour retrieval algorithm via linking of horizontal segments of 1s. Only LIST retrieval mode can be used with this method
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ColorConversion">
            <summary>
            Color Conversion code
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Bgra">
            <summary>
            Convert BGR color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Rgba">
            <summary>
            Convert RGB color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Bgr">
            <summary>
            Convert BGRA color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Rgb">
            <summary>
            Convert RGBA color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Rgba">
            <summary>
            Convert BGR color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Bgra">
            <summary>
            Convert RGB color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Bgr">
            <summary>
            Convert RGBA color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Rgb">
            <summary>
            Convert BGRA color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Rgb">
            <summary>
            Convert BGR color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Bgr">
            <summary>
            Convert RGB color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Rgba">
            <summary>
            Convert BGRA color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Bgra">
            <summary>
            Convert RGBA color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Gray">
            <summary>
            Convert BGR color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Gray">
            <summary>
            Convert RGB color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Bgr">
            <summary>
            Convert GRAY color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Rgb">
            <summary>
            Convert GRAY color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Bgra">
            <summary>
            Convert GRAY color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Rgba">
            <summary>
            Convert GRAY color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Gray">
            <summary>
            Convert BGRA color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Gray">
            <summary>
            Convert RGBA color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Bgr565">
            <summary>
            Convert BGR color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Bgr565">
            <summary>
            Convert RGB color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Bgr">
            <summary>
            Convert BGR565 color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Rgb">
            <summary>
            Convert BGR565 color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Bgr565">
            <summary>
            Convert BGRA color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Bgr565">
            <summary>
            Convert RGBA color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Bgra">
            <summary>
            Convert BGR565 color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Rgba">
            <summary>
            Convert BGR565 color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Bgr565">
            <summary>
            Convert GRAY color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Gray">
            <summary>
            Convert BGR565 color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Bgr555">
            <summary>
            Convert BGR color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Bgr555">
            <summary>
            Convert RGB color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Bgr">
            <summary>
            Convert BGR555 color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Rgb">
            <summary>
            Convert BGR555 color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Bgr555">
            <summary>
            Convert BGRA color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Bgr555">
            <summary>
            Convert RGBA color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Bgra">
            <summary>
            Convert BGR555 color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Rgba">
            <summary>
            Convert BGR555 color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Bgr555">
            <summary>
            Convert GRAY color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Gray">
            <summary>
            Convert BGR555 color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Xyz">
            <summary>
            Convert BGR color to XYZ color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Xyz">
            <summary>
            Convert RGB color to XYZ color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Xyz2Bgr">
            <summary>
            Convert XYZ color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Xyz2Rgb">
            <summary>
            Convert XYZ color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2YCrCb">
            <summary>
            Convert BGR color to YCrCb color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2YCrCb">
            <summary>
            Convert RGB color to YCrCb color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.YCrCb2Bgr">
            <summary>
            Convert YCrCb color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.YCrCb2Rgb">
            <summary>
            Convert YCrCb color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Hsv">
            <summary>
            Convert BGR color to HSV color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Hsv">
            <summary>
            Convert RGB colot to HSV color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Lab">
            <summary>
            Convert BGR color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Lab">
            <summary>
            Convert RGB color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2Bgr">
            <summary>
            Convert BayerBG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2Bgr">
            <summary>
            Convert BayerGB color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2Bgr">
            <summary>
            Convert BayerRG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2Bgr">
            <summary>
            Convert BayerGR color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2Rgb">
            <summary>
            Convert BayerBG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2Rgb">
            <summary>
            Convert BayerRG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2Rgb">
            <summary>
            Convert BayerRG color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2Rgb">
            <summary>
            Convert BayerGR color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Luv">
            <summary>
            Convert BGR color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Luv">
            <summary>
            Convert RGB color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Hls">
            <summary>
            Convert BGR color to HLS color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Hls">
            <summary>
            Convert RGB color to HLS color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hsv2Bgr">
            <summary>
            Convert HSV color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hsv2Rgb">
            <summary>
            Convert HSV color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lab2Bgr">
            <summary>
            Convert Lab color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lab2Rgb">
            <summary>
            Convert Lab color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Luv2Bgr">
            <summary>
            Convert Luv color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Luv2Rgb">
            <summary>
            Convert Luv color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hls2Bgr">
            <summary>
            Convert HLS color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hls2Rgb">
            <summary>
            Convert HLS color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2BgrVng">
            <summary>
            Convert BayerBG pattern to BGR color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2BgrVng">
            <summary>
            Convert BayerGB pattern to BGR color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2BgrVng">
            <summary>
            Convert BayerRG pattern to BGR color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2BgrVng">
            <summary>
            Convert BayerGR pattern to BGR color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2RgbVng">
            <summary>
            Convert BayerBG pattern to RGB color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2RgbVng">
            <summary>
            Convert BayerGB pattern to RGB color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2RgbVng">
            <summary>
            Convert BayerRG pattern to RGB color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2RgbVng">
            <summary>
            Convert BayerGR pattern to RGB color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2HsvFull">
            <summary>
            Convert BGR to HSV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2HsvFull">
            <summary>
            Convert RGB to HSV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2HlsFull">
            <summary>
            Convert BGR to HLS
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2HlsFull">
            <summary>
            Convert RGB to HLS
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hsv2BgrFull">
            <summary>
            Convert HSV color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hsv2RgbFull">
            <summary>
            Convert HSV color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hls2BgrFull">
            <summary>
            Convert HLS color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hls2RgbFull">
            <summary>
            Convert HLS color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lbgr2Lab">
            <summary>
            Convert sBGR color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lrgb2Lab">
            <summary>
            Convert sRGB color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lbgr2Luv">
            <summary>
            Convert sBGR color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lrgb2Luv">
            <summary>
            Convert sRGB color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lab2Lbgr">
            <summary>
            Convert Lab color to sBGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lab2Lrgb">
            <summary>
            Convert Lab color to sRGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Luv2Lbgr">
            <summary>
            Convert Luv color to sBGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Luv2Lrgb">
            <summary>
            Convert Luv color to sRGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Yuv">
            <summary>
            Convert BGR color to YUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Yuv">
            <summary>
            Convert RGB color to YUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2Bgr">
            <summary>
            Convert YUV color to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2Rgb">
            <summary>
            Convert YUV color to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2Gray">
            <summary>
            Convert BayerBG to GRAY
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2Gray">
            <summary>
            Convert BayerGB to GRAY
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2Gray">
            <summary>
            Convert BayerRG to GRAY
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2Gray">
            <summary>
            Convert BayerGR to GRAY
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420I2Rgb">
            <summary>
            Convert YUV420i to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420I2Bgr">
            <summary>
            Convert YUV420i to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Rgb">
            <summary>
            Convert YUV420sp to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Bgr">
            <summary>
            Convert YUV320sp to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420I2Rgba">
            <summary>
            Convert YUV320i to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420I2Bgra">
            <summary>
            Convert YUV420i to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Rgba">
            <summary>
            Convert YUV420sp to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Bgra">
            <summary>
            Convert YUV420sp to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYv12">
            <summary>
            Convert YUV (YV12) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYv12">
            <summary>
            Convert YUV (YV12) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbIyuv">
            <summary>
            Convert YUV (iYUV) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrIyuv">
            <summary>
            Convert YUV (iYUV) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbI420">
            <summary>
            Convert YUV (i420) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrI420">
            <summary>
            Convert YUV (i420) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Rgb">
            <summary>
            Convert YUV (420p) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Bgr">
            <summary>
            Convert YUV (420p) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYv12">
            <summary>
            Convert YUV (YV12) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYv12">
            <summary>
            Convert YUV (YV12) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaIyuv">
            <summary>
            Convert YUV (iYUV) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraIyuv">
            <summary>
            Convert YUV (iYUV) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaI420">
            <summary>
            Convert YUV (i420) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraI420">
            <summary>
            Convert YUV (i420) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Rgba">
            <summary>
            Convert YUV (420p) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Bgra">
            <summary>
            Convert YUV (420p) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2Gray420">
            <summary>
            Convert YUV 420 to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayNv21">
            <summary>
            Convert YUV NV21 to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayNv12">
            <summary>
            Convert YUV NV12 to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYv12">
            <summary>
            Convert YUV YV12 to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayIyuv">
            <summary>
            Convert YUV (iYUV) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayI420">
            <summary>
            Convert YUV (i420) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Gray">
            <summary>
            Convert YUV (420sp) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Gray">
            <summary>
            Convert YUV (420p) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbUyvy">
            <summary>
            Convert YUV (UYVY) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrUyvy">
            <summary>
            Convert YUV (UYVY) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbY422">
            <summary>
            Convert YUV (Y422) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrY422">
            <summary>
            Convert YUV (Y422) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbUynv">
            <summary>
            Convert YUV (UYNY) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrUynv">
            <summary>
            Convert YUV (UYNV) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaUyvy">
            <summary>
            Convert YUV (UYVY) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraUyvy">
            <summary>
            Convert YUV (VYUY) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaY422">
            <summary>
            Convert YUV (Y422) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraY422">
            <summary>
            Convert YUV (Y422) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaUynv">
            <summary>
            Convert YUV (UYNV) to RGBA 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraUynv">
            <summary>
            Convert YUV (UYNV) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYuy2">
            <summary>
            Convert YUV (YUY2) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYuy2">
            <summary>
            Convert YUV (YUY2) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYvyu">
            <summary>
            Convert YUV (YVYU) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYvyu">
            <summary>
            Convert YUV (YVYU) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYuyv">
            <summary>
            Convert YUV (YUYV) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYuyv">
            <summary>
            Convert YUV (YUYV) to BGR 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYunv">
            <summary>
            Convert YUV (YUNV) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYunv">
            <summary>
            Convert YUV (YUNV) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYuy2">
            <summary>
            Convert YUV (YUY2) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYuy2">
            <summary>
            Convert YUV (YUY2) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYvyu">
            <summary>
            Convert YUV (YVYU) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYvyu">
            <summary>
            Convert YUV (YVYU) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYuyv">
            <summary>
            Convert YUV (YUYV) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYuyv">
            <summary>
            Convert YUV (YUYV) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYunv">
            <summary>
            Convert YUV (YUNV) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYunv">
            <summary>
            Convert YUV (YUNV) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayUyvy">
            <summary>
            Convert YUV (UYVY) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYuy2">
            <summary>
            Convert YUV (YUY2) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayY422">
            <summary>
            Convert YUV (Y422) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayUynv">
            <summary>
            Convert YUV (UYNV) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYvyu">
            <summary>
            Convert YUV (YVYU) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYuyv">
            <summary>
            Convert YUV (YUYV) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYunv">
            <summary>
            Convert YUV (YUNV) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2MRgba">
            <summary>
            Alpha premultiplication
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.MRgba2Rgba">
            <summary>
            Alpha premultiplication
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2YuvI420">
            <summary>
            Convert RGB to YUV_I420
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2YuvI420">
            <summary>
            Convert BGR to YUV_I420
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2YuvIyuv">
            <summary>
            Convert RGB to YUV_IYUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2YuvIyuv">
            <summary>
            Convert BGR to YUV_IYUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2YuvI420">
            <summary>
            Convert RGBA to YUV_I420
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2YuvI420">
            <summary>
            Convert BGRA to YUV_I420
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2YuvIyuv">
            <summary>
            Convert RGBA to YUV_IYUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2YuvIyuv">
            <summary>
            Convert BGRA to YUV_IYUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2YuvYv12">
            <summary>
            Convert RGB to YUV_YV12
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2YuvYv12">
            <summary>
            Convert BGR to YUV_YV12
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2YuvYv12">
            <summary>
            Convert RGBA to YUV_YV12
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2YuvYv12">
            <summary>
            Convert BGRA to YUV_YV12
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2BgrEa">
            <summary>
            Convert BayerBG to BGR (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2BgrEa">
            <summary>
            Convert BayerGB to BGR (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2BgrEa">
            <summary>
            Convert BayerRG to BGR (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2BgrEa">
            <summary>
            Convert BayerGR to BGR (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2RgbEa">
            <summary>
            Convert BayerBG to RGB (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2RgbEa">
            <summary>
            Convert BayerGB to RGB (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2RgbEa">
            <summary>
            Convert BayerRG to RGB (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2RgbEa">
            <summary>
            Convert BayerGR to RGB (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.ColorcvtMax">
            <summary>
            The max number, do not use
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FontFace">
            <summary>
            Fonts
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheySimplex">
            <summary>
            Hershey simplex
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyPlain">
            <summary>
            Hershey plain
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyDuplex">
            <summary>
            Hershey duplex 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyComplex">
            <summary>
            Hershey complex
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyTriplex">
            <summary>
            Hershey triplex
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyComplexSmall">
            <summary>
            Hershey complex small
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyScriptSimplex">
            <summary>
            Hershey script simplex
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyScriptComplex">
            <summary>
            Hershey script complex
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GemmType">
            <summary>
            Flags used for GEMM function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GemmType.Default">
            <summary>
            Do not apply transpose to neither matrices
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GemmType.Src1Transpose">
            <summary>
            transpose src1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GemmType.Src2Transpose">
            <summary>
            transpose src2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GemmType.Src3Transpose">
            <summary>
            transpose src3
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HoughType">
            <summary>
            Hough detection type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HoughType.Gradient">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.InpaintType">
            <summary>
            Inpaint type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.InpaintType.NS">
            <summary>
            Navier-Stokes based method.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.InpaintType.Telea">
            <summary>
            The method by Alexandru Telea 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.EdgePreservingFilterFlag">
            <summary>
            Edge preserving filter flag
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EdgePreservingFilterFlag.RecursFilter">
            <summary>
            Recurs filter
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EdgePreservingFilterFlag.NormconvFilter">
            <summary>
            Norm conv filter
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Inter">
            <summary>
            Interpolation types
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Nearest">
            <summary>
            Nearest-neighbor interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Linear">
            <summary>
            Bilinear interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Cubic">
            <summary>
            Resampling using pixel area relation. It is the preferred method for image decimation that gives moire-free results. In case of zooming it is similar to CV_INTER_NN method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Area">
            <summary>
            Bicubic interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Lanczos4">
            <summary>
            LANCZOS 4
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SmoothType">
            <summary>
            Interpolation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.BlurNoScale">
            <summary>
            (simple blur with no scaling) - summation over a pixel param1xparam2 neighborhood. If the neighborhood size may vary, one may precompute integral image with cvIntegral function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.Blur">
            <summary>
            (simple blur) - summation over a pixel param1xparam2 neighborhood with subsequent scaling by 1/(param1xparam2). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.Gaussian">
            <summary>
            (Gaussian blur) - convolving image with param1xparam2 Gaussian kernel. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.Median">
            <summary>
            (median blur) - finding median of param1xparam1 neighborhood (i.e. the neighborhood is square). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.Bilateral">
            <summary>
            (bilateral filter) - applying bilateral 3x3 filtering with color sigma=param1 and space sigma=param2. Information about bilateral filtering can be found 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LoadImageType">
            <summary>
            cvLoadImage type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LoadImageType.Unchanged">
            <summary>
            8bit, color or not 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LoadImageType.Grayscale">
            <summary>
            8bit, gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LoadImageType.Color">
            <summary>
            ?, color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LoadImageType.AnyDepth">
            <summary>
            any depth, ?
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LoadImageType.AnyColor">
            <summary>
            ?, any color
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DepthType">
            <summary>
            OpenCV depth type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Default">
            <summary>
            default
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv8U">
            <summary>
            Byte
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv8S">
            <summary>
            SByte
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv16U">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv16S">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv32S">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv32F">
            <summary>
            float
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv64F">
            <summary>
            double
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RandType">
            <summary>
            CV_RAND TYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RandType.Uni">
            <summary>
            Uniform distribution
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RandType.Normal">
            <summary>
            Normal distribution
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RetrType">
            <summary>
            contour retrieval mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RetrType.External">
            <summary>
            retrieve only the extreme outer contours 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RetrType.List">
            <summary>
             retrieve all the contours and puts them in the list 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RetrType.Ccomp">
            <summary>
            retrieve all the contours and organizes them into two-level hierarchy: top level are external boundaries of the components, second level are bounda boundaries of the holes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RetrType.Tree">
            <summary>
            retrieve all the contours and reconstructs the full hierarchy of nested contours 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.EltypeBits">
            <summary>
            The bit to shift for SEQ_ELTYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.EltypeMask">
            <summary>
            The mask of CV_SEQ_ELTYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.KindBits">
            <summary>
            The bits to shift for SEQ_KIND
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.Shift">
            <summary>
            The bits to shift for SEQ_FLAG
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SeqEltype">
            <summary>
            Sequence element type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Point">
            <summary>
              (x,y) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Code">
            <summary>  
            freeman code: 0..7 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Generic">
            <summary>  
            unspecified type of sequence elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Ptr">
            <summary>  
            =6 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Ppoint">
            <summary>  
            pointer to element of other sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Index">
            <summary>  
            index of element of some other sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.GraphEdge">
            <summary>  
            next_o, next_d, vtx_o, vtx_d 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.GraphVertex">
            <summary>  
            first_edge, (x,y) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.TrainAtr">
            <summary>  
            vertex of the binary tree   
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.ConnectedComp">
            <summary>  
            connected component  
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Point3D">
            <summary>  
            (x,y,z)  
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SeqKind">
            <summary>
            The kind of sequence available
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.Generic">
            <summary>
            generic (unspecified) kind of sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.Curve">
            <summary>
            dense sequence subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.BinTree">
            <summary>
            dense sequence subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.Graph">
            <summary>
            sparse sequence (or set) subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.Subdiv2D">
            <summary>
            sparse sequence (or set) subtypes 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SeqFlag">
            <summary>
            Sequence flag
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqFlag.Closed">
            <summary>
            close sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqFlag.Simple">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqFlag.Convex">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqFlag.Hole">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SeqType">
            <summary>
            Sequence type for point sets
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.PointSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.Point3DSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.Polyline">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.Polygon">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.SimplePolygon">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.TermCritType">
            <summary>
            CV_TERMCRIT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TermCritType.Iter">
            <summary>
            Iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TermCritType.Eps">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ThresholdType">
            <summary>
            Types of thresholding 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.Binary">
            <summary>
            value = value > threshold ? max_value : 0
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.BinaryInv">
            <summary>
             value = value > threshold ? 0 : max_value       
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.Trunc">
            <summary>
             value = value > threshold ? threshold : value   
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.ToZero">
            <summary>
             value = value > threshold ? value : 0           
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.ToZeroInv">
            <summary>
             value = value > threshold ? 0 : value           
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.Mask">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.Otsu">
            <summary>
             use Otsu algorithm to choose the optimal threshold value;
             combine the flag with one of the above CV_THRESH_* values 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.TemplateMatchingType">
            <summary>
            Methods for comparing two array
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.Sqdiff">
            <summary>
            R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.SqdiffNormed">
            <summary>
            R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2/sqrt[sumx',y'T(x',y')2 sumx',y'I(x+x',y+y')2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.Ccorr">
            <summary>
            R(x,y)=sumx',y'[T(x',y') I(x+x',y+y')]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.CcorrNormed">
            <summary>
            R(x,y)=sumx',y'[T(x',y') I(x+x',y+y')]/sqrt[sumx',y'T(x',y')2 sumx',y'I(x+x',y+y')2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.Ccoeff">
            <summary>
            R(x,y)=sumx',y'[T'(x',y') I'(x+x',y+y')],
            where T'(x',y')=T(x',y') - 1/(wxh) sumx",y"T(x",y")
               I'(x+x',y+y')=I(x+x',y+y') - 1/(wxh) sumx",y"I(x+x",y+y")
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.CcoeffNormed">
            <summary>
            R(x,y)=sumx',y'[T'(x',y') I'(x+x',y+y')]/sqrt[sumx',y'T'(x',y')2 sumx',y'I'(x+x',y+y')2]
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.IplDepth">
            <summary>
            IPL_DEPTH
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepthSign">
            <summary>
            indicates if the value is signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth_1U">
            <summary>
            1bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth_8U">
            <summary>
            8bit unsigned (Byte)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth16U">
            <summary>
            16bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth32F">
            <summary>
            32bit float (Single)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth_8S">
            <summary>
            8bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth16S">
            <summary>
            16bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth32S">
            <summary>
            32bit signed 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth64F">
            <summary>
            double
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FlipType">
            <summary>
            Enumeration used by cvFlip
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FlipType.None">
            <summary>
            No flipping
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FlipType.Horizontal">
            <summary>
            Flip horizontally
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FlipType.Vertical">
            <summary>
            Flip vertically
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CheckType">
            <summary>
            Enumeration used by cvCheckArr
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CheckType.NanInfinity">
            <summary>
            Checks that every element is neither NaN nor Infinity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CheckType.Range">
            <summary>
            If set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neigther NaN nor Infinity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CheckType.Quite">
            <summary>
            If set, the function does not raises an error if an element is invalid or out of range
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FloodFillType">
            <summary>
            Type of floodfill operation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FloodFillType.Default">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FloodFillType.FixedRange">
            <summary>
            If set the difference between the current pixel and seed pixel is considered,
            otherwise difference between neighbor pixels is considered (the range is floating).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FloodFillType.MaskOnly">
            <summary>
            If set, the function does not fill the image (new_val is ignored),
            but the fills mask (that must be non-NULL in this case).
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Connectivity">
            <summary>
            The type for cvSampleLine
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Connectivity.EightConnected">
            <summary>
            8-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Connectivity.FourConnected">
            <summary>
            4-connected
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LineType">
            <summary>
            The type of line for drawing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LineType.EightConnected">
            <summary>
            8-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LineType.FourConnected">
            <summary>
            4-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LineType.AntiAlias">
            <summary>
            Anti-alias
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DistType">
            <summary>
            Defines for Distance Transform
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.User">
            <summary>
              User defined distance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.L1">
            <summary>
              distance = |x1-x2| + |y1-y2| 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.L2">
            <summary>
              Simple euclidean distance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.C">
            <summary>
              distance = max(|x1-x2|,|y1-y2|) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.L12">
            <summary>
              L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1)) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.Fair">
            <summary>
              distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.Welsch">
            <summary>
              distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.Huber">
            <summary>
              distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.MulSpectrumsType">
            <summary>
            The types for cvMulSpectrums
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MulSpectrumsType.Default">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MulSpectrumsType.DxtRows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MulSpectrumsType.DxtMulConj">
            <summary>
            Conjugate the second argument of cvMulSpectrums
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DxtType">
            <summary>
            Flag used for cvDFT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.Forward">
            <summary>
            Do forward 1D or 2D transform. The result is not scaled
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.Inverse">
            <summary>
            Do inverse 1D or 2D transform. The result is not scaled. CV_DXT_FORWARD and CV_DXT_INVERSE are mutually exclusive, of course
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.Scale">
            <summary>
            Scale the result: divide it by the number of array elements. Usually, it is combined with CV_DXT_INVERSE, and one may use a shortcut 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.Rows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.InvScale">
            <summary>
            Inverse and scale
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DctType">
            <summary>
            Flag used for cvDCT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DctType.Forward">
            <summary>
            Do forward 1D or 2D transform. The result is not scaled
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DctType.Inverse">
            <summary>
            Do inverse 1D or 2D transform. The result is not scaled. CV_DXT_FORWARD and CV_DXT_INVERSE are mutually exclusive, of course
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DctType.Rows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FmType">
            <summary>
            Calculates fundamental matrix given a set of corresponding points
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.SevenPoint">
            <summary>
            for 7-point algorithm. N == 7
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.EightPoint">
            <summary>
            for 8-point algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.LMedsOnly">
            <summary>
            for LMedS algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.RansacOnly">
            <summary>
            for RANSAC algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.LMeds">
            <summary>
            CV_FM_LMEDS_ONLY | CV_FM_8POINT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.Ransac">
            <summary>
            CV_FM_RANSAC_ONLY | CV_FM_8POINT
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.General">
            <summary>
            General enumeration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.General.MaxDim">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.General.SeqMagicVal">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.General.SetMagicVal">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ErrorCodes">
            <summary>
             Error codes
             </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsOk">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBacktrace">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsError">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsInternal">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsNoMem">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadArg">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadFunc">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsNoConv">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsAutoTrace">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.HeaderIsNull">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadImageSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadDataPtr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.Badstep">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadModelOrChseq">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadNumChannels">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadNumChannel1U">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadDepth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadAlphaChannel">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadOrder">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadOrigin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadAlign">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadCallback">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadTileSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadCoi">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadRoiSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.MaskIsTiled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsNullPtr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsVecLengthErr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsFilterStructContenterr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsKernelStructContenterr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsFilterOffSetErr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsDivByZero">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsInplaceNotSupported">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsObjectNotFound">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsUnmatchedFormats">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadFlag">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsUnmatchedSizes">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsUnsupportedFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsOutOfRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsParseError">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsNotImplemented">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadMemBlock">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Warp">
            <summary>
            Types for WarpAffine
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Warp.Default">
            <summary>
            Neither FILL_OUTLIERS nor CV_WRAP_INVERSE_MAP
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Warp.FillOutliers">
            <summary>
            Fill all the destination image pixels. If some of them correspond to outliers in the source image, they are set to fillval.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Warp.InverseMap">
            <summary>
            Indicates that matrix is inverse transform from destination image to source and, thus, can be used directly for pixel interpolation. Otherwise, the function finds the inverse transform from map_matrix.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.AdaptiveThresholdType">
            <summary>
            Types of Adaptive Threshold
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AdaptiveThresholdType.MeanC">
            <summary>
            indicates that "Mean minus C" should be used for adaptive threshold.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AdaptiveThresholdType.GaussianC">
            <summary>
            indicates that "Gaussian minus C" should be used for adaptive threshold.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ElementShape">
            <summary>
            Shape of the Structuring Element
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ElementShape.Rectangle">
            <summary>
            A rectangular element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ElementShape.Cross">
            <summary>
            A cross-shaped element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ElementShape.Ellipse">
            <summary>
            An elliptic element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ElementShape.Custom">
            <summary>
            A user-defined element.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.PcaType">
            <summary>
            PCA Type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PcaType.DataAsRow">
            <summary>
            the vectors are stored as rows (i.e. all the components of a certain vector are stored continously)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PcaType.DataAsCol">
            <summary>
             the vectors are stored as columns (i.e. values of a certain vector component are stored continuously)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PcaType.UseAvg">
            <summary>
            use pre-computed average vector
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DecompMethod">
            <summary>
            cvInvert method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.LU">
            <summary>
            Gaussian elimination with optimal pivot element chose
            In case of LU method the function returns src1 determinant (src1 must be square). If it is 0, the matrix is not inverted and src2 is filled with zeros.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.Svd">
            <summary>
            Singular value decomposition (SVD) method
            In case of SVD methods the function returns the inversed condition number of src1 (ratio of the smallest singular value to the largest singular value) and 0 if src1 is all zeros. The SVD methods calculate a pseudo-inverse matrix if src1 is singular
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.Eig">
            <summary>
            Eig
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.Cholesky">
            <summary>
            method for a symmetric positively-defined matrix
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.QR">
            <summary>
            QR decomposition
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.Normal">
            <summary>
            Normal
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CovarMethod">
            <summary>
            cvCalcCovarMatrix method types
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Scrambled">
            <summary>
            Calculates covariation matrix for a set of vectors 
            transpose([v1-avg, v2-avg,...]) * [v1-avg,v2-avg,...] 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Normal">
            <summary>
            [v1-avg, v2-avg,...] * transpose([v1-avg,v2-avg,...])
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.UseAvg">
            <summary>
            Do not calc average (i.e. mean vector) - use the input vector instead
            (useful for calculating covariance matrix by parts)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Scale">
            <summary>
            Scale the covariance matrix coefficients by number of the vectors
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Rows">
            <summary>
            All the input vectors are stored in a single matrix, as its rows 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Cols">
            <summary>
            All the input vectors are stored in a single matrix, as its columns
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SvdType">
            <summary>
            Type for cvSVD
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SvdType.Default">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SvdType.ModifyA">
            <summary>
            enables modification of matrix src1 during the operation. It speeds up the processing. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SvdType.Ut">
            <summary>
            means that the transposed matrix U is returned. Specifying the flag speeds up the processing. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SvdType.Vt">
            <summary>
            means that the transposed matrix V is returned. Specifying the flag speeds up the processing. 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LKFlowFlag">
            <summary>
            Type for cvCalcOpticalFlowPyrLK
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFlowFlag.Default">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFlowFlag.UserInitialFlow">
            <summary>
            Uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFlowFlag.LKGetMinEigenvals">
            <summary>
            use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CalibType">
            <summary>
            Various camera calibration flags
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.Default">
            <summary>
            The default value
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.UserIntrinsicGuess">
            <summary>
            intrinsic_matrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center (image_size is used here), and focal distances are computed in some least-squares fashion
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixAspectRatio">
            <summary>
            The optimization procedure consider only one of fx and fy as independent variable and keeps the aspect ratio fx/fy the same as it was set initially in intrinsic_matrix. In this case the actual initial values of (fx, fy) are either taken from the matrix (when CV_CALIB_USE_INTRINSIC_GUESS is set) or estimated somehow (in the latter case fx, fy may be set to arbitrary values, only their ratio is used)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixPrincipalPoint">
            <summary>
            The principal point is not changed during the global optimization, it stays at the center and at the other location specified (when CV_CALIB_FIX_FOCAL_LENGTH - Both fx and fy are fixed.
            CV_CALIB_USE_INTRINSIC_GUESS is set as well)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.ZeroTangentDist">
            <summary>
            Tangential distortion coefficients are set to zeros and do not change during the optimization
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixFocalLength">
            <summary>
            The focal length is fixed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK1">
            <summary>
            The 1st distortion coefficient (k1) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK2">
            <summary>
            The 2nd distortion coefficient (k2) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK3">
            <summary>
            The 3rd distortion coefficient (k3) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK4">
            <summary>
            The 4th distortion coefficient (k4) is fixed (see above)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK5">
            <summary>
            The 5th distortion coefficient (k5) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK6">
            <summary>
            The 6th distortion coefficient (k6) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.RationalModel">
            <summary>
            Rational model
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CalibCbType">
            <summary>
            Type of chessboard calibration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.Default">
            <summary>
            Default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.AdaptiveThresh">
            <summary>
            Use adaptive thresholding to convert the image to black-n-white, rather than a fixed threshold level (computed from the average image brightness)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.NormalizeImage">
            <summary>
            Normalize the image using cvNormalizeHist before applying fixed or adaptive thresholding.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.FilterQuads">
            <summary>
            Use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads that are extracted at the contour retrieval stage
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.FastCheck">
            <summary>
            If it is on, then this check is performed before the main algorithm and if a chessboard is not found, the function returns 0 instead of wasting 0.3-1s on doing the full search.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CalibCgType">
            <summary>
            Type of circles grid calibration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCgType.SymmetricGrid">
            <summary>
            symmetric grid
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCgType.AsymmetricGrid">
            <summary>
            asymmetric grid
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCgType.Clustering">
            <summary>
            Clustering
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.EigobjType">
            <summary>
            IO type for eigen object related functions
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EigobjType.NoCallback">
            <summary>
            No callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EigobjType.InputCallback">
            <summary>
            input callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EigobjType.OutputCallback">
            <summary>
            output callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EigobjType.BothCallback">
            <summary>
            both callback
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.NextEdgeType">
            <summary>
            CvNextEdgeType
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NextEdgeType.NextAroundOrg">
            <summary>
            next around the edge origin (eOnext)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NextEdgeType.NextAroundDst">
            <summary>
            next around the edge vertex (eDnext) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NextEdgeType.PrevAroundOrg">
            <summary>
            previous around the edge origin (reversed eRnext)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NextEdgeType.PreAroundDst">
            <summary>
            previous around the edge destination (reversed eLnext) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NextEdgeType.NextAroundLeft">
            <summary>
            next around the left facet (eLnext) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NextEdgeType.NextAroundRight">
            <summary>
            next around the right facet (eRnext)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NextEdgeType.PrevAroundLeft">
            <summary>
            previous around the left facet (reversed eOnext)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NextEdgeType.PrevAroundRight">
            <summary>
            previous around the right facet (reversed eDnext) 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Orientation">
            <summary>
            orientation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Orientation.Clockwise">
            <summary>
            clockwise
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Orientation.CounterClockwise">
            <summary>
            counter clockwise
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.StereoBmPrefilter">
            <summary>
            Stereo Block Matching Prefilter type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StereoBmPrefilter.NormalizedResponse">
            <summary>
            No prefilter
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StereoBmPrefilter.XSobel">
            <summary>
            XSobel
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HomographyMethod">
            <summary>
            Type of cvHomography method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HomographyMethod.Default">
            <summary>
            regular method using all the point pairs
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HomographyMethod.LMEDS">
            <summary>
            Least-Median robust method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HomographyMethod.Ransac">
            <summary>
            RANSAC-based robust method
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ContoursMatchType">
            <summary>
            Type used by cvMatchShapes
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ContoursMatchType.I1">
            <summary>
            I_1(A,B)=sum_{i=1..7} abs(1/m^A_i - 1/m^B_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary> 
        </member>
        <member name="F:Emgu.CV.CvEnum.ContoursMatchType.I2">
            <summary>
            I_2(A,B)=sum_{i=1..7} abs(m^A_i - m^B_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ContoursMatchType.I3">
            <summary>
            I_3(A,B)=sum_{i=1..7} abs(m^A_i - m^B_i)/abs(m^A_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Subdiv2DPointLocationType">
            <summary>
            The result type of cvSubdiv2DLocate.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.Error">
            <summary>
            One of input arguments is invalid.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.OutsideRect">
            <summary>
            Point is outside the subdivision reference rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.Inside">
            <summary>
            Point falls into some facet
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.Vertex">
            <summary>
            Point coincides with one of subdivision vertices
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.OnEdge">
            <summary>
            Point falls onto the edge
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.StereoRectifyType">
            <summary>
            Type used in cvStereoRectify
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StereoRectifyType.Default">
            <summary>
            Shift one of the image in horizontal or vertical direction (depending on the orientation of epipolar lines) in order to maximise the useful image area
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StereoRectifyType.CalibZeroDisparity">
            <summary>
            Makes the principal points of each camera have the same pixel coordinates in the rectified views
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BorderType">
            <summary>
            The type for CopyMakeBorder function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.NegativeOne">
            <summary>
            Used by some cuda methods, will pass the value -1 to the function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Constant">
            <summary>
            Border is filled with the fixed value, passed as last parameter of the function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Replicate">
            <summary>
            The pixels from the top and bottom rows, the left-most and right-most columns are replicated to fill the border
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Reflect">
            <summary>
            Reflect
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Wrap">
            <summary>
            Wrap
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Reflect101">
            <summary>
            Reflect 101
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Transparent">
            <summary>
            Transparent
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Default">
            <summary>
            The default border interpolation type.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Isolated">
            <summary>
            do not look outside of ROI
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HaarDetectionType">
            <summary>
            The types for haar detection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.Default">
            <summary>
            The default type where no optimization is done.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.DoCannyPruning">
            <summary>
            If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.ScaleImage">
            <summary>
            For each scale factor used the function will downscale the image rather than "zoom" the feature coordinates in the classifier cascade. Currently, the option can only be used alone, i.e. the flag can not be set together with the others
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.FindBiggestObject">
            <summary>
            If it is set, the function finds the largest object (if any) in the image. That is, the output sequence will contain one (or zero) element(s)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.DoRoughSearch">
            <summary>
            It should be used only when CV_HAAR_FIND_BIGGEST_OBJECT is set and min_neighbors &gt; 0. If the flag is set, the function does not look for candidates of a smaller size as soon as it has found the object (with enough neighbor candidates) at the current scale. Typically, when min_neighbors is fixed, the mode yields less accurate (a bit larger) object rectangle than the regular single-object mode (flags=CV_HAAR_FIND_BIGGEST_OBJECT), but it is much faster, up to an order of magnitude. A greater value of min_neighbors may be specified to improve the accuracy
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BackOrFront">
            <summary>
            Specific if it is back or front
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BackOrFront.Back">
            <summary>
            Back
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BackOrFront.Front">
            <summary>
            Front
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.StorageOp">
            <summary>
            The file storage operation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StorageOp.Read">
            <summary>
            The storage is open for reading
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StorageOp.Write">
            <summary>
            The storage is open for writing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StorageOp.Append">
            <summary>
            The storage is open for append
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HistogramCompMethod">
            <summary>
            Histogram comparison method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Correl">
            <summary>
            Correlation/ 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Chisqr">
            <summary>
            Chi-Square
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Intersect">
            <summary>
            Intersection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Bhattacharyya">
            <summary>
            Bhattacharyya distance
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Hellinger">
            <summary>
             Synonym for Bhattacharyya
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.ChisqrAlt">
            <summary>
            Alternative Chi-Square
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.OpticalflowFarnebackFlag">
            <summary>
            The available flags for Farneback optical flow computation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OpticalflowFarnebackFlag.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OpticalflowFarnebackFlag.UseInitialFlow">
            <summary>
            Use the input flow as the initial flow approximation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OpticalflowFarnebackFlag.FarnebackGaussian">
            <summary>
            Use a Gaussian winsize x winsizefilter instead of box
            filter of the same size for optical flow estimation. Usually, this option gives more accurate
            flow than with a box filter, at the cost of lower speed (and normally winsize for a
            Gaussian window should be set to a larger value to achieve the same level of robustness)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GrabcutInitType">
            <summary>
            Grabcut initialization type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GrabcutInitType.InitWithRect">
            <summary>
            Initialize with rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GrabcutInitType.InitWithMask">
            <summary>
            Initialize with mask
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GrabcutInitType.Eval">
            <summary>
            Eval
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CaptureType">
            <summary>
            CvCapture type. This is the equivalent to CV_CAP_ macros.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Any">
            <summary>
            Auto detect
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Mil">
            <summary>
            MIL proprietary drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Vfw">
            <summary>
            Platform native
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.V4L">
            <summary>
            Platform native
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.V4L2">
            <summary>
            Platform native
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Firewire">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.IEEE1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.DC1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.CMU1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Stereo">
            <summary>
            TYZX proprietary drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Tyzx">
            <summary>
            TYZX proprietary drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.TyzxLeft">
            <summary>
            TYZX proprietary drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.TyzxRight">
            <summary>
            TYZX proprietary drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.TyzxColor">
            <summary>
            TYZX proprietary drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.TyzxZ">
            <summary>
            TYZX proprietary drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.QT">
            <summary>
            QuickTime
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Unicap">
            <summary>
            Unicap drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.DShow">
            <summary>
            DirectShow (via videoInput)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Msmf">
            <summary>
            Microsoft Media Foundation (via videoInput)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Pvapi">
            <summary>
            PvAPI, Prosilica GigE SDK
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.OpenNI">
            <summary>
            OpenNI (for Kinect)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.OpenNIAsus">
            <summary>
            OpenNI (for Asus Xtion)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Android">
            <summary>
            Android
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.AndroidBack">
            <summary>
            Android back camera
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.AndroidFront">
            <summary>
            // Android front camera
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.XiApi">
            <summary>
            XIMEA Camera API
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.AVFoundation">
            <summary>
            AVFoundation framework for iOS (OS X Lion will have the same API)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Giganetix">
            <summary>
             Smartek Giganetix GigEVisionSDK
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.KMeansInitType">
            <summary>
            KMeans initialization type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.KMeansInitType.RandomCenters">
            <summary>
            Chooses random centers for k-Means initialization
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.KMeansInitType.UseInitialLabels">
            <summary>
            Uses the user-provided labels for K-Means initialization
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.KMeansInitType.PPCenters">
            <summary>
            Uses k-Means++ algorithm for initialization
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ColorMapType">
            <summary>
            The type of color map
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Autumn">
            <summary>
            Autumn
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Bone">
            <summary>
            Bone
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Jet">
            <summary>
            Jet
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Winter">
            <summary>
            Winter
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Rainbow">
            <summary>
            Rainbow
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Ocean">
            <summary>
            Ocean
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Summer">
            <summary>
            Summer
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Spring">
            <summary>
            Spring
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Cool">
            <summary>
            Cool
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Hsv">
            <summary>
            Hsv
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Pink">
            <summary>
            Pink
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Hot">
            <summary>
            Hot
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SolveLPResult">
            <summary>
            The return value for solveLP function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolveLPResult.Unbounded">
            <summary>
            Problem is unbounded (target function can achieve arbitrary high values)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolveLPResult.Unfeasible">
            <summary>
            Problem is unfeasible (there are no points that satisfy all the constraints imposed)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolveLPResult.Single">
            <summary>
            There is only one maximum for target function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolveLPResult.Multi">
            <summary>
            there are multiple maxima for target function - the arbitrary one is returned
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.MorphOp">
            <summary>
            Morphology operation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Erode">
            <summary>
            Erode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Dilate">
            <summary>
            Dilate
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Open">
            <summary>
            Open
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Close">
            <summary>
            Close
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Gradient">
            <summary>
            Gradient
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Tophat">
            <summary>
            Tophat
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Blackhat">
            <summary>
            Blackhat
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.AccessType">
            <summary>
            Access type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.Read">
            <summary>
            Read
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.Write">
            <summary>
            Write
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.ReadWrite">
            <summary>
            Read and write
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.Mask">
            <summary>
            Mask
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.Fast">
            <summary>
            Dast
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RectIntersectType">
            <summary>
            Rectangle intersect type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RectIntersectType.None">
            <summary>
            No intersection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RectIntersectType.Partial">
            <summary>
            There is a partial intersection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RectIntersectType.Full">
            <summary>
            One of the rectangle is fully enclosed in the other
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SolvePnpMethod">
            <summary>
            Method for solving a PnP problem
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolvePnpMethod.Iterative">
            <summary>
            Iterative
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolvePnpMethod.EPnP">
            <summary>
            F.Moreno-Noguer, V.Lepetit and P.Fua "EPnP: Efficient Perspective-n-Point Camera Pose Estimation"
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolvePnpMethod.P3P">
            <summary>
            X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang; "Complete Solution Classification for the Perspective-Three-Point Problem"
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Cuboid">
            <summary>
            A solid resembling a cube, with the rectangular faces not all equal; a rectangular parallelepiped.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Cuboid.Min">
            <summary>
            The coordinate of the upper corner
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Cuboid.Max">
            <summary>
            The coordinate of the lower corner
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Cuboid.Contains(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Check if the specific point is in the Cuboid
            </summary>
            <param name="point">The point to be checked</param>
            <returns>True if the point is in the cuboid</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Cuboid.Centroid">
            <summary>
            Get the centroid of this cuboid
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.CvStructSizes">
            <summary>
            This is used to hold the sizes of the Open CV structures
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint">
            <summary>
            The size of CvPoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint2D32f">
            <summary>
            The size of CvPoint2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint3D32f">
            <summary>
            The size of CvPoint3D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvSize">
            <summary>
            The size of CvSize
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvSize2D32f">
            <summary>
            The size of CvSize2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvScalar">
            <summary>
            The size of CvScalar
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvRect">
            <summary>
            The size of CvRect
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvBox2D">
            <summary>
            The size of CvBox2D
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvMat">
            <summary>
            The size of CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvMatND">
            <summary>
            The size of CvMatND
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvTermCriteria">
            <summary>
            The size of CvTermCriteria
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvSeq">
            <summary>
            The size of CvSeq
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvContour">
            <summary>
            The size of CvContour
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.IplImage">
            <summary>
            The size of IplImage
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvAvgComp">
            <summary>
            Result of cvHaarDetectObjects
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvAvgComp.Rect">
            <summary>
            Bounding rectangle for the object (average rectangle of a group)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvAvgComp.Neighbors">
            <summary>
            Number of neighbor rectangles in the group
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvBlob">
            <summary>
            Wrapper to the CvBlob structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlob.Center">
            <summary>
            The center of the blob 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlob.Size">
            <summary>
            Blob size
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlob.ID">
            <summary>
            Blob ID  
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBlob.op_Explicit(Emgu.CV.Structure.MCvBlob)~System.Drawing.RectangleF">
            <summary>
            Convert a MCvBlob to RectangleF
            </summary>
            <param name="blob">The blob</param>
            <returns>The equivalent RectangleF</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBlob.op_Explicit(Emgu.CV.Structure.MCvBlob)~System.Drawing.Rectangle">
            <summary>
            Convert a MCvBlob to RectangleF
            </summary>
            <param name="blob">The blob</param>
            <returns>The equivalent RectangleF</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBlob.Equals(Emgu.CV.Structure.MCvBlob)">
            <summary>
            Check if the two blobs are equal
            </summary>
            <param name="other">The blob to compares with</param>
            <returns>True if equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvBlob.Empty">
            <summary>
            Get an empty blob
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvChain">
            <summary>
            Managed structure equivalent to CvChain
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.flags">
            <summary>
             micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.header_size">
            <summary>
             size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.h_prev">
            <summary>
             previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.h_next">
            <summary>
             next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.v_prev">
            <summary>
             2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.v_next">
            <summary>
             2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.total">
            <summary>
             total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.elem_size">
            <summary>
             size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.block_max">
            <summary>
             maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.ptr">
            <summary>
             current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.delta_elems">
            <summary>
             how many elements allocated when the seq grows 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.storage">
            <summary>
             where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.free_blocks">
            <summary>
             free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.first">
            <summary>
             pointer to the first sequence block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.origin">
            <summary>
            The origin of the chain
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvConDensation">
            <summary>
            Managed structure equivalent to CvConDensation
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.MP">
            <summary>
            Dimension of measurement vector
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.DP">
            <summary>
            Dimension of state vector
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.DynamMatr">
            <summary>
            Matrix of the linear Dynamics system
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.State">
            <summary>
            Vector of State
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.SamplesNum">
            <summary>
            Number of the Samples
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.flSamples">
            <summary>
            Array of the Sample Vectors
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.flNewSamples">
            <summary>
            Temporary array of the Sample Vectors
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.flConfidence">
            <summary>
            Confidence for each Sample
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.flCumulative">
            <summary>
            Cumulative confidence
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.Temp">
            <summary>
            Temporary vector
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.RandomSample">
            <summary>
            RandomVector to update sample set
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.RandS">
            <summary>
            Array of structures to generate random vectors
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvConnectedComp">
            <summary>
            Managed structure equivalent to CvConnectedComp
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConnectedComp.Area">
            <summary>
            area of the segmented component
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConnectedComp.Value">
            <summary>
            scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConnectedComp.Rect">
            <summary>
            ROI of the segmented component
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConnectedComp.Contour">
            <summary>
            Pointer to the CvSeq
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvContour">
            <summary>
            Managed structure equivalent to CvContour
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.flags">
            <summary>
             Micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.header_size">
            <summary>
             Size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.h_prev">
            <summary>
             Pointer to the previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.h_next">
            <summary>
             Pointer to the next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.v_prev">
            <summary>
             Pointer to the 2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.v_next">
            <summary>
             Pointer to the 2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.total">
            <summary>
             Total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.elem_size">
            <summary>
             Size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.block_max">
            <summary>
             Maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.ptr">
            <summary>
             Current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.delta_elems">
            <summary>
             How many elements allocated when the seq grows 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.storage">
            <summary>
             Where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.free_blocks">
            <summary>
             Free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.first">
            <summary>
             Pointer to the first sequence block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.rect">
            <summary>
            If computed, stores the minimum enclosing rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.color">
            <summary>
            Color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.reserved0">
            <summary>
            Reserved0
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.reserved1">
            <summary>
            Reserved1
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.reserved2">
            <summary>
            Reserved2
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvConvexityDefect">
            <summary>
            Managed structure equivalent to CvConvexityDefect
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConvexityDefect.StartPointPointer">
            <summary>
            Pointer to the point of the contour where the defect begins
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConvexityDefect.EndPointPointer">
            <summary>
            Pointer to the point of the contour where the defect ends
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConvexityDefect.DepthPointPointer">
            <summary>
            Pointer to the farthest point from the convex hull within the defect
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConvexityDefect.Depth">
            <summary>
            Distance between the farthest point and the convex hull
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvConvexityDefect.StartPoint">
            <summary>
            Point of the contour where the defect begins
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvConvexityDefect.EndPoint">
            <summary>
            Point of the contour where the defect ends
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvConvexityDefect.DepthPoint">
            <summary>
            The farthest from the convex hull point within the defect
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvHuMoments">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.Hu1">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.Hu2">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.Hu3">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.Hu4">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.Hu5">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.Hu6">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.Hu7">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvKalman">
            <summary>
            Managed CvKalman structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.MP">
            <summary>
              number of measurement vector dimensions 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.DP">
            <summary>
              number of state vector dimensions 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.CP">
            <summary>
              number of control vector dimensions 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PosterState">
            <summary>
              =state_pre->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PriorState">
            <summary>
              =state_post->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.DynamMatr">
            <summary>
              =transition_matrix->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.MeasurementMatr">
            <summary>
              =measurement_matrix->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.MNCovariance">
            <summary>
              =measurement_noise_cov->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PNCovariance">
            <summary>
              =process_noise_cov->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.KalmGainMatr">
            <summary>
              =gain->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PriorErrorCovariance">
            <summary>
              =error_cov_pre->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PosterErrorCovariance">
            <summary>
              =error_cov_post->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.Temp1Data">
            <summary>
              temp1->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.Temp2Data">
            <summary>
              temp2->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.state_pre">
            <summary>
              predicted state (x'(k)):
                                                x(k)=A*x(k-1)+B*u(k) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.state_post">
            <summary>
              corrected state (x(k)):
                                                x(k)=x'(k)+K(k)*(z(k)-H*x'(k)) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.transition_matrix">
            <summary>
              state transition matrix (A) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.control_matrix">
            <summary>
              control matrix (B)
                                               (it is not used if there is no control)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.measurement_matrix">
            <summary>
              measurement matrix (H) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.process_noise_cov">
            <summary>
              process noise covariance matrix (Q) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.measurement_noise_cov">
            <summary>
              measurement noise covariance matrix (R) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.error_cov_pre">
            <summary>
              priori error estimate covariance matrix P'(k)=A*P(k-1)*At + Q)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.gain">
            <summary>
              Kalman gain matrix (K(k)):
                                                K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.error_cov_post">
            <summary>
              posteriori error estimate covariance matrix P(k)=(I-K(k)*H)*P'(k) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp1">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp2">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp3">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp4">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp5">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMat">
            <summary>
            Managed structure equivalent to CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Type">
            <summary>
            CvMat signature (CV_MAT_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Step">
            <summary>
            full row length in bytes
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.HdrRefcount">
            <summary>
            Header reference count
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Rows">
            <summary>
            number of rows
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Cols">
            <summary>
            number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.NumberOfChannels">
            <summary>
            Get the number of channels
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatConstants">
            <summary>
            Constants used by the MCvMat structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatConstants.TypeOffset">
            <summary>
            Offset of roi
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatND">
            <summary>
            Managed structure equivalent to CvMatND
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.type">
            <summary>
            CvMatND signature (CV_MATND_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dims">
            <summary>
            number of array dimensions
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.hdr_refcount">
            <summary>
            Header reference count
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim0">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim1">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim2">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim3">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim4">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim5">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim6">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim7">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim8">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim9">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim10">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim11">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim12">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim13">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim14">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim15">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim16">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim17">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim18">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim19">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim20">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim21">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim22">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim23">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim24">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim25">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim26">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim27">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim28">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim29">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim30">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim31">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.dim">
            <summary>
            pairs (number of elements, distance between elements in bytes) for every dimension
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatND.Dimension">
            <summary>
            The MatND Dimension
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.Dimension.Size">
            <summary>
            Number of elements in this dimension
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.Dimension.Step">
            <summary>
            distance between elements in bytes for this dimension
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMoments">
            <summary>
            spatial and central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M00">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M10">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M01">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M20">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M11">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M02">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M30">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M21">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M12">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M03">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu20">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu11">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu02">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu30">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu21">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu12">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu03">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.InvSqrtM00">
            <summary>
            m00 != 0 ? 1/sqrt(m00) : 0
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetSpatialMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves the spatial moment, which in case of image moments is defined as:
            M_{x_order,y_order}=sum_{x,y}(I(x,y) * x^{x_order} * y^{y_order})
            where I(x,y) is the intensity of the pixel (x, y). 
            </summary>
            <param name="xOrder">x order of the retrieved moment, x_order &gt;= 0</param>
            <param name="yOrder">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The spatial moment of the specific order</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetCentralMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves the central moment, which in case of image moments is defined as:
            mu_{x_order,y_order}=sum_{x,y}(I(x,y)*(x-x_c)^{x_order} * (y-y_c)^{y_order}),
            where x_c=M10/M00, y_c=M01/M00 - coordinates of the gravity center
            </summary>
            <param name="xOrder">x order of the retrieved moment, x_order &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The center moment</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetNormalizedCentralMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves normalized central moment, which in case of image moments is defined as:
            eta_{x_order,y_order}=mu_{x_order,y_order} / M00^{(y_order+x_order)/2+1},
            where mu_{x_order,y_order} is the central moment
            </summary>
            <param name="xOrder">x order of the retrieved moment, x_order &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The normalized center moment</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetHuMoment">
            <summary>
            Get the HuMoments 
            </summary>
            <returns>The Hu moment computed from this moment</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMoments.GravityCenter">
            <summary>
            The Gravity Center of this Moment
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvObjectDetection">
            <summary>
            Structure contains the bounding box and confidence level for detected object
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvObjectDetection.Rect">
            <summary>
            Bounding box for a detected object
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvObjectDetection.Score">
            <summary>
            Confidence level 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint2D64f">
            <summary>
            Managed Structure equivalent to CvPoint2D64f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint2D64f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint2D64f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.#ctor(System.Double,System.Double)">
            <summary>
            Create a MCvPoint2D64f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Addition(Emgu.CV.Structure.MCvPoint2D64f,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Subtraction(Emgu.CV.Structure.MCvPoint2D64f,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Subtract <paramref name="p2"/> from <paramref name="p1"/>
            </summary>
            <param name="p1">The first point</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Multiply(Emgu.CV.Structure.MCvPoint2D64f,System.Double)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Multiply(System.Double,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.Equals(Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Returns true if the two points equals.
            </summary>
            <param name="other">The other point to compare with</param>
            <returns>True if the two points equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint3D32f">
            <summary>
            Managed Structure equivalent to CvPoint3D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.Z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Create a MCvPoint3D32f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.CrossProduct(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return the cross product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The cross product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.DotProduct(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return the dot product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The dot product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.GetNormalizedPoint">
            <summary>
            Get the normalized point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Implicit(Emgu.CV.Structure.MCvPoint3D32f)~Emgu.CV.Structure.MCvPoint3D64f">
            <summary>
            The implicit operator to convert MCvPoint3D32f to MCvPoint3D64f
            </summary>
            <param name="point">The point to be converted</param>
            <returns>The converted point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Subtraction(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Subtract one point from the other
            </summary>
            <param name="p1">The point to subtract from</param>
            <param name="p2">The value to be subtracted</param>
            <returns>The subtraction of one point from the other</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Addition(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Multiply(Emgu.CV.Structure.MCvPoint3D32f,System.Single)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Multiply(System.Single,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.Equals(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return true if the location of the two points are equal
            </summary>
            <param name="other">The other point to compare with</param>
            <returns>True if the location of the two points are equal</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvPoint3D32f.Norm">
            <summary>
            return the norm of this 3D point
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint3D64f">
            <summary>
            Managed Structure equivalent to CvPoint3D64f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.Z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a MCvPoint3D64f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.CrossProduct(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Return the cross product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The cross product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.DotProduct(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Return the dot product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The dot product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Addition(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Subtraction(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Subtract <paramref name="p2"/> from <paramref name="p1"/>
            </summary>
            <param name="p1">The first point</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Multiply(Emgu.CV.Structure.MCvPoint3D64f,System.Double)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Multiply(System.Double,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.Equals(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Check if the other point equals to this point
            </summary>
            <param name="other">The point to be compared</param>
            <returns>True if the two points are equal</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvScalar">
            <summary>
            Managed structure equivalent to CvScalar 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V0">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V1">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V2">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V3">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.ToArray">
            <summary>
            The scalar values as a vector (of size 4)
            </summary>
            <returns>The scalar values as an array</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
            <param name="v2">v2</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
            <param name="v2">v2</param>
            <param name="v3">v3</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.ToCode(Emgu.Util.TypeEnum.ProgrammingLanguage)">
            <summary>
            Return the code to generate this MCvScalar from specific language
            </summary>
            <param name="language">The programming language to generate code from</param>
            <returns>The code to generate this MCvScalar from specific language</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.Equals(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Return true if the two MCvScalar equals
            </summary>
            <param name="other">The other MCvScalar to compare with</param>
            <returns>true if the two MCvScalar equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSeq">
            <summary>
            Managed structure equivalent to CvSeq
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.flags">
            <summary>
             Micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.header_size">
            <summary>
             Size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.h_prev">
            <summary>
             Previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.h_next">
            <summary>
             Next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.v_prev">
            <summary>
             2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.v_next">
            <summary>
             2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.total">
            <summary>
             Total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.elem_size">
            <summary>
             Size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.block_max">
            <summary>
             Maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.ptr">
            <summary>
             Current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.delta_elems">
            <summary>
             How many elements allocated when the sequence grows (sequence granularity 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.storage">
            <summary>
             Where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.free_blocks">
            <summary>
             Free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.first">
            <summary>
             Pointer to the first sequence block 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSeqBlock">
            <summary>
            Managed structure equivalent to CvSeqBlock
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.prev">
            <summary>
            Previous sequence block.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.next">
            <summary>
            Next sequence block.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.start_index">
            <summary>
            Index of the first element in the block + sequence-&gt;first-&gt;start_index.   
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.count">
            <summary>
            Number of elements in the block.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.data">
            <summary>
            Pointer to the first element of the block.
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSeqReader">
            <summary>
            Wrapped CvSeqReader structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.header_size">
            <summary>
            The size of the header
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.seq">
            <summary>
            sequence, beign read
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.block">
            <summary>
            current block
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.ptr">
            <summary>
            pointer to element be read next 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.block_min">
            <summary>
             pointer to the beginning of block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.block_max">
            <summary>
            pointer to the end of block
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.delta_index">
            <summary>
            = seq->first->start_index 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.prev_elem">
            <summary>
            pointer to previous element
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSet">
            <summary>
            Wrapper CvSet structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.flags">
            <summary>
             micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.header_size">
            <summary>
             size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.h_prev">
            <summary>
             previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.h_next">
            <summary>
             next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.v_prev">
            <summary>
             2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.v_next">
            <summary>
             2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.total">
            <summary>
             total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.elem_size">
            <summary>
            size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.block_max">
            <summary>
            maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.ptr">
            <summary>
             current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.delta_elems">
            <summary>
             how many elements allocated when the sequence grows (sequence granularity 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.storage">
            <summary>
             where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.free_blocks">
            <summary>
             free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.first">
            <summary>
             pointer to the first sequence block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.free_elems">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.active_count">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSetElem">
            <summary>
            Wrapper CvSetElem structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSetElem.flags">
            <summary>
            flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSetElem.next_free">
            <summary>
            next_free
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSlice">
            <summary>
            Managed structure equivalent to CvSlice
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSlice.start_index">
            <summary>
            Start index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSlice.end_index">
            <summary>
            End index
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSlice.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new MCvSlice using the specific start and end index
            </summary>
            <param name="start">start index</param>
            <param name="end">end index</param>
        </member>
        <member name="P:Emgu.CV.Structure.MCvSlice.WholeSeq">
            <summary>
            Get the equivalent of CV_WHOLE_SEQ
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvStereoBMState">
            <summary>
            Wrapped CvStereoBMState structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilterType">
            <summary>
            0 for now
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilterSize">
            <summary>
            ~5x5..21x21
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilterCap">
            <summary>
            up to ~31
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.SADWindowSize">
            <summary>
            Could be 5x5..21x21. Correspondence using Sum of Absolute Difference (SAD):
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.minDisparity">
            <summary>
            minimum disparity (=0)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.numberOfDisparities">
            <summary>
            maximum disparity - minimum disparity
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.textureThreshold">
            <summary>
            areas with no texture are ignored
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.uniquenessRatio">
            <summary>
            Filter out pixels if there are other close matches
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.speckleWindowSize">
            <summary>
            Disparity variation window (not used)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.speckleRange">
            <summary>
            Acceptable range of variation in window (not used)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.trySmallerWindows">
            <summary>
            If 1, the results may be more accurate at the expense of slower processing.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.roi1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.roi2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.disp12MaxDiff">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilteredImg0">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilteredImg1">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.slidingSumBuf">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.cost">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.disp">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvStereoGCState">
            <summary>
            Wrapped CvStereoGCState structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.Ithreshold">
            <summary>
            Threshold for piece-wise linear data cost function (5 by default)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.interactionRadius">
            <summary>
            Radius for smoothness cost function (1 by default; means Potts model)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.K">
            <summary>
            Parameters for the cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.lambda">
            <summary>
            Parameters for the cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.lambda1">
            <summary>
            Parameters for the cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.lambda2">
            <summary>
            Parameters for the cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.occlusionCost">
            <summary>
            10000 by default, (usually computed adaptively from the input data)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.minDisparity">
            <summary>
            0 by default; see CvStereoBMState
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.numberOfDisparities">
            <summary>
            Defined by user; see CvStereoBMState
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.maxIters">
            <summary>
            Number of iterations; defined by user.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.left">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.right">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.dispLeft">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.dispRight">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.ptrLeft">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.ptrRight">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.vtxBuf">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.edgeBuf">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvTermCriteria">
            <summary>
            Managed structure equivalent to CvTermCriteria
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.Type">
            <summary>
            CV_TERMCRIT value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.MaxIter">
            <summary>
            Maximum iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.Epsilon">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Int32)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Double)">
            <summary>
            Create the termination Criteria using only the constrain of epsilon
            </summary>
            <param name="eps"> The epsilon value</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Int32,System.Double)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration as well as epsilon
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
            <param name="eps">The epsilon value</param>
        </member>
        <member name="T:Emgu.CV.Structure.MDMatch">
            <summary>
            OpenCV's DMatch structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.QueryIdx">
            <summary>
            Query descriptor index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.TrainIdx">
            <summary>
            Train descriptor index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.ImgIdx">
            <summary>
            Train image index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.Distance">
            <summary>
            Distance
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MIplImage">
            <summary>
            Managed structure equivalent to IplImage
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.NSize">
            <summary>
            sizeof(IplImage) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ID">
            <summary>
            version (=0)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.NChannels">
            <summary>
            Most of OpenCV functions support 1,2,3 or 4 channels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.AlphaChannel">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Depth">
            <summary>
            pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U, IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel0">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel1">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel2">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel3">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq0">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq1">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq2">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq3">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.DataOrder">
            <summary>
            0 - interleaved color channels, 1 - separate color channels.
            cvCreateImage can only create interleaved images 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Origin">
            <summary>
            0 - top-left origin,
            1 - bottom-left origin (Windows bitmaps style)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Align">
            <summary>
            Alignment of image rows (4 or 8).
            OpenCV ignores it and uses widthStep instead 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Width">
            <summary>
            image width in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Height">
            <summary>
            image height in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Roi">
            <summary>
            image ROI. when it is not NULL, this specifies image region to process 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.MaskROI">
            <summary>
            must be NULL in OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageId">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.TileInfo">
            <summary>
            ditto 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageSize">
            <summary>
            image data size in bytes
            (=image->height*image->widthStep in case of interleaved data)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageData">
            <summary>
            pointer to aligned image data 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.WidthStep">
            <summary>
            size of aligned image row in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode0">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode1">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode2">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode3">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst0">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst1">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst2">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst3">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageDataOrigin">
            <summary>
             pointer to a very origin of image data (not necessarily aligned) - it is needed for correct image deallocation 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MKeyPoint">
            <summary>
            OpenCV's KeyPoint class
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Point">
            <summary>
            The location of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Size">
            <summary>
            Size of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Angle">
            <summary>
            Orientation of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Response">
            <summary>
            Response of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Octave">
            <summary>
            octave
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.ClassId">
            <summary>
            class id
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.RangeF">
            <summary>
            The range use to setup the histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.RangeF.#ctor(System.Single,System.Single)">
            <summary>
            Create a range of the specific min/max value
            </summary>
            <param name="min">The min value of this range</param>
            <param name="max">The max value of this range</param>
        </member>
        <member name="M:Emgu.CV.Structure.RangeF.Equals(Emgu.CV.Structure.RangeF)">
            <summary>
            Return true if the two RangeF equals
            </summary>
            <param name="other">The other RangeF to compare with</param>
            <returns>True if the two RangeF equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.RangeF.Min">
            <summary>
            The minimum value of this range
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.RangeF.Max">
            <summary>
            The Maximum value of this range
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.RotatedRect">
            <summary>
            Managed structure equivalent to CvBox2D
            </summary>
        </member>
        <member name="T:Emgu.CV.IConvexPolygonF">
            <summary>
            An interface for the convex polygon
            </summary>
        </member>
        <member name="M:Emgu.CV.IConvexPolygonF.GetVertices">
            <summary>
            Get the vertices of this convex polygon
            </summary>
            <returns>The vertices of this convex polygon</returns>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Center">
            <summary>
            The center of the box
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Size">
            <summary>
            The size of the box
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Angle">
            <summary>
            The angle between the horizontal axis and the first side (i.e. width) in degrees
            </summary>
            <remarks>Possitive value means counter-clock wise rotation</remarks>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.#ctor(System.Drawing.PointF,System.Drawing.SizeF,System.Single)">
            <summary>
            Create a RotatedRect structure with the specific parameters
            </summary>
            <param name="center">The center of the box</param>
            <param name="size">The size of the box</param>
            <param name="angle">The angle of the box in degrees. Possitive value means counter-clock wise rotation</param>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.Offset(System.Int32,System.Int32)">
            <summary>
            Shift the box by the specific amount
            </summary>
            <param name="x">The x value to be offseted</param>
            <param name="y">The y value to be offseted</param>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.GetVertices">
            <summary>
            Get the 4 verticies of this Box.
            </summary>
            <returns>The vertives of this RotatedRect</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.MinAreaRect">
            <summary>
            Get the minimum enclosing rectangle for this Box
            </summary>
            <returns>The minimum enclosing rectangle for this Box</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.Equals(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Returns true if the two box are equal
            </summary>
            <param name="other">The other box to compare with</param>
            <returns>True if two boxes are equal</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.op_Implicit(System.Drawing.RectangleF)~Emgu.CV.Structure.RotatedRect">
            <summary>
            Convert a RectangleF to RotatedRect
            </summary>
            <param name="rectangle">The rectangle</param>
            <returns>The equivalent RotatedRect</returns>
        </member>
        <member name="P:Emgu.CV.Structure.RotatedRect.Empty">
            <summary>
            Represent an uninitialized RotatedRect
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment2D">
            <summary> 
            A line segment 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2D._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2D._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.#ctor(System.Drawing.Point,System.Drawing.Point)">
            <summary> 
            Create a line segment with the specific starting point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.Side(System.Drawing.Point)">
            <summary>
            Determine which side of the line the 2D point is at
            </summary>
            <param name="point">the point</param>
            <returns>
            1 if on the right hand side;
            0 if on the line;
            -1 if on the left hand side;
            </returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.GetExteriorAngleDegree(Emgu.CV.Structure.LineSegment2D)">
            <summary>
            Get the exterior angle between this line and <paramref name="otherLine"/>
            </summary>
            <param name="otherLine">The other line</param>
            <returns>The exterior angle between this line and <paramref name="otherLine"/></returns>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.Direction">
            <summary> The direction of the line, the norm of which is 1 </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment2DF">
            <summary> 
            A line segment 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2DF._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2DF._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.#ctor(System.Drawing.PointF,System.Drawing.PointF)">
            <summary> 
            Create a line segment with the specific start point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.YByX(System.Single)">
            <summary> Obtain the Y value from the X value using first degree interpolation</summary>
            <param name="x">The X value</param>
            <returns>The Y value</returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.Side(System.Drawing.PointF)">
            <summary>
            Determin which side of the line the 2D point is at
            </summary>
            <param name="point">the point</param>
            <returns>
            1 if on the right hand side;
            0 if on the line;
            -1 if on the left hand side;
            </returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.GetExteriorAngleDegree(Emgu.CV.Structure.LineSegment2DF)">
            <summary>
            Get the exterior angle between this line and <paramref name="otherLine"/>
            </summary>
            <param name="otherLine">The other line</param>
            <returns>The exterior angle between this line and <paramref name="otherLine"/></returns>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.Direction">
            <summary> 
            The direction of the line, the norm of which is 1 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment3DF">
            <summary>
            A 3D line segment
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment3DF._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment3DF._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment3DF.#ctor(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary> 
            Create a line segment with the specific start point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="T:Emgu.CV.PointCollection">
            <summary>
            A collection of points
            </summary>
        </member>
        <member name="M:Emgu.CV.PointCollection.EllipseLeastSquareFitting(System.Drawing.PointF[])">
            <summary>
            Fit an ellipse to the points collection
            </summary>
            <param name="points">The points to be fitted</param>
            <returns>An ellipse</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.PolyLine(System.Drawing.PointF[],System.Boolean)">
            <summary>
            convert a series of points to LineSegment2D
            </summary>
            <param name="points">the array of points</param>
            <param name="closed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <returns>array of LineSegment2D</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.PolyLine(System.Drawing.Point[],System.Boolean)">
            <summary>
            convert a series of System.Drawing.Point to LineSegment2D
            </summary>
            <param name="points">the array of points</param>
            <param name="closed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <returns>array of LineSegment2D</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.BoundingRectangle(System.Drawing.PointF[])">
            <summary>
            Find the bounding rectangle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The bounding rectangle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.ReprojectImageTo3D(Emgu.CV.Mat,Emgu.CV.IInputArray)">
            <summary>
            Re-project pixels on a 1-channel disparity map to array of 3D points.
            </summary>
            <param name="disparity">Disparity map</param>
            <param name="Q">The re-projection 4x4 matrix, can be arbitrary, e.g. the one, computed by cvStereoRectify</param>
            <returns>The reprojected 3D points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.GeneratePointCloud(Emgu.CV.Structure.Ellipse,System.Int32)">
            <summary>
            Generate a random point cloud around the ellipse. 
            </summary>
            <param name="e">The region where the point cloud will be generated. The axes of e corresponds to std of the random point cloud.</param>
            <param name="numberOfPoints">The number of points to be generated</param>
            <returns>A random point cloud around the ellipse</returns>
        </member>
        <member name="T:Emgu.CV.Properties.StringTable">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.BoundingRectangleNotCalculated">
            <summary>
              Looks up a localized string similar to The bounding rectangle is not calculated, consider calling CvInvoke.cvBoundingRect(thisContour, 1) first..
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.FailToCreateHaarCascade">
            <summary>
              Looks up a localized string similar to Fail to create HaarCascade object: {0}.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.FileNotFound">
            <summary>
              Looks up a localized string similar to File Not Found.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.IncompatibleDimension">
            <summary>
              Looks up a localized string similar to Incompatible Dimension.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.NotImplemented">
            <summary>
              Looks up a localized string similar to Not implmented.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.ThicknessShouldBeGreaterThanZero">
            <summary>
              Looks up a localized string similar to Thickness should be &gt; 0.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.UnsupportedImageDepth">
            <summary>
              Looks up a localized string similar to Unsupported image depth.
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.ExposableMethodAttribute">
            <summary>
            Attribute used by ImageBox to generate Operation Menu
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ExposableMethodAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.Exposable">
            <summary>
            Get or Set the exposable value, if true, this function will be displayed in Operation Menu of ImageBox
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.Category">
            <summary>
            The catefory of this function
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.GenericParametersOptionSizes">
            <summary>
            The size for each generic parameter Options
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.GenericParametersOptions">
            <summary>
            The options for generic parameters
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.GenericParameter">
            <summary>
            A generic parameter for the Operation class
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.GenericParameter.#ctor(System.Type,System.Type[])">
            <summary>
            Create a generic parameter for the Operation class
            </summary>
            <param name="selectedType">The selected generic parameter typ</param>
            <param name="availableType">The types that can be used</param>
        </member>
        <member name="P:Emgu.CV.Reflection.GenericParameter.SelectedType">
            <summary>
            The selected generic parameter type
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.GenericParameter.AvailableTypes">
            <summary>
            The types that can be used
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.ReflectColorType">
            <summary>
            A collection of reflection function that can be applied to ColorType object
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectColorType.GetDisplayColorOfChannels(Emgu.CV.IColor)">
            <summary>
            Get the display color for each channel
            </summary>
            <param name="color">The color</param>
            <returns>The display color for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectColorType.GetNamesOfChannels(Emgu.CV.IColor)">
            <summary>
            Get the names of the channels
            </summary>
            <param name="color">The color</param>
            <returns>The names of the channels</returns>
        </member>
        <member name="T:Emgu.CV.Reflection.ReflectIImage">
            <summary>
            A collection of reflection function that can be applied to IImage object
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetImageMethods(Emgu.CV.IImage)">
            <summary>
            Get all the methods that belongs to the IImage and Image class with ExposableMethodAttribute set true.
            </summary>
            <param name="image">The IImage object to be refelected for methods marked with ExposableMethodAttribute</param>
            <returns>All the methods that belongs to the IImage and Image class with ExposableMethodAttribute set true</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetTypeOfColor(Emgu.CV.IImage)">
            <summary>
            Get the color type of the image
            </summary>
            <param name="image">The image to apply reflection on</param>
            <returns>The color type of the image</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetTypeOfDepth(Emgu.CV.IImage)">
            <summary>
            Get the depth type of the image
            </summary>
            <param name="image">The image to apply reflection on</param>
            <returns>The depth type of the image</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetPixelColor(Emgu.CV.IImage,System.Drawing.Point)">
            <summary>
            Get the color at the specific location of the image
            </summary>
            <param name="image">The image to obtain pixel value from</param>
            <param name="location">The location to sample a pixel</param>
            <returns>The color at the specific location</returns>
        </member>
        <member name="T:Emgu.CV.Structure.CircleF">
            <summary> A circle </summary>
        </member>
        <member name="M:Emgu.CV.Structure.CircleF.#ctor(System.Drawing.PointF,System.Single)">
            <summary> Create a circle with the specific center and radius </summary>
            <param name="center"> The center of this circle </param>
            <param name="radius"> The radius of this circle </param>
        </member>
        <member name="M:Emgu.CV.Structure.CircleF.Equals(Emgu.CV.Structure.CircleF)">
            <summary>
            Compare this circle with <paramref name="circle2"/>
            </summary>
            <param name="circle2">The other box to be compared</param>
            <returns>true if the two boxes equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Center">
            <summary> Get or Set the center of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Radius">
            <summary> The radius of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Area">
            <summary> The area of the circle </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Cross2DF">
            <summary>
            A 2D cross
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Cross2DF.#ctor(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            Construct a cross
            </summary>
            <param name="center">The center of the cross</param>
            <param name="width">the width of the cross</param>
            <param name="height">the height of the cross</param>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Center">
            <summary>
            The center of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Size">
            <summary>
            The size of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Horizontal">
            <summary>
            Get the horizonal linesegment of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Vertical">
            <summary>
            Get the vertical linesegment of this cross
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Ellipse">
            <summary>
            An ellipse
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ellipse.#ctor(System.Drawing.PointF,System.Drawing.SizeF,System.Single)">
            <summary>
            Create an ellipse with specific parameters
            </summary>
            <param name="center"> The center of the ellipse</param>
            <param name="size"> The width and height of the ellipse</param>
            <param name="angle"> The rotation angle in radian for the ellipse</param>
        </member>
        <member name="M:Emgu.CV.Structure.Ellipse.#ctor(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Create an ellipse from the specific RotatedRect
            </summary>
            <param name="box2d">The RotatedRect representation of this ellipse</param>
        </member>
        <member name="P:Emgu.CV.Structure.Ellipse.RotatedRect">
            <summary>
            The RotatedRect representation of this ellipse
            </summary>
        </member>
        <member name="T:Emgu.CV.IConvexPolygon">
            <summary>
            An interface for the convex polygon
            </summary>
        </member>
        <member name="M:Emgu.CV.IConvexPolygon.GetVertices">
            <summary>
            Get the vertices of this convex polygon
            </summary>
            <returns>The vertices of this convex polygon</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Triangle2DF">
            <summary>
            A 2D triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.#ctor(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Create a triangle using the specific vertices
            </summary>
            <param name="v0">The first vertex</param>
            <param name="v1">The second vertex</param>
            <param name="v2">The third vertex</param>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.Equals(Emgu.CV.Structure.Triangle2DF)">
            <summary>
            Compare two triangles and return true if equal
            </summary>
            <param name="tri">the other triangles to compare with</param>
            <returns>true if the two triangles equals, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.GetVertices">
            <summary>
            Get the vertices of this triangle
            </summary>
            <returns>The vertices of this triangle</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V0">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V1">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V2">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.Area">
            <summary>
            Get the area of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.Centeroid">
            <summary>
            Returns the centroid of this triangle
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Triangle3DF">
            <summary>
            A 3D triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle3DF.#ctor(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Create a triangle using the specific vertices
            </summary>
            <param name="v0">The first vertex</param>
            <param name="v1">The second vertex</param>
            <param name="v2">The third vertex</param>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle3DF.Equals(Emgu.CV.Structure.Triangle3DF)">
            <summary>
            Compare two triangles and return true if equal
            </summary>
            <param name="tri">the other triangles to compare with</param>
            <returns>true if the two triangles equals, false otherwise</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V0">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V1">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V2">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Area">
            <summary>
            Get the area of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Normal">
            <summary>
            Get the normal of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Centeroid">
            <summary>
            Returns the centroid of this triangle
            </summary>
        </member>
        <member name="T:Emgu.CV.SparseMatrix`1">
            <summary>
            Create a sparse matrix
            </summary>
            <typeparam name="TDepth">The type of elements in this matrix</typeparam>
        </member>
        <member name="M:Emgu.CV.SparseMatrix`1.#ctor(System.Int32[])">
            <summary>
            Create a sparse matrix of the specific dimension
            </summary>
            <param name="dimension">The dimension of the sparse matrix</param>
        </member>
        <member name="M:Emgu.CV.SparseMatrix`1.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this sparse matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.SparseMatrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns>The element on the specific <paramref name="row"/> and <paramref name="col"/></returns>
        </member>
        <member name="T:Emgu.CV.StereoBM">
            <summary>
            Class for computing stereo correspondence using the block matching algorithm, introduced and contributed to OpenCV by K. Konolige.
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoBM.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a stereoBM object
            </summary>
            <param name="blockSize">the linear size of the blocks compared by the algorithm. The size should be odd (as the block is centered at the current pixel). Larger block size implies smoother, though less accurate disparity map. Smaller block size gives more detailed disparity map, but there is higher chance for algorithm to find a wrong correspondence.</param>
            <param name="numberOfDisparities">the disparity search range. For each pixel algorithm will find the best disparity from 0 (default minimum disparity) to <paramref name="numberOfDisparities"/>. The search range can then be shifted by changing the minimum disparity.</param>
        </member>
        <member name="M:Emgu.CV.StereoBM.DisposeObject">
            <summary>
            Release the stereo state and all the memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.StereoBM.StereoMatcherPtr">
            <summary>
            Pointer to the stereo matcher
            </summary>
        </member>
        <member name="T:Emgu.CV.StereoMatcherExtensions">
            <summary>
            Extension methods for StereoMather
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoMatcherExtensions.Compute(Emgu.CV.IStereoMatcher,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes disparity map for the specified stereo pair
            </summary>
            <param name="matcher">The stereo matcher</param>
            <param name="left">Left 8-bit single-channel image.</param>
            <param name="right">Right image of the same size and the same type as the left one.</param>
            <param name="disparity">Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map</param>
        </member>
        <member name="T:Emgu.CV.StereoSGBM">
            <summary>
            This is a variation of
            "Stereo Processing by Semiglobal Matching and Mutual Information"
            by Heiko Hirschmuller.
            We match blocks rather than individual pixels, thus the algorithm is called
            SGBM (Semi-global block matching)
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoSGBM.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.StereoSGBM.Mode)">
            <summary>
            Create a stereo disparity solver using StereoSGBM algorithm (combination of H. Hirschmuller + K. Konolige approaches) 
            </summary>
            <param name="minDisparity">Minimum possible disparity value. Normally, it is zero but sometimes rectification algorithms can shift images, so this parameter needs to be adjusted accordingly.</param>
            <param name="numDisparities">Maximum disparity minus minimum disparity. The value is always greater than zero. In the current implementation, this parameter must be divisible by 16.</param>
            <param name="blockSize">Matched block size. It must be an odd number &gt;=1 . Normally, it should be somewhere in the 3..11 range. Use 0 for default. </param>
            <param name="p1">The first parameter controlling the disparity smoothness. It is the penalty on the disparity change by plus or minus 1 between neighbor pixels. Reasonably good value is 8*number_of_image_channels*SADWindowSize*SADWindowSize. Use 0 for default</param>
            <param name="p2">The second parameter controlling the disparity smoothness. It is the penalty on the disparity change by more than 1 between neighbor pixels. The algorithm requires <paramref name="p2"/> &gt; <paramref name="p1"/>. Reasonably good value is 32*number_of_image_channels*SADWindowSize*SADWindowSize. Use 0 for default</param>
            <param name="disp12MaxDiff">Maximum allowed difference (in integer pixel units) in the left-right disparity check. Set it to a non-positive value to disable the check.</param>
            <param name="preFilterCap">Truncation value for the prefiltered image pixels. The algorithm first computes x-derivative at each pixel and clips its value by [-preFilterCap, preFilterCap] interval. The result values are passed to the Birchfield-Tomasi pixel cost function.</param>
            <param name="uniquenessRatio">Margin in percentage by which the best (minimum) computed cost function value should win the second best value to consider the found match correct. Normally, a value within the 5-15 range is good enough.</param>
            <param name="speckleWindowSize">Maximum size of smooth disparity regions to consider their noise speckles and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the 50-200 range</param>
            <param name="speckleRange">Maximum disparity variation within each connected component. If you do speckle filtering, set the parameter to a positive value, it will be implicitly multiplied by 16. Normally, 1 or 2 is good enough.</param>
            <param name="mode">Set it to HH to run the full-scale two-pass dynamic programming algorithm. It will consume O(W*H*numDisparities) bytes, which is large for 640x480 stereo and huge for HD-size pictures. By default, it is set to false.</param>
        </member>
        <member name="M:Emgu.CV.StereoSGBM.DisposeObject">
            <summary>
            Release the unmanged memory associated with this stereo solver
            </summary>
        </member>
        <member name="P:Emgu.CV.StereoSGBM.StereoMatcherPtr">
            <summary>
            Pointer to the StereoMatcher 
            </summary>
        </member>
        <member name="T:Emgu.CV.StereoSGBM.Mode">
            <summary>
            The SGBM mode
            </summary>
        </member>
        <member name="F:Emgu.CV.StereoSGBM.Mode.SGBM">
            <summary>
            This is the default mode, the algorithm is single-pass, which means that you consider only 5 directions instead of 8
            </summary>
        </member>
        <member name="F:Emgu.CV.StereoSGBM.Mode.HH">
            <summary>
            Run the full-scale two-pass dynamic programming algorithm. It will consume O(W*H*numDisparities) bytes, which is large for 640x480 stereo and huge for HD-size pictures.
            </summary>
        </member>
        <member name="T:Emgu.CV.Subdiv2D">
            <summary>
            Planar Subdivision, can be use to compute Delaunnay's triangulation or Voroni diagram.
            </summary>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.#ctor(System.Drawing.Rectangle)">
            <summary>
            Start the Delaunay's triangulation in the specific region of interest.
            </summary>
            <param name="roi">The region of interest of the triangulation</param>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.#ctor(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Create a planar subdivision from the given points. The ROI is computed as the minimum bounding Rectangle for the input points
            </summary>
            <param name="silent">If true, any exception during insert will be ignored</param>
            <param name="points">The points to be inserted to this planar subdivision</param>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.Insert(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Insert a collection of points to this planar subdivision
            </summary>
            <param name="points">The points to be inserted to this planar subdivision</param>
            <param name="silent">If true, any exception during insert will be ignored</param>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.Insert(System.Drawing.PointF)">
            <summary>
            Insert a point to the triangulation. 
            </summary>
            <param name="point">The point to be inserted</param>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.Locate(System.Drawing.PointF,System.Int32@,System.Int32@)">
            <summary>
            Locates input point within subdivision
            </summary>
            <param name="pt">The point to locate</param>
            <param name="subdiv2DEdge">The output edge the point falls onto or right to</param>
            <param name="subdiv2DPoint">Optional output vertex double pointer the input point coincides with</param>
            <returns>The type of location for the point</returns>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.FindNearest(System.Drawing.PointF,System.Drawing.PointF@)">
            <summary>
            Finds subdivision vertex that is the closest to the input point. It is not necessarily one of vertices of the facet containing the input point, though the facet (located using cvSubdiv2DLocate) is used as a starting point.
            </summary>
            <param name="point">Input point</param>
            <param name="nearestPoint">The nearest subdivision vertex</param>
            <returns>The location type of the point</returns>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.GetVoronoiFacets(System.Int32[])">
            <summary>
            Obtains the list of Voronoi Facets 
            </summary>
            <returns>The list of Voronoi Facets</returns>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.GetDelaunayTriangles(System.Boolean)">
            <summary>
            Returns the triangles subdivision of the current planar subdivision. 
            </summary>
            <remarks>The triangles might contains virtual points that do not belongs to the inserted points, if you do not want those points, set <paramref name="includeVirtualPoints"> to false</paramref></remarks>
            <returns>The triangles subdivision in the current planar subdivision</returns>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.DisposeObject">
            <summary>
            Release unmanaged resources
            </summary>
        </member>
        <member name="T:Emgu.CV.VoronoiFacet">
            <summary>
            A Voronoi Facet
            </summary>
        </member>
        <member name="M:Emgu.CV.VoronoiFacet.#ctor(System.Drawing.PointF,System.Drawing.PointF[])">
            <summary>
            Create a Voronoi facet using the specific <paramref name="point"/> and <paramref name="polyline"/>
            </summary>
            <param name="point">The point this facet associate with </param>
            <param name="polyline">The points that defines the contour of this facet</param>
        </member>
        <member name="P:Emgu.CV.VoronoiFacet.Point">
            <summary>
            The point this facet associates to
            </summary>
        </member>
        <member name="P:Emgu.CV.VoronoiFacet.Vertices">
            <summary>
            Get or set the vertices of this facet
            </summary>
        </member>
        <member name="T:Emgu.CV.Tiff.TiffWriter`2">
            <summary>
            A class that can be used for writing geotiff
            </summary>
            <typeparam name="TColor">The color type of the image to be written</typeparam>
            <typeparam name="TDepth">The depth type of the image to be written</typeparam>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.#ctor(System.String)">
            <summary>
            Create a tiff writer to save an image
            </summary>
            <param name="fileName">The file name to be saved</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.WriteImage(Emgu.CV.Image{`0,`1})">
            <summary>
            Write the image to the tiff file
            </summary>
            <param name="image">The image to be written</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.WriteGeoTag(System.Double[],System.Double[])">
            <summary>
            Write the geo information into the tiff file
            </summary>
            <param name="modelTiepoint">Model Tie Point, an array of size 6</param>
            <param name="modelPixelScale">Model pixel scale, an array of size 3</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.DisposeObject">
            <summary>
            Release the writer and write all data on to disk.
            </summary>
        </member>
        <member name="T:Emgu.CV.Tiff.TileTiffWriter`2">
            <summary>
            A writer for writing GeoTiff
            </summary>
            <typeparam name="TColor">The color type of the image to be written</typeparam>
            <typeparam name="TDepth">The depth type of the image to be written</typeparam>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.#ctor(System.String,System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Create a TitleTiffWriter.
            </summary>
            <param name="fileName">The name of the file to be written to</param>
            <param name="imageSize">The size of the image</param>
            <param name="tileSize">The tile size in pixels</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.WriteTile(System.Int32,System.Int32,Emgu.CV.Image{`0,`1})">
            <summary>
            Write a tile into the tile tiff
            </summary>
            <param name="rowNumber">The starting row for the tile</param>
            <param name="colNumber">The starting col for the tile</param>
            <param name="tile">The tile to be written</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.WriteImage(Emgu.CV.Image{`0,`1})">
            <summary>
            Write the whole image as tile tiff
            </summary>
            <param name="image">The image to be written</param>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileSizeInBytes">
            <summary>
            Get the equivalent size for a tile of data as it would be returned in a call to TIFFReadTile or as it would be expected in a call to TIFFWriteTile. 
            </summary>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileRowSizeInBytes">
            <summary>
            Get the number of bytes of a row of data in a tile. 
            </summary>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileSize">
            <summary>
            Get tile size in pixels.
            </summary>
        </member>
        <member name="T:Emgu.CV.TimedImage`2">
            <summary> 
            The Image which contains time stamp which specified what time this image is created 
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor">
            <summary>
            Create a empty Image 
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height, depth and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an empty Image of the specified width and height
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="P:Emgu.CV.TimedImage`2.Timestamp">
            <summary> 
            The time this image is captured
            </summary>
        </member>
        <member name="T:Emgu.CV.UMat">
            <summary>
            The equivalent of cv::Mat, should only be used if you know what you are doing.
            In most case you should use the Matrix class instead
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor">
            <summary>
            Create an empty cv::UMat
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Create a umat of the specific type.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(Emgu.CV.UMat,System.Drawing.Rectangle)">
            <summary>
            Get the Umat header for the specific roi of the parent
            </summary>
            <param name="parent">The parent Umat</param>
            <param name="roi">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.UMat.Create(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix element depth type.</param>
            <param name="channels">New matrix number of channels</param>
        </member>
        <member name="M:Emgu.CV.UMat.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Copy the data in this mat to the other mat
            </summary>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
            <param name="m">The input array to copy to</param>
        </member>
        <member name="M:Emgu.CV.UMat.SetTo(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value">Assigned scalar converted to the actual array type.</param>
            <param name="mask">Operation mask of the same size as the umat.</param>
        </member>
        <member name="M:Emgu.CV.UMat.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value">Assigned scalar value.</param>
            <param name="mask">Operation mask of the same size as the umat.</param>
        </member>
        <member name="M:Emgu.CV.UMat.ToMat(Emgu.CV.CvEnum.AccessType)">
            <summary>
            Return the Mat representation of the UMat
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.GetInputArray">
            <summary>
            Pointer to the InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.GetOutputArray">
            <summary>
            Pointer to the OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.GetInputOutputArray">
            <summary>
            Pointer to the InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns>A new mat header that has different shape</returns>
        </member>
        <member name="M:Emgu.CV.UMat.ToImage``2">
            <summary>
            Convert this Mat to Image
            </summary>
            <typeparam name="TColor">The type of Color</typeparam>
            <typeparam name="TDepth">The type of Depth</typeparam>
            <returns>The image</returns>
        </member>
        <member name="M:Emgu.CV.UMat.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.UMat.ConvertTo(Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">Output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">Optional scale factor.</param>
            <param name="beta">Optional delta added to the scaled values.</param>
        </member>
        <member name="M:Emgu.CV.UMat.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.UMat.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.UMat.Clone">
            <summary>
            Make a clone of the current UMat.
            </summary>
            <returns>A clone of the current UMat.</returns>
        </member>
        <member name="P:Emgu.CV.UMat.Size">
            <summary>
            The size of this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Rows">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Cols">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.NumberOfChannels">
            <summary>
            Get the number of channels
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Depth">
            <summary>
            Depth type
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.ElementSize">
            <summary>
            The size of the elements in this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.IsEmpty">
            <summary>
            Indicates if this cv::UMat is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Bitmap">
            <summary>
            The Get property provide a more efficient way to convert Image&lt;Gray, Byte&gt;, Image&lt;Bgr, Byte&gt; and Image&lt;Bgra, Byte&gt; into Bitmap
            such that the image data is <b>shared</b> with Bitmap. 
            If you change the pixel value on the Bitmap, you change the pixel values on the Image object as well!
            For other types of image this property has the same effect as ToBitmap()
            <b>Take extra caution not to use the Bitmap after the Image object is disposed</b>
            The Set property convert the bitmap to this Image type.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.CvException">
            <summary>
            The default exception to be thrown when error encounter in Open CV 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.CvException.#ctor(System.Int32,System.String,System.String,System.String,System.Int32)">
            <summary>
            The default exception to be thrown when error is encountered in Open CV 
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
        </member>
        <member name="P:Emgu.CV.Util.CvException.Status">
            <summary>
            The numeric code for error status
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.ErrorStr">
            <summary>
            The corresponding error string for the Status code
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.FunctionName">
            <summary>
            The name of the function the error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.ErrorMessage">
            <summary>
            A description of the error
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.FileName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.Line">
            <summary>
            The line number in the souce where error is encountered
            </summary>
        </member>
        <member name="T:Emgu.CV.CvString">
            <summary>
            Wrapper for cv::String. This class support UTF-8 chars.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvString.#ctor(System.String)">
            <summary>
            Create a CvString from System.String
            </summary>
            <param name="s">The System.String object to be converted to CvString</param>
        </member>
        <member name="M:Emgu.CV.CvString.#ctor">
            <summary>
            Create an empty CvString
            </summary>
        </member>
        <member name="M:Emgu.CV.CvString.ToString">
            <summary>
            Get the string representation of the CvString
            </summary>
            <returns>The string representation of the CvString</returns>
        </member>
        <member name="M:Emgu.CV.CvString.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.CvToolbox">
            <summary>
            Utilities class
            </summary>
        </member>
        <member name="F:Emgu.CV.Util.CvToolbox.GrayscalePalette">
            <summary>
            The ColorPalette of Grayscale for Bitmap Format8bppIndexed
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.ColorPaletteToLookupTable(System.Drawing.Imaging.ColorPalette,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@)">
            <summary>
            Convert the color pallette to four lookup tables
            </summary>
            <param name="pallette">The color pallette to transform</param>
            <param name="bTable">Lookup table for the B channel</param>
            <param name="gTable">Lookup table for the G channel</param>
            <param name="rTable">Lookup table for the R channel</param>
            <param name="aTable">Lookup table for the A channel</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.OptimizeCV(System.Boolean)">
            <summary>
            Enable or diable IPL optimization for opencv
            </summary>
            <param name="enable">true to enable optimization, false to disable</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMatrixFromArrays``1(``0[][])">
            <summary>
            Convert arrays of data to matrix
            </summary>
            <param name="data">Arrays of data</param>
            <returns>A two dimension matrix that represent the array</returns>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMatrixFromPoints(Emgu.CV.Structure.MCvPoint2D64f[][])">
            <summary>
            Convert arrays of points to matrix
            </summary>
            <param name="points">Arrays of points</param>
            <returns>A two dimension matrix that represent the points</returns>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMinMax(System.Collections.Generic.IEnumerable{Emgu.CV.Structure.MCvPoint3D64f},Emgu.CV.Structure.MCvPoint3D64f@,Emgu.CV.Structure.MCvPoint3D64f@)">
            <summary>
            Compute the minimum and maximum value from the points
            </summary>
            <param name="points">The points</param>
            <param name="min">The minimum x,y,z values</param>
            <param name="max">The maximum x,y,z values</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetColorCvtCode(System.Type,System.Type)">
            <summary>
            Given the source and destination color type, compute the color conversion code for CvInvoke.cvCvtColor function
            </summary>
            <param name="srcColorType">The source color type. Must be a type inherited from IColor</param>
            <param name="destColorType">The dest color type. Must be a type inherited from IColor</param>
            <returns>The color conversion code for CvInvoke.cvCvtColor function</returns>
        </member>
        <member name="T:Emgu.CV.Util.DataLogger">
            <summary>
            A DataLogger for unmanaged code to log data back to managed code, using callback.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.#ctor(System.Int32)">
            <summary>
            Create a MessageLogger and register the callback function
            </summary>
            <param name="logLevel">The log level.</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.Log(System.IntPtr,System.Int32)">
            <summary>
            Log some data
            </summary>
            <param name="data">Pointer to some unmanaged data</param>
            <param name="logLevel">The logLevel. The Log function only logs when the <paramref name="logLevel"/> is greater or equals to the DataLogger's logLevel</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.DisposeObject">
            <summary>
            Release the DataLogger and all the unmanaged memory associated with it.
            </summary>
        </member>
        <member name="E:Emgu.CV.Util.DataLogger.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.DataLogger`1">
            <summary>
            A generic version of the DataLogger
            </summary>
            <typeparam name="T">The supported type includes System.String and System.ValueType</typeparam>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.#ctor(System.Int32)">
            <summary>
            Create a new DataLogger
            </summary>
            <param name="logLevel">The log level.</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.Log(`0,System.Int32)">
            <summary>
            Log some data
            </summary>
            <param name="data">The data to be logged</param>
            <param name="logLevel">The logLevel. The Log function only logs when the <paramref name="logLevel"/> is greater or equals to the DataLogger's logLevel</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.op_Implicit(Emgu.CV.Util.DataLogger{`0})~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The DataLogger</param>
            <returns>The unmanaged pointer for this DataLogger</returns>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this DataLogger
            </summary>
        </member>
        <member name="E:Emgu.CV.Util.DataLogger`1.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.DataLogger`1.Ptr">
            <summary>
            Pointer to the unmanaged object
            </summary>
        </member>
        <member name="E:Emgu.CV.Util.DataLoggerHelper.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="T:Emgu.CV.ParamType">
            <summary>
            The type of the parameter
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.Int32">
            <summary>
            Int32 
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.Boolean">
            <summary>
            Boolean
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.Double">
            <summary>
            Double
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.String">
            <summary>
            String
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.Mat">
            <summary>
            Mat
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.VectorOfMat">
            <summary>
            VectorOfMat
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.Algorithm">
            <summary>
            Algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.Float">
            <summary>
            Float
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.UInt32">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.UInt64">
            <summary>
            UInt64
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamType.UChar">
            <summary>
            Unsigned char
            </summary>
        </member>
        <member name="T:Emgu.CV.ParamDef">
            <summary>
            The definition of the parameter.
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamDef.Name">
            <summary>
            The name of the parameter
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamDef.Type">
            <summary>
            The type of the parameter
            </summary>
        </member>
        <member name="F:Emgu.CV.ParamDef.Help">
            <summary>
            Help documents on the parameter
            </summary>
        </member>
        <member name="T:Emgu.CV.AlgorithmExtensions">
            <summary>
            Extension methods to the IAlgorithm interface
            </summary>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.GetInt(Emgu.CV.IAlgorithm,System.String)">
            <summary>
            Returns the algorithm parameter
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="name">The name of the parameter</param>
            <returns>The value of the parameter</returns>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.SetInt(Emgu.CV.IAlgorithm,System.String,System.Int32)">
            <summary>
            Sets the algorithm parameter
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="name">The name of the parameter</param>
            <param name="value">The value of the parameter</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.GetDouble(Emgu.CV.IAlgorithm,System.String)">
            <summary>
            Returns the algorithm parameter
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="name">The name of the parameter</param>
            <returns>The value of the parameter</returns>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.SetDouble(Emgu.CV.IAlgorithm,System.String,System.Double)">
            <summary>
            Sets the algorithm parameter
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="name">The name of the parameter</param>
            <param name="value">The value of the parameter</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.GetString(Emgu.CV.IAlgorithm,System.String)">
            <summary>
            Returns the algorithm parameter
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="name">The name of the parameter</param>
            <returns>The value of the parameter</returns>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.SetString(Emgu.CV.IAlgorithm,System.String,System.String)">
            <summary>
            Sets the algorithm parameter
            </summary>
            <param name="algorithm">The algorithm</param>
            <param name="name">The name of the parameter</param>
            <param name="value">The value of the parameter</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.GetParams(Emgu.CV.IAlgorithm)">
            <summary>
            Get the list of parameter definitions
            </summary>
            <param name="algorithm">The algorithm to retrieve the parameter list from</param>
            <returns>The list of parameter definitions</returns>
        </member>
        <member name="P:Emgu.CV.AlgorithmExtensions.AlgorithmList">
            <summary>
            Get the list of algorithms available from opencv
            </summary>
        </member>
        <member name="T:Emgu.CV.InputArray">
            <summary>
            This is the proxy class for passing read-only input arrays into OpenCV functions.
            </summary>
        </member>
        <member name="M:Emgu.CV.InputArray.#ctor(System.IntPtr)">
            <summary>
            Create a Input array from an existing unmanaged inputArray pointer
            </summary>
            <param name="inputArrayPtr">The unmanaged pointer the the InputArray</param>
        </member>
        <member name="M:Emgu.CV.InputArray.GetEmpty">
            <summary>
            Get an empty input array
            </summary>
            <returns>An empty input array</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetMat(System.Int32)">
            <summary>
            Get the Mat from the input array
            </summary>
            <param name="idx">The index, in case if this is an VectorOfMat</param>
            <returns>The Mat</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetUMat(System.Int32)">
            <summary>
            Get the UMat from the input array
            </summary>
            <param name="idx">The index, in case if this is an VectorOfUMat</param>
            <returns>The UMat</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetSize(System.Int32)">
            <summary>
            Get the size of the input array
            </summary>
            <param name="idx">The optional index</param>
            <returns>The size of the input array</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.IsEmpty">
            <summary>
            Return true if the input array is empty
            </summary>
            <returns>True if the input array is empty</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetDepth(System.Int32)">
            <summary>
            Get the depth type
            </summary>
            <param name="idx">The optional index</param>
            <returns>The depth type</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetChannels(System.Int32)">
            <summary>
            Get the number of channels
            </summary>
            <param name="idx">The optional index</param>
            <returns>The number of channels</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this InputArray
            </summary>
        </member>
        <member name="T:Emgu.CV.InputOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for input/output function parameters.
            </summary>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.#ctor(System.IntPtr)">
            <summary>
            Create an InputOutputArray from an existing unmanaged inputOutputArray pointer
            </summary>
            <param name="inputOutputArrayPtr">The pointer to the existing inputOutputArray</param>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.GetEmpty">
            <summary>
            Get an empty InputOutputArray
            </summary>
            <returns>An empty InputOutputArray</returns>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.DisposeObject">
            <summary>
            Release all the memory associated with this InputOutputArry
            </summary>
        </member>
        <member name="T:Emgu.CV.OutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for output function parameters. 
            </summary>
        </member>
        <member name="M:Emgu.CV.OutputArray.#ctor(System.IntPtr)">
            <summary>
            Create an OutputArray from an existing unmanaged outputArray pointer
            </summary>
            <param name="outputArrayPtr">The pointer to the unmanaged outputArray</param>
        </member>
        <member name="M:Emgu.CV.OutputArray.GetEmpty">
            <summary>
            Get an empty output array
            </summary>
            <returns>An empty output array</returns>
        </member>
        <member name="M:Emgu.CV.OutputArray.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this output array.
            </summary>
        </member>
        <member name="T:Emgu.CV.ScalarArray">
            <summary>
            An implementation of IInputArray intented to convert data to IInputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.ScalarArray.#ctor(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create an InputArray from MCvScalar
            </summary>
            <param name="scalar">The MCvScalar to be converted to InputArray</param>
        </member>
        <member name="M:Emgu.CV.ScalarArray.#ctor(System.Double)">
            <summary>
            Create an InputArray from a double value
            </summary>
            <param name="scalar">The double value to be converted to InputArray</param>
        </member>
        <member name="M:Emgu.CV.ScalarArray.op_Explicit(System.Double)~Emgu.CV.ScalarArray">
            <summary>
            Convert double scalar to InputArray
            </summary>
            <param name="scalar">The double scalar</param>
            <returns>The InputArray</returns>
        </member>
        <member name="M:Emgu.CV.ScalarArray.op_Explicit(Emgu.CV.Structure.MCvScalar)~Emgu.CV.ScalarArray">
            <summary>
            Convert MCvSalar to InputArray
            </summary>
            <param name="scalar">The MCvScalar</param>
            <returns>The InputArray</returns>
        </member>
        <member name="M:Emgu.CV.ScalarArray.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.ScalarArray.GetInputArray">
            <summary>
            The pointer to the input array
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.StructSize">
            <summary>
            Cache the size of various header in bytes
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.PointF">
            <summary>
            The size of PointF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.RangF">
            <summary>
            The size of RangF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvPoint2D64f">
            <summary>
            The size of PointF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvMat">
            <summary>
            The size of MCvMat
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvSeq">
            <summary>
            The size of MCvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvContour">
            <summary>
            The size of MCvContour
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MIplImage">
            <summary>
            The size of IplImage
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvSeqBlock">
            <summary>
            The size of CvSeqBlock
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvPoint3D32f">
            <summary>
            The size of MCvPoint3D32f
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvMatND">
            <summary>
            The size of MCvMatND
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvBlob">
            <summary>
            The size of MCvBlob
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.TbbTaskScheduler">
            <summary>
            This class canbe used to initiate TBB. Only usefull if it is compiled with TBB support
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.TbbTaskScheduler.#ctor">
            <summary>
            Initialize the TBB task scheduler
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.TbbTaskScheduler.DisposeObject">
            <summary>
            Release the TBB task scheduler
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfByte">
            <summary>
            Wraped class of the C++ standard vector of Byte.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor">
            <summary>
            Create an empty standard vector of Byte
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Byte of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Byte[])">
            <summary>
            Create an standard vector of Byte with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Push(System.Byte[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.ToArray">
            <summary>
            Convert the standard vector to an array of Byte
            </summary>
            <returns>An array of Byte</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfCvString">
            <summary>
            Wraped class of the C++ standard vector of CvString.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor">
            <summary>
            Create an empty standard vector of CvString
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor(System.Int32)">
            <summary>
            Create an standard vector of CvString of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor(Emgu.CV.CvString[])">
            <summary>
            Create an standard vector of CvString with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Push(Emgu.CV.CvString)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Push(Emgu.CV.CvString[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfDMatch">
            <summary>
            Wraped class of the C++ standard vector of DMatch.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor">
            <summary>
            Create an empty standard vector of DMatch
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(System.Int32)">
            <summary>
            Create an standard vector of DMatch of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(Emgu.CV.Structure.MDMatch[])">
            <summary>
            Create an standard vector of DMatch with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Push(Emgu.CV.Structure.MDMatch[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.ToArray">
            <summary>
            Convert the standard vector to an array of DMatch
            </summary>
            <returns>An array of DMatch</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfDouble">
            <summary>
            Wraped class of the C++ standard vector of Double.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor">
            <summary>
            Create an empty standard vector of Double
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Double of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Double[])">
            <summary>
            Create an standard vector of Double with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Push(System.Double[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.ToArray">
            <summary>
            Convert the standard vector to an array of Double
            </summary>
            <returns>An array of Double</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfFloat">
            <summary>
            Wraped class of the C++ standard vector of Float.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor">
            <summary>
            Create an empty standard vector of Float
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Float of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Single[])">
            <summary>
            Create an standard vector of Float with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Push(System.Single[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.ToArray">
            <summary>
            Convert the standard vector to an array of Float
            </summary>
            <returns>An array of Float</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfInt">
            <summary>
            Wraped class of the C++ standard vector of Int.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor">
            <summary>
            Create an empty standard vector of Int
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Int of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Int32[])">
            <summary>
            Create an standard vector of Int with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Push(System.Int32[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.ToArray">
            <summary>
            Convert the standard vector to an array of Int
            </summary>
            <returns>An array of Int</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfKeyPoint">
            <summary>
            Wraped class of the C++ standard vector of KeyPoint.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor">
            <summary>
            Create an empty standard vector of KeyPoint
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(System.Int32)">
            <summary>
            Create an standard vector of KeyPoint of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(Emgu.CV.Structure.MKeyPoint[])">
            <summary>
            Create an standard vector of KeyPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Push(Emgu.CV.Structure.MKeyPoint[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.ToArray">
            <summary>
            Convert the standard vector to an array of KeyPoint
            </summary>
            <returns>An array of KeyPoint</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByImageBorder(System.Drawing.Size,System.Int32)">
            <summary>
            Remove keypoints within borderPixels of an image edge.
            </summary>
            <param name="imageSize">Image size</param>
            <param name="borderSize">Border size in pixel</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByKeypointSize(System.Single,System.Single)">
            <summary>
            Remove keypoints of sizes out of range.
            </summary>
            <param name="minSize">Minimum size</param>
            <param name="maxSize">Maximum size</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByPixelsMask(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Remove keypoints from some image by mask for pixels of this image.
            </summary>
            <param name="mask">The mask</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfMat">
            <summary>
            Wraped class of the C++ standard vector of Mat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor">
            <summary>
            Create an empty standard vector of Mat
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Mat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor(Emgu.CV.Mat[])">
            <summary>
            Create an standard vector of Mat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push(Emgu.CV.Mat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push(Emgu.CV.Mat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push``1(Emgu.CV.CvArray{``0})">
            <summary>
            Convert a CvArray to cv::Mat and push it into the vector
            </summary>
            <typeparam name="TDepth">The type of depth of the cvArray</typeparam>
            <param name="cvArray">The cvArray to be pushed into the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push``1(Emgu.CV.CvArray{``0}[])">
            <summary>
            Convert a group of CvArray to cv::Mat and push them into the vector
            </summary>
            <typeparam name="TDepth">The type of depth of the cvArray</typeparam>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfOclPlatformInfo">
            <summary>
            Wraped class of the C++ standard vector of OclPlatformInfo.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor">
            <summary>
            Create an empty standard vector of OclPlatformInfo
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor(System.Int32)">
            <summary>
            Create an standard vector of OclPlatformInfo of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor(Emgu.CV.OclPlatformInfo[])">
            <summary>
            Create an standard vector of OclPlatformInfo with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Push(Emgu.CV.OclPlatformInfo)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Push(Emgu.CV.OclPlatformInfo[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPoint">
            <summary>
            Wraped class of the C++ standard vector of Point.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor">
            <summary>
            Create an empty standard vector of Point
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Point of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Drawing.Point[])">
            <summary>
            Create an standard vector of Point with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Push(System.Drawing.Point[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.ToArray">
            <summary>
            Convert the standard vector to an array of Point
            </summary>
            <returns>An array of Point</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPoint3D32F">
            <summary>
            Wraped class of the C++ standard vector of Point3D32F.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor">
            <summary>
            Create an empty standard vector of Point3D32F
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Point3D32F of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(Emgu.CV.Structure.MCvPoint3D32f[])">
            <summary>
            Create an standard vector of Point3D32F with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Push(Emgu.CV.Structure.MCvPoint3D32f[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.ToArray">
            <summary>
            Convert the standard vector to an array of Point3D32F
            </summary>
            <returns>An array of Point3D32F</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPointF">
            <summary>
            Wraped class of the C++ standard vector of PointF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor">
            <summary>
            Create an empty standard vector of PointF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Int32)">
            <summary>
            Create an standard vector of PointF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Drawing.PointF[])">
            <summary>
            Create an standard vector of PointF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Push(System.Drawing.PointF[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.ToArray">
            <summary>
            Convert the standard vector to an array of PointF
            </summary>
            <returns>An array of PointF</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfRect">
            <summary>
            Wraped class of the C++ standard vector of Rect.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor">
            <summary>
            Create an empty standard vector of Rect
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Rect of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Drawing.Rectangle[])">
            <summary>
            Create an standard vector of Rect with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Push(System.Drawing.Rectangle[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.ToArray">
            <summary>
            Convert the standard vector to an array of Rect
            </summary>
            <returns>An array of Rect</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfTriangle2DF">
            <summary>
            Wraped class of the C++ standard vector of Triangle2DF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor">
            <summary>
            Create an empty standard vector of Triangle2DF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Triangle2DF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(Emgu.CV.Structure.Triangle2DF[])">
            <summary>
            Create an standard vector of Triangle2DF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Push(Emgu.CV.Structure.Triangle2DF[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.ToArray">
            <summary>
            Convert the standard vector to an array of Triangle2DF
            </summary>
            <returns>An array of Triangle2DF</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfUMat">
            <summary>
            Wraped class of the C++ standard vector of UMat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor">
            <summary>
            Create an empty standard vector of UMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of UMat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor(Emgu.CV.UMat[])">
            <summary>
            Create an standard vector of UMat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Push(Emgu.CV.UMat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Push(Emgu.CV.UMat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfDMatch">
            <summary>
            Wraped class of the C++ standard vector of VectorOfDMatch.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor">
            <summary>
            Create an empty standard vector of VectorOfDMatch
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfDMatch of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(Emgu.CV.Util.VectorOfDMatch[])">
            <summary>
            Create an standard vector of VectorOfDMatch with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Push(Emgu.CV.Util.VectorOfDMatch)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Push(Emgu.CV.Util.VectorOfDMatch[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(Emgu.CV.Structure.MDMatch[][])">
            <summary>
            Create the standard vector of VectorOfDMatch 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfInt">
            <summary>
            Wraped class of the C++ standard vector of VectorOfInt.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor">
            <summary>
            Create an empty standard vector of VectorOfInt
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfInt of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(Emgu.CV.Util.VectorOfInt[])">
            <summary>
            Create an standard vector of VectorOfInt with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Push(Emgu.CV.Util.VectorOfInt)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Push(Emgu.CV.Util.VectorOfInt[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(System.Int32[][])">
            <summary>
            Create the standard vector of VectorOfInt 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPoint">
            <summary>
            Wraped class of the C++ standard vector of VectorOfPoint.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPoint
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPoint of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(Emgu.CV.Util.VectorOfPoint[])">
            <summary>
            Create an standard vector of VectorOfPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Push(Emgu.CV.Util.VectorOfPoint)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Push(Emgu.CV.Util.VectorOfPoint[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(System.Drawing.Point[][])">
            <summary>
            Create the standard vector of VectorOfPoint 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPoint3D32F">
            <summary>
            Wraped class of the C++ standard vector of VectorOfPoint3D32F.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPoint3D32F
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPoint3D32F of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(Emgu.CV.Util.VectorOfPoint3D32F[])">
            <summary>
            Create an standard vector of VectorOfPoint3D32F with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfPoint3D32F)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfPoint3D32F[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(Emgu.CV.Structure.MCvPoint3D32f[][])">
            <summary>
            Create the standard vector of VectorOfPoint3D32F 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPointF">
            <summary>
            Wraped class of the C++ standard vector of VectorOfPointF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPointF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPointF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(Emgu.CV.Util.VectorOfPointF[])">
            <summary>
            Create an standard vector of VectorOfPointF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Push(Emgu.CV.Util.VectorOfPointF)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Push(Emgu.CV.Util.VectorOfPointF[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(System.Drawing.PointF[][])">
            <summary>
            Create the standard vector of VectorOfPointF 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="T:Emgu.CV.Util.ZlibCompression">
            <summary>
            Use zlib included in OpenCV to perform in-memory binary compression and decompression
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.ZlibCompression.Compress(System.Byte[],System.Int32)">
            <summary>
            Compress the data using the specific compression level
            </summary>
            <param name="original">The data to be compressed</param>
            <param name="compressionLevel">The compression level, 0-9 where 0 mean no compression at all</param>
            <returns>The compressed bytes</returns>
        </member>
        <member name="M:Emgu.CV.Util.ZlibCompression.Uncompress(System.Byte[],System.Int32)">
            <summary>
            Uncompress the data 
            </summary>
            <param name="compressedData">The compressed data</param>
            <param name="estimatedUncompressedSize">The estimated size fo the uncompress data. Must be large enough to hold the decompressed data.</param>
            <returns>The decompressed data</returns>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BackgroundSubtractor">
            <summary>
            An abstract class that can be use the perform background / forground detection.
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractor.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Update the background model
            </summary>
            <param name="image">The image that is used to update the background model</param>
            <param name="learningRate">Use -1 for default</param>
            <param name="fgMask">The output forground mask</param>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BackgroundSubtractorKNN">
            <summary>
            K-nearest neighbors - based Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractorKNN.#ctor(System.Int32,System.Double,System.Boolean)">
            <summary>
            Create a K-nearest neighbors - based Background/Foreground Segmentation Algorithm.
            </summary>
            <param name="history">Length of the history.</param>
            <param name="dist2Threshold">Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update.</param>
            <param name="detectShadows">If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractorKNN.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this background model.
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BackgroundSubtractorMOG2">
            <summary>
            The class implements the following algorithm:
            "Improved adaptive Gaussian mixture model for background subtraction"
            Z.Zivkovic
            International Conference Pattern Recognition, UK, August, 2004.
            http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractorMOG2.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            Create an "Improved adaptive Gaussian mixture model for background subtraction".
            </summary>
            <param name="history">The length of the history.</param>
            <param name="varThreshold">The maximum allowed number of mixture components. Actual number is determined dynamically per pixel.</param>
            <param name="shadowDetection">If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractorMOG2.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this background model.
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoWriter">
            <summary>
            Create a video writer that write images to video format
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Drawing.Size,System.Boolean)">
            <summary>
            Create a video writer using the specific information.
            On windows, it will open a codec selection dialog.
            On linux, it will use the default codec for the specified filename
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="fps">frame rate per second</param>
            <param name="size">the size of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Int32,System.Drawing.Size,System.Boolean)">
            <summary>
            Create a video writer using the specific information
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="compressionCode">Compression code. Usually computed using CvInvoke.CV_FOURCC. 
            On windows use -1 to open a codec selection dialog.
            On Linux, use CvInvoke.CV_FOURCC('I', 'Y', 'U', 'V') for default codec for the specific file name.
            </param>
            <param name="fps">frame rate per second</param>
            <param name="size">the size of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Write(Emgu.CV.Mat)">
            <summary>
            Write a single frame to the video writer
            </summary>
            <param name="frame">The frame to be written to the video writer</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Fourcc(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Generate 4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <param name="c3"></param>
            <param name="c4"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.VideoWriter.DisposeObject">
            <summary>
            Release the video writer and all the memory associate with it
            </summary>
        </member>
    </members>
</doc>
